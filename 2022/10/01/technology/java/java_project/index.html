<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.7.2/css/all.min.css" integrity="sha256-dABdfBfUoC8vJUBOwGVdm8L9qlMWaHTIfXt+7GnZCIo=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.22.0","exturl":false,"sidebar":{"position":"right","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":true,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="实际项目中，Java项目遇到的问题，包含MQ、SpringBoot、Redis、MySQL、Kafka 等…">
<meta property="og:type" content="article">
<meta property="og:title" content="Java项目遇到的问题">
<meta property="og:url" content="http://example.com/2022/10/01/technology/java/java_project/index.html">
<meta property="og:site_name" content="zhyyao">
<meta property="og:description" content="实际项目中，Java项目遇到的问题，包含MQ、SpringBoot、Redis、MySQL、Kafka 等…">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2022-10-01T10:51:53.000Z">
<meta property="article:modified_time" content="2025-02-28T11:14:33.367Z">
<meta property="article:author" content="zhyyao">
<meta property="article:tag" content="面试题">
<meta property="article:tag" content="Java">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/2022/10/01/technology/java/java_project/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://example.com/2022/10/01/technology/java/java_project/","path":"2022/10/01/technology/java/java_project/","title":"Java项目遇到的问题"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Java项目遇到的问题 | zhyyao</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">zhyyao</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">zhyyao-blogs</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-首页"><a href="/" rel="section"><i class="fas fas fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-分类"><a href="/categories/" rel="section"><i class="fas fa-folder-open fa-fw"></i>分类</a></li><li class="menu-item menu-item-时间轴"><a href="/archives/" rel="section"><i class="fas fa-archive fa-fw"></i>时间轴</a></li><li class="menu-item menu-item-标签"><a href="/tags/" rel="section"><i class="fas fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-关于我"><a href="/about/" rel="section"><i class="fas fa-heart fa-fw"></i>关于我</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
      <div class="search-header">
        <span class="search-icon">
          <i class="fa fa-search"></i>
        </span>
        <div class="search-input-container">
          <input autocomplete="off" autocapitalize="off" maxlength="80"
                placeholder="搜索..." spellcheck="false"
                type="search" class="search-input">
        </div>
        <span class="popup-btn-close" role="button">
          <i class="fa fa-times-circle"></i>
        </span>
      </div>
      <div class="search-result-container">
        <div class="search-result-icon">
          <i class="fa fa-spinner fa-pulse fa-5x"></i>
        </div>
      </div>
    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#MQ-%E7%9B%B8%E5%85%B3"><span class="nav-number">1.</span> <span class="nav-text">MQ 相关</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#MQ-%E5%A4%A7%E9%87%8F%E6%9C%AA%E8%AE%A2%E9%98%85%E6%B6%88%E6%81%AF%E5%A4%84%E7%90%86"><span class="nav-number">1.1.</span> <span class="nav-text">MQ 大量未订阅消息处理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%8B%A5%E5%9B%A0%E4%B8%BA%E7%A7%AF%E5%8E%8B%E6%97%B6%E9%97%B4%E5%A4%AA%E4%B9%85%EF%BC%8C%E5%AF%BC%E8%87%B4%E6%B6%88%E6%81%AF%E4%B8%A2%E5%A4%B1%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86"><span class="nav-number">1.2.</span> <span class="nav-text">若因为积压时间太久，导致消息丢失如何处理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%8B%A5%E7%A7%AF%E5%8E%8B%E5%A4%AA%E5%A4%9A%EF%BC%8C%E5%AF%BC%E8%87%B4-MQ-%E6%BB%A1%E4%BA%86%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86"><span class="nav-number">1.3.</span> <span class="nav-text">若积压太多，导致 MQ 满了如何处理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E6%9E%9C-MQ-%E5%92%8C-MySQL-%E5%90%8C%E6%97%B6%E6%8C%82%E4%BA%86%EF%BC%8C%E6%80%8E%E4%B9%88%E5%A4%84%E7%90%86"><span class="nav-number">1.4.</span> <span class="nav-text">如果 MQ 和 MySQL 同时挂了，怎么处理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#RabbitMQ-%E7%9A%84%E5%8E%9F%E7%90%86"><span class="nav-number">1.5.</span> <span class="nav-text">RabbitMQ 的原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B6%88%E6%81%AF%E4%B8%A2%E5%A4%B1%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86"><span class="nav-number">1.6.</span> <span class="nav-text">消息丢失如何处理</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Redis-%E7%9B%B8%E5%85%B3"><span class="nav-number">2.</span> <span class="nav-text">Redis 相关</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E3%80%81%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF%E5%92%8C%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9"><span class="nav-number">2.1.</span> <span class="nav-text">缓存穿透、缓存击穿和缓存雪崩</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Redis-%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-number">2.2.</span> <span class="nav-text">Redis 的数据类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Redis-%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">2.3.</span> <span class="nav-text">Redis 的数据结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Redis-%E7%9A%84%E6%8C%81%E4%B9%85%E5%8C%96"><span class="nav-number">2.4.</span> <span class="nav-text">Redis 的持久化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B3%E4%BA%8E-Redlock"><span class="nav-number">2.5.</span> <span class="nav-text">关于 Redlock</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Etcd-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81"><span class="nav-number">2.6.</span> <span class="nav-text">Etcd 分布式锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Redis-%E7%9A%84%E8%BF%87%E6%9C%9F%E7%AD%96%E7%95%A5%E5%92%8C%E6%B7%98%E6%B1%B0%E6%9C%BA%E5%88%B6"><span class="nav-number">2.7.</span> <span class="nav-text">Redis 的过期策略和淘汰机制</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ES-%E7%9B%B8%E5%85%B3"><span class="nav-number">3.</span> <span class="nav-text">ES 相关</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Spring-%E7%9B%B8%E5%85%B3"><span class="nav-number">4.</span> <span class="nav-text">Spring 相关</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Spring-Boot-%E5%B8%B8%E7%94%A8%E7%BB%84%E4%BB%B6"><span class="nav-number">4.1.</span> <span class="nav-text">Spring Boot 常用组件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Spring-Boot-%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B%E4%B8%AD-URL-%E5%86%B2%E7%AA%81%EF%BC%8C%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E6%8A%A5%E9%94%99"><span class="nav-number">4.2.</span> <span class="nav-text">Spring Boot 启动过程中 URL 冲突，原理是什么，为什么会报错</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Spring%E3%80%81Spring-MVC%E3%80%81Spring-Boot-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">4.3.</span> <span class="nav-text">Spring、Spring MVC、Spring Boot 的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Spring-%E7%9A%84%E5%90%AF%E5%8A%A8%E5%8E%9F%E7%90%86"><span class="nav-number">4.4.</span> <span class="nav-text">Spring 的启动原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Spring-Boot-%E7%9A%84%E5%90%AF%E5%8A%A8%E7%B1%BB%EF%BC%8C%E4%BD%BF%E7%94%A8-SpringBootApplication-%E6%B3%A8%E8%A7%A3%E3%80%82"><span class="nav-number">4.5.</span> <span class="nav-text">Spring Boot 的启动类，使用 @SpringBootApplication 注解。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Spring-Boot-%E6%AF%94%E8%BE%83%E9%87%8D%E8%A6%81%E7%9A%84%E6%B3%A8%E8%A7%A3"><span class="nav-number">4.6.</span> <span class="nav-text">Spring Boot 比较重要的注解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#BeanFactory-%E5%92%8C-ApplicationContext-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">4.7.</span> <span class="nav-text">BeanFactory 和 ApplicationContext 的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#BeanFactory-%E5%92%8C-FactoryBean-%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C%E8%81%94%E7%B3%BB"><span class="nav-number">4.8.</span> <span class="nav-text">BeanFactory 和 FactoryBean 的区别和联系</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Spring-%E6%A1%86%E6%9E%B6%E6%98%AF%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3-Bean-%E4%B9%8B%E9%97%B4%E7%9A%84%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%E7%9A%84"><span class="nav-number">4.9.</span> <span class="nav-text">Spring 框架是如何解决 Bean 之间的循环依赖的</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Spring-%E7%9A%84-Import-%E6%B3%A8%E8%A7%A3%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="nav-number">4.10.</span> <span class="nav-text">Spring 的 @Import 注解的作用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%8C%E4%B8%80%E4%B8%AA%E7%B1%BB%E4%B8%AD%E8%B0%83%E7%94%A8-Transaction%E6%B3%A8%E8%A7%A3%E7%9A%84%E6%96%B9%E6%B3%95%E4%BC%9A%E6%9C%89%E4%BA%8B%E5%8A%A1%E6%95%88%E6%9E%9C%E5%90%97%EF%BC%9F"><span class="nav-number">4.11.</span> <span class="nav-text">同一个类中调用 @Transaction注解的方法会有事务效果吗？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#springboot%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B%E4%B8%AD%E5%A6%82%E4%BD%95%E5%8A%A0%E8%BD%BDMETA-INF-spring-factories"><span class="nav-number">4.12.</span> <span class="nav-text">springboot启动过程中如何加载META-INF&#x2F;spring.factories</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#IOC%E5%92%8CAOP%E7%9A%84%E5%8E%9F%E7%90%86%E5%92%8C%E5%BA%94%E7%94%A8"><span class="nav-number">4.13.</span> <span class="nav-text">IOC和AOP的原理和应用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SpringMVC%E7%9A%84%E5%A4%A7%E8%87%B4%E5%AE%9E%E7%8E%B0%E8%BF%87%E7%A8%8B"><span class="nav-number">4.14.</span> <span class="nav-text">SpringMVC的大致实现过程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Spring%E4%BA%8B%E5%8A%A1%E7%9A%84%E4%BC%A0%E6%92%AD%E7%BA%A7%E5%88%AB"><span class="nav-number">4.15.</span> <span class="nav-text">Spring事务的传播级别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Spring%E5%A6%82%E4%BD%95%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3"><span class="nav-number">4.16.</span> <span class="nav-text">Spring如何自定义注解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%99%A4%E4%BA%86eurka%E7%9A%84%E5%85%B6%E4%BB%96%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%EF%BC%9F"><span class="nav-number">4.17.</span> <span class="nav-text">除了eurka的其他注册中心？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Spring-Boot-%E5%92%8CSpring-Cloud%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">4.18.</span> <span class="nav-text">Spring Boot 和Spring Cloud的区别</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Mysql%E7%9B%B8%E5%85%B3"><span class="nav-number">5.</span> <span class="nav-text">Mysql相关</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#mybatis%E6%96%B9%E8%A8%80%E5%A4%84%E7%90%86"><span class="nav-number">5.1.</span> <span class="nav-text">mybatis方言处理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E7%89%B9%E6%80%A7%EF%BC%88ACID%E5%8E%9F%E5%88%99%EF%BC%89%EF%BC%9A"><span class="nav-number">5.2.</span> <span class="nav-text">数据库事务特性（ACID原则）：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8F%AF%E8%83%BD%E5%87%BA%E7%8E%B0%E7%9A%84%E9%97%AE%E9%A2%98%EF%BC%9A"><span class="nav-number">5.3.</span> <span class="nav-text">数据库可能出现的问题：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%EF%BC%9A"><span class="nav-number">5.4.</span> <span class="nav-text">数据库隔离级别：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#mysql%E7%9A%84mvcc%E7%9A%84%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6%E7%9A%84%E9%97%AE%E9%A2%98"><span class="nav-number">5.5.</span> <span class="nav-text">mysql的mvcc的并发控制的问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#mysql%E6%9C%80%E5%B7%A6%E5%8C%B9%E9%85%8D%E5%8E%9F%E5%88%99%E7%9A%84%E5%8E%9F%E7%90%86"><span class="nav-number">5.6.</span> <span class="nav-text">mysql最左匹配原则的原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#mysql%E7%9A%84InnoDB%E5%92%8CMyISAM"><span class="nav-number">5.7.</span> <span class="nav-text">mysql的InnoDB和MyISAM</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95%EF%BC%9A"><span class="nav-number">5.7.1.</span> <span class="nav-text">聚簇索引：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9D%9E%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95%EF%BC%9A"><span class="nav-number">5.7.2.</span> <span class="nav-text">非聚簇索引：</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E6%AD%BB%E9%94%81"><span class="nav-number">5.8.</span> <span class="nav-text">数据库死锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#mysql%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88%E7%9A%84%E6%83%85%E5%86%B5%EF%BC%9A"><span class="nav-number">5.9.</span> <span class="nav-text">mysql索引失效的情况：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E8%83%BD%E7%94%A8select"><span class="nav-number">5.10.</span> <span class="nav-text">为什么不能用select *</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E8%83%BD%E4%BD%BF%E7%94%A8insert-a-%EF%BC%88select-b%EF%BC%89"><span class="nav-number">5.11.</span> <span class="nav-text">为什么不能使用insert a （select b）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#mysql%E4%B8%BB%E4%BB%8E%E5%BA%93%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%A1%88"><span class="nav-number">5.12.</span> <span class="nav-text">mysql主从库设计方案</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#java%E5%9F%BA%E7%A1%80%E7%9B%B8%E5%85%B3"><span class="nav-number">6.</span> <span class="nav-text">java基础相关</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#JAVA%E6%9C%AC%E8%BA%AB%E6%9C%89%E5%80%BC%E4%BC%A0%E9%80%92%E5%90%97"><span class="nav-number">6.1.</span> <span class="nav-text">JAVA本身有值传递吗</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E5%92%8C%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F"><span class="nav-number">6.2.</span> <span class="nav-text">单例模式和工厂模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JVM%E7%9B%B8%E5%85%B3"><span class="nav-number">6.3.</span> <span class="nav-text">JVM相关</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#java%E6%96%87%E4%BB%B6%E4%BB%8E%E5%BC%80%E5%A7%8B%E5%88%B0%E6%89%A7%E8%A1%8C%E6%88%90%E5%8A%9F%EF%BC%8C%E4%B8%AD%E9%97%B4%E7%BB%8F%E5%8E%86%E4%BA%86%E9%82%A3%E4%BA%9B%E6%AD%A5%E9%AA%A4%EF%BC%9F"><span class="nav-number">6.3.1.</span> <span class="nav-text">java文件从开始到执行成功，中间经历了那些步骤？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JVM%E7%9A%84%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6"><span class="nav-number">6.3.2.</span> <span class="nav-text">JVM的加载机制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B"><span class="nav-number">6.3.3.</span> <span class="nav-text">双亲委派模型</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6"><span class="nav-number">6.4.</span> <span class="nav-text">垃圾回收机制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#validate%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="nav-number">6.5.</span> <span class="nav-text">validate关键字的作用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CAS%E5%8E%9F%E7%90%86"><span class="nav-number">6.6.</span> <span class="nav-text">CAS原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ArrayList%E5%92%8CLinkedList%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">6.7.</span> <span class="nav-text">ArrayList和LinkedList的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#string%E7%B1%BB%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AFfinal%E7%9A%84"><span class="nav-number">6.8.</span> <span class="nav-text">string类为什么是final的</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%87%E6%BB%A4%E5%99%A8%E3%80%81%E7%9B%91%E5%90%AC%E5%99%A8%E3%80%81%E6%8B%A6%E6%88%AA%E5%99%A8%E3%80%81%E8%A7%A6%E5%8F%91%E5%99%A8"><span class="nav-number">6.9.</span> <span class="nav-text">过滤器、监听器、拦截器、触发器</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%87%E6%BB%A4%E5%99%A8%EF%BC%9A"><span class="nav-number">6.9.1.</span> <span class="nav-text">过滤器：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8B%A6%E6%88%AA%E5%99%A8%EF%BC%9A"><span class="nav-number">6.9.2.</span> <span class="nav-text">拦截器：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A7%A6%E5%8F%91%E5%99%A8%EF%BC%9A"><span class="nav-number">6.9.3.</span> <span class="nav-text">触发器：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%9B%91%E5%90%AC%E5%99%A8%EF%BC%9A"><span class="nav-number">6.9.4.</span> <span class="nav-text">监听器：</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#hashMap%E7%9B%B8%E5%85%B3"><span class="nav-number">6.10.</span> <span class="nav-text">hashMap相关</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#java%E4%B8%AD%E7%9A%84%E5%A4%9A%E6%80%81%E6%9C%89%E4%BB%80%E4%B9%88%E7%89%B9%E6%80%A7"><span class="nav-number">6.11.</span> <span class="nav-text">java中的多态有什么特性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#StringBuffer%E5%92%8CStringBuilder%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">6.12.</span> <span class="nav-text">StringBuffer和StringBuilder的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%87%8D%E5%86%99%E5%92%8C%E9%87%8D%E8%BD%BD%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">6.13.</span> <span class="nav-text">重写和重载的区别</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9B%B8%E5%85%B3"><span class="nav-number">7.</span> <span class="nav-text">多线程相关</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="nav-number">7.1.</span> <span class="nav-text">线程池</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#BlockingQueue%EF%BC%88%E7%BC%93%E5%86%B2%E9%98%9F%E5%88%97%EF%BC%89"><span class="nav-number">7.2.</span> <span class="nav-text">BlockingQueue（缓冲队列）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E4%B8%83%E5%A4%A7%E6%A0%B8%E5%BF%83%E5%8F%82%E6%95%B0"><span class="nav-number">7.3.</span> <span class="nav-text">线程池的七大核心参数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%9B%9B%E5%A4%A7%E6%8B%92%E7%BB%9D%E7%AD%96%E7%95%A5"><span class="nav-number">7.4.</span> <span class="nav-text">线程池的四大拒绝策略</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%BD%BF%E7%94%A8%E5%8E%9F%E5%88%99"><span class="nav-number">7.5.</span> <span class="nav-text">线程池使用原则</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">7.6.</span> <span class="nav-text">进程和线程的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Threadlocal"><span class="nav-number">7.7.</span> <span class="nav-text">Threadlocal</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#AQS%E6%9C%BA%E5%88%B6%EF%BC%88%E6%8A%BD%E8%B1%A1%E9%98%9F%E5%88%97%E5%90%8C%E6%AD%A5%E5%99%A8%EF%BC%89"><span class="nav-number">7.8.</span> <span class="nav-text">AQS机制（抽象队列同步器）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9C%A8%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%B8%AD%EF%BC%8Cexecute-%E5%92%8Csubmit-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">7.9.</span> <span class="nav-text">在线程池中，execute()和submit()有什么区别？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E9%97%AE%E9%A2%98"><span class="nav-number">8.</span> <span class="nav-text">分布式问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F"><span class="nav-number">8.1.</span> <span class="nav-text">如何设计一个秒杀系统</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%93%A8%E5%85%B5%E6%9C%BA%E5%88%B6"><span class="nav-number">8.2.</span> <span class="nav-text">哨兵机制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E6%9E%9C%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%B4%A9%E6%BA%83%E4%BA%86%EF%BC%8C%E5%9C%A8%E4%B8%8D%E5%BD%B1%E5%93%8D%E5%AE%A2%E6%88%B7%E4%BD%BF%E7%94%A8%E7%9A%84%E5%89%8D%E6%8F%90%E4%B8%8B%EF%BC%8C%E5%BA%94%E8%AF%A5%E6%80%8E%E4%B9%88%E5%A4%84%E7%90%86"><span class="nav-number">8.3.</span> <span class="nav-text">如果服务器崩溃了，在不影响客户使用的前提下，应该怎么处理</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AE%97%E6%B3%95%E7%9B%B8%E5%85%B3"><span class="nav-number">9.</span> <span class="nav-text">算法相关</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9B%AA%E8%8A%B1%E7%AE%97%E6%B3%95%EF%BC%9A"><span class="nav-number">9.1.</span> <span class="nav-text">雪花算法：</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="zhyyao"
      src="/images/self.jpeg">
  <p class="site-author-name" itemprop="name">zhyyao</p>
  <div class="site-description" itemprop="description">record and sharing learning experiences</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">16</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/yaoyizhuo" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;yaoyizhuo" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:yyzclick@126.com" title="E-Mail → mailto:yyzclick@126.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://blog.csdn.net/qq_45804375?spm=1000.2115.3001.5343" title="CSND → https:&#x2F;&#x2F;blog.csdn.net&#x2F;qq_45804375?spm&#x3D;1000.2115.3001.5343" rel="noopener me" target="_blank"><i class="fa-solid fa-pen-fancy fa-fw"></i>CSND</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/10/01/technology/java/java_project/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/self.jpeg">
      <meta itemprop="name" content="zhyyao">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="zhyyao">
      <meta itemprop="description" content="record and sharing learning experiences">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="Java项目遇到的问题 | zhyyao">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Java项目遇到的问题
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-10-01 18:51:53" itemprop="dateCreated datePublished" datetime="2022-10-01T18:51:53+08:00">2022-10-01</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-02-28 19:14:33" itemprop="dateModified" datetime="2025-02-28T19:14:33+08:00">2025-02-28</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><p>实际项目中，Java项目遇到的问题，包含MQ、SpringBoot、Redis、MySQL、Kafka 等…</p>
<span id="more"></span>

<h2 id="MQ-相关"><a href="#MQ-相关" class="headerlink" title="MQ 相关"></a>MQ 相关</h2><h3 id="MQ-大量未订阅消息处理"><a href="#MQ-大量未订阅消息处理" class="headerlink" title="MQ 大量未订阅消息处理"></a>MQ 大量未订阅消息处理</h3><ul>
<li><strong>产生原因</strong>：消费端宕机、消费端消费能力不足、生产端流量过大。</li>
<li><strong>解决方案</strong>：<ol>
<li>加机器，如果是线上事故，尽可能多的申请服务器，尽量短时间将 MQ 消费掉。</li>
<li>在 MQ 配置中增加最大消费数量和每次从消息队列中读取的消费数量。</li>
<li>上线专门记录消息的队列，将其持久化到数据库中，后续慢慢处理。</li>
</ol>
</li>
</ul>
<h3 id="若因为积压时间太久，导致消息丢失如何处理"><a href="#若因为积压时间太久，导致消息丢失如何处理" class="headerlink" title="若因为积压时间太久，导致消息丢失如何处理"></a>若因为积压时间太久，导致消息丢失如何处理</h3><ul>
<li><strong>先找到丢失的消息</strong>：如果有备份，直接从备份里恢复；如果没有，则尝试从生产者的生产记录里找到，让生产者重新发送。</li>
<li><strong>分析问题出现原因</strong>：<ol>
<li>首先看消息是不是积压时间过长丢失的，如果是，延长这个时间。</li>
<li>然后看是不是队列空间打满了，如果是，扩大空间。</li>
<li>最后增强消费能力。</li>
</ol>
</li>
<li><strong>后续优化</strong>：<ol>
<li>采用高可用架构，配置集群，保证一台服务器宕掉的时候，其他依然可用。</li>
<li>进行数据复制，防止单点丢失数据。</li>
</ol>
</li>
</ul>
<h3 id="若积压太多，导致-MQ-满了如何处理"><a href="#若积压太多，导致-MQ-满了如何处理" class="headerlink" title="若积压太多，导致 MQ 满了如何处理"></a>若积压太多，导致 MQ 满了如何处理</h3><ul>
<li>直接写程序将新收到的 MQ 丢弃，在流量低峰期再找回来。</li>
</ul>
<h3 id="如果-MQ-和-MySQL-同时挂了，怎么处理"><a href="#如果-MQ-和-MySQL-同时挂了，怎么处理" class="headerlink" title="如果 MQ 和 MySQL 同时挂了，怎么处理"></a>如果 MQ 和 MySQL 同时挂了，怎么处理</h3><ul>
<li>MQ 持久化，写数据库、写磁盘、写日志。恢复后从里面读取，重新发送。</li>
</ul>
<h3 id="RabbitMQ-的原理"><a href="#RabbitMQ-的原理" class="headerlink" title="RabbitMQ 的原理"></a>RabbitMQ 的原理</h3><ul>
<li>生成者发送消息之后并不会直接到消费者，而是会把消息发送到交换机（Exchange），在交换机中将其放在合适的队列（Queue），然后才是消费者进行消费。</li>
</ul>
<h3 id="消息丢失如何处理"><a href="#消息丢失如何处理" class="headerlink" title="消息丢失如何处理"></a>消息丢失如何处理</h3><ul>
<li><strong>消息丢失分三种情况</strong>：生产者消息丢失、队列消息丢失、消费者消息丢失。<ul>
<li><strong>生产者消息丢失</strong>：用 Confirm 模式，将生产者发送消息时，生成一个唯一 ID，在消费队列接收后返回一个 ACK（包含唯一<br>ID），如果接收失败，就返回 NACK 重新发送即可。</li>
<li><strong>队列消息丢失</strong>：同样的方式，将消息做持久化，持久化完成后再返回 ACK。</li>
<li><strong>消费者消息丢失</strong>：一般是采用了自动确认功能，改为手动确认，在消费者消费完成后再返回成功。而不是接收后自动返回成功。</li>
</ul>
</li>
</ul>
<h2 id="Redis-相关"><a href="#Redis-相关" class="headerlink" title="Redis 相关"></a>Redis 相关</h2><h3 id="缓存穿透、缓存击穿和缓存雪崩"><a href="#缓存穿透、缓存击穿和缓存雪崩" class="headerlink" title="缓存穿透、缓存击穿和缓存雪崩"></a>缓存穿透、缓存击穿和缓存雪崩</h3><ul>
<li><strong>缓存穿透</strong>：大量不存在的查询读缓存读不到，直接去读取数据库。造成服务崩溃的情况。<ul>
<li><strong>解决方案</strong>：<ol>
<li>在缓存中增加 value 为空的缓存，但这样会加大内存消耗，可以设置一个较短的过期时间。如果在缓存时间内在数据库中增加了这个<br>key 对象，会造成缓存和实际不一致，可以加库后发 MQ 更新缓存。</li>
<li>如果实时性要求不高，可以采用布隆过滤器，它可以减少使用缓存空间。</li>
</ol>
</li>
</ul>
</li>
<li><strong>缓存击穿</strong>：若一个热点 key 的缓存失效了，此时新建缓存比较复杂，同时多个请求来新建该缓存，导致服务崩溃。<ul>
<li><strong>解决方案</strong>：<ol>
<li>加锁排队，同一个 key 同时只有一个在新建。风险：如果新建时间较长，会有死锁风险，会导致吞吐量降低，但可以较好的保证数据一致性。</li>
<li>永不过期的缓存，缓存本身无物理过期时间，添加缓存逻辑过期时间，若超过则更新缓存，更新期间还读以前的缓存。更新后读新缓存。不会有死锁风险，但会有数据不一致的情况出现。</li>
</ol>
</li>
</ul>
</li>
<li><strong>缓存雪崩</strong>：若一个缓存一段时间内失效，此时有大量请求进来，所有请求落在服务器上，会引起缓存雪崩，服务宕机。<ul>
<li><strong>解决方案</strong>：<ol>
<li>Redis 二级缓存，设置过期时间不同。</li>
<li>分布式部署多个机房，提高缓存可用性。</li>
<li>数据预热，提前加载好缓存数据。</li>
<li>加锁排队，一个 key 同时只能有一个线程访问，其他排队等待。</li>
</ol>
</li>
</ul>
</li>
</ul>
<h3 id="Redis-的数据类型"><a href="#Redis-的数据类型" class="headerlink" title="Redis 的数据类型"></a>Redis 的数据类型</h3><ul>
<li>String（字符串）、List（列表）、Set（集合）、Hash（哈希）、Zset（有序集合）。</li>
</ul>
<h3 id="Redis-的数据结构"><a href="#Redis-的数据结构" class="headerlink" title="Redis 的数据结构"></a>Redis 的数据结构</h3><ul>
<li><strong>SDS</strong>：简单动态字符串，对应数据类型中的 String。<ul>
<li>Redis 是用 C 语言实现的，但在 C 语言里面的 char 类型字符串存在缺陷，所以 Redis 封装了一个新的简单动态字符串。</li>
<li>C 语言中 char 的缺陷：<ol>
<li>字符数组结束位置会插入 <code>\0</code>，所以出现 <code>\0</code> 时 C 语言就会认为字符串已经结束了。导致字符串不能全量读取。这种限制导致<br>C 语言的字符串只能读取文本，不能读取音频、视频等二进制数据。</li>
<li>CHAR 类型字符串不会计算自身缓冲区大小，有缓冲区溢出的风险。</li>
</ol>
</li>
<li>SDS 数据结构：len（字符串长度）、alloc（分配的空间长度）、flags（SDS 类型）、buf[]（字节数组）。</li>
<li>优势：<ol>
<li>C 语言中获取字符串长度需要遍历，时间复杂度为 O(N)，而简单动态字符串可以直接获取，时间复杂度为 O(1)。</li>
<li>二进制安全，不需要 <code>\0</code> 来控制结尾，同时还支持了文本、视频、音频等的存储。</li>
<li>不会发生缓冲区溢出，有 alloc-len 来获取剩余空间大小，若缓冲区大小不够用，Redis 会自动扩张 SDS 空间（小于 1M<br>的翻倍扩容，大于 1M 的按 1M 扩容）。</li>
<li>节省内存空间，Redis 共设计了五种类型（sdshdr5、sdshdr8、sdshdr16、sdshdr32、sdshdr64）。</li>
</ol>
</li>
</ul>
</li>
<li><strong>双向链表</strong>：List 常用数据结构，但因链表不连续，无法很好利用 CPU 缓存且内存开销大，因此数据量较小时使用压缩列表，数据量大才会使用双向链表。</li>
<li><strong>压缩列表</strong>：List、Hash 和 Zset 数据量较少时使用，连续紧凑，但不能保存过多元素，否则查询效率低，查询第一个和最后一个字段的时间复杂度是<br>O(1)，但查询中间的数字需要遍历，时间复杂度为 O(N)。<ul>
<li>压缩列表在更新时会有连锁更新的现象（原因：列表节点的 prevlen 属性会根据前一个节点的长度进行不同的空间大小分配）。直接影响压缩列表的访问性能。</li>
</ul>
</li>
<li><strong>哈希表</strong>：保存键值对（key-value）的数据结构。有可能存在 hash 冲突，Redis 采用链式 hash 来解决冲突（哈希冲突：当有两个或两个以上的<br>key 分配到同一个哈希桶，称之为 hash 冲突）。<ul>
<li>链式哈希通过 next 指针，在发生 hash 冲突时，将其指向一个新的哈希桶。但这样会导致哈希长度增加，所以又采用了 rehash 来解决。</li>
<li>rehash 的触发条件：负载因子 &#x3D; 哈希表已保存节点数量 &#x2F; 哈希表大小。</li>
<li>若负载因子大于等于 1，且 Redis 没有执行 RDB 快照和 AOF 重写的情况下，会进行 rehash 操作。</li>
<li>负载因子大于等于 5 时，无论在做什么，都会强制进行 rehash 操作。</li>
</ul>
</li>
<li><strong>跳表</strong>：只有在 Zset 的底层采用使用跳表，能支持 O(logN) 复杂度的节点查找。</li>
<li><strong>整数集合</strong>：Set 的底层实现之一、多层有序链表如果 Set 只包含数值，会使用整数集合。</li>
<li><strong>Quicklist</strong>：双向链表 + 压缩列表。整体是链表形式，而每个元素又是一个压缩列表，控制压缩列表的大小和元素个数来规避连锁更新的风险。</li>
<li><strong>Listpack</strong>：每个节点不再包含前一个节点的长度，新加元素不会影响其他节点，解决 Quicklist 问题。</li>
</ul>
<h3 id="Redis-的持久化"><a href="#Redis-的持久化" class="headerlink" title="Redis 的持久化"></a>Redis 的持久化</h3><ul>
<li>Redis 有两种持久化方式：RDB、AOF。<ul>
<li>RDB 为默认持久化方式，保存路径在 redis.conf 配置文件下，会生成 dump.rdb。会在指定时间对数据进行持久化存储。</li>
<li>如果手动开启持久化功能，会生成 AOF 持久化文件，用来记录对服务器的读写操作，当服务重启时会重新执行这些命令来恢复原始数据。</li>
<li>因为 RDB 出现意外 down 掉的话，会丢失最后一次快照的所有内容，而 AOF 不会丢失超过 2 秒的数据，因此官方建议 RDB 和 AOF<br>同时开启，两者同时开启，优先 AOF 作为持久化机制。</li>
</ul>
</li>
</ul>
<h3 id="关于-Redlock"><a href="#关于-Redlock" class="headerlink" title="关于 Redlock"></a>关于 Redlock</h3><ul>
<li>Redlock 是 Redis 官方提出的一种分布式锁算法，用于实现分布式系统里面的可靠锁机制。核心思想是通过多个独立的 Redis<br>实例来确保锁的可靠性和一致性。</li>
<li><strong>背景</strong>：在分布式系统中，单点的 Redis 实现的锁可能存在以下问题：<ol>
<li>单点故障：如果 Redis 实例宕机，锁就会失效。</li>
<li>时钟漂移：如果 Redis 实例的时钟不同步，可能导致锁的过期时间计算错误。</li>
</ol>
</li>
<li><strong>核心思想</strong>：在多个独立的 Redis 实例上同时获取锁，只有大多数实例（N&#x2F;2+1）成功获取锁，才算真正获取到锁。</li>
<li><strong>步骤</strong>：<ol>
<li>获取当前时间：记录获取锁的开始时间。</li>
<li>依次向多个 Redis 实例请求锁；（1. 使用相同的 key 和随机值作为锁的值，2. 设置锁的过期时间）。</li>
<li>计算获取锁的时间：如果获取锁的时间小于锁的过期时间，并且大多数实例（N&#x2F;2+1）成功获取锁，则认为锁获取成功。</li>
<li>释放锁：向所有 Redis 实例发送删除锁的请求。</li>
</ol>
</li>
<li><strong>优点</strong>：避免单点故障，部分实例宕机依然可用，且基于 Redis 实现，易于集成。</li>
<li><strong>缺点</strong>：需要在多个 Redis 实例上获取锁，增加了网络通信和计算开销。如果 Redis<br>实例的时钟不同步，可能会导致锁的过期时间计算错误。而且可靠性存在争议，不能完全解决分布式锁的问题。</li>
<li><strong>使用场景</strong>：分布式任务调度：确保同一时间只有一个节点执行任务；资源竞争控制：防止多节点同时操作共享资源。</li>
<li><strong>替代方案</strong>：Zookeeper，Etcd 分布式锁，数据库分布式锁。</li>
</ul>
<h3 id="Etcd-分布式锁"><a href="#Etcd-分布式锁" class="headerlink" title="Etcd 分布式锁"></a>Etcd 分布式锁</h3><ul>
<li><strong>特性</strong>：<ol>
<li>租约：Etcd 里面的时间绑定机制，为键值对设置一个有效期，租约过期时，之前设置的键值对自动删除。</li>
<li>事务：支持事务操作，保证原子性。</li>
<li>Watch 机制：监听某个键的变化，用来实现锁的等待和通知。</li>
</ol>
</li>
<li><strong>实现方案</strong>：<ol>
<li>创建租约，设置过期时间。</li>
<li>客户端尝试通过事务写入一个键值对（锁的唯一标识），失败表示锁已经被其他人持有。</li>
<li>监听锁释放：如果获取失败，可以通过 Watch 机制，监听锁的释放。</li>
<li>释放锁：客户端删除键值对，或者租约过期来释放锁。</li>
</ol>
</li>
</ul>
<h3 id="Redis-的过期策略和淘汰机制"><a href="#Redis-的过期策略和淘汰机制" class="headerlink" title="Redis 的过期策略和淘汰机制"></a>Redis 的过期策略和淘汰机制</h3><ul>
<li><strong>过期策略</strong>：<ol>
<li>惰性删除：访问时检查，并删除过期键。</li>
<li>定期删除：定期随机检查，并删除过期键。</li>
</ol>
</li>
<li><strong>淘汰机制</strong>：<ol>
<li>不淘汰，默认策略。当有新的写入进来发现内存不足，直接报错。适用于不允许数据丢失的场景。</li>
<li>从设置了过期时间的键中，删除最近最少使用的。</li>
<li>从设置了过期时间的键中，删除最不经常使用的。</li>
<li>从设置了过期时间的键中，随机淘汰。</li>
<li>从设置了过期时间的键中，淘汰剩余时间最短的键。</li>
<li>从所有键中，淘汰最近最少使用的。</li>
<li>从所有键中，淘汰最不经常使用的。</li>
<li>从所有键中，随机淘汰。</li>
</ol>
</li>
</ul>
<h2 id="ES-相关"><a href="#ES-相关" class="headerlink" title="ES 相关"></a>ES 相关</h2><ul>
<li>ES 本身使用倒排索引。</li>
</ul>
<h2 id="Spring-相关"><a href="#Spring-相关" class="headerlink" title="Spring 相关"></a>Spring 相关</h2><h3 id="Spring-Boot-常用组件"><a href="#Spring-Boot-常用组件" class="headerlink" title="Spring Boot 常用组件"></a>Spring Boot 常用组件</h3><ul>
<li><strong>Starter</strong>：提供各种功能的依赖管理。</li>
<li><strong>Web（spring-boot-starter-web）</strong>：集成 Spring MVC 和 Tomcat。核心注解：@RestController，@Service 等。</li>
<li><strong>JPA（spring-boot-starter-data-jpa）</strong>：简化数据库操作。核心注解：@Entity @Query。</li>
<li><strong>Test（spring-boot-starter-test）</strong>：提供测试支持，核心注解：@Junit，@Test。</li>
</ul>
<h3 id="Spring-Boot-启动过程中-URL-冲突，原理是什么，为什么会报错"><a href="#Spring-Boot-启动过程中-URL-冲突，原理是什么，为什么会报错" class="headerlink" title="Spring Boot 启动过程中 URL 冲突，原理是什么，为什么会报错"></a>Spring Boot 启动过程中 URL 冲突，原理是什么，为什么会报错</h3><ul>
<li>Spring Boot 启动时会初始化上下文，加载所有的 Bean，在加载控制器时，Spring MVC 会加载所有映射，如果 URL 冲突，则直接报错。异常信息为：<br><code>IllegalStateException（Ambiguous mapping. Cannot map &#39;xxxController&#39; method ... to &#123;xxx&#125;: There is already &#39;yyyController&#39; bean method ... mapped.）</code>。</li>
</ul>
<h3 id="Spring、Spring-MVC、Spring-Boot-的区别"><a href="#Spring、Spring-MVC、Spring-Boot-的区别" class="headerlink" title="Spring、Spring MVC、Spring Boot 的区别"></a>Spring、Spring MVC、Spring Boot 的区别</h3><ul>
<li><strong>Spring</strong>：是一个家族，里面包含了各种各样衍生产品，但他们都实现了 IOC（依赖注入）和 AOP（面向切面）。然后在这个基础上进行延伸，提供其他高级功能。Spring<br>是一个引擎。</li>
<li><strong>Spring MVC</strong>：是一个 Web 框架，提供轻耦合的方式开发 Web 应用，是 Spring 的一个模块，通过解决问题领域是网站应用程序或服务开发。是基于<br>Spring 的 MVC 框架。</li>
<li><strong>Spring Boot</strong>：实现了 Auto-configuration<br>自动配置（另外三大神器：Starter（依赖）、CLI（命令行接口）、Auctutor（监控）），大幅度减少配置，几乎相当于开箱即用。是一套快速开发整合包。</li>
</ul>
<h3 id="Spring-的启动原理"><a href="#Spring-的启动原理" class="headerlink" title="Spring 的启动原理"></a>Spring 的启动原理</h3><ol>
<li>开始启动。</li>
<li>构造一个 Spring 应用，进行模块的初始化，包括配置 source、配置是否为 Web<br>环境、创建初始化构造器（获取工厂对象，生成工厂实例）、创建应用监听器（获取工厂对象，生成工厂实例）、配置应用的主方法所在类。</li>
<li>启动该应用：启动监听器模块、启动配置环境模块、启动应用上下文（创建上下文对象、基本属性配置、更新应用上下文：准备环境所需<br>Bean 工厂和通过工厂产生环境所需的 Bean）。</li>
</ol>
<h3 id="Spring-Boot-的启动类，使用-SpringBootApplication-注解。"><a href="#Spring-Boot-的启动类，使用-SpringBootApplication-注解。" class="headerlink" title="Spring Boot 的启动类，使用 @SpringBootApplication 注解。"></a>Spring Boot 的启动类，使用 <code>@SpringBootApplication</code> 注解。</h3><h3 id="Spring-Boot-比较重要的注解"><a href="#Spring-Boot-比较重要的注解" class="headerlink" title="Spring Boot 比较重要的注解"></a>Spring Boot 比较重要的注解</h3><ul>
<li><strong>@SpringBootConfiguration</strong>：继承 <code>@Configuration</code>，标识当前是注解类。<ul>
<li>按照原来 XML 配置文件的形式，Spring Boot 大多采用配置类来解决配置问题：<ol>
<li>XML 中进行配置，指向类路径。</li>
<li>通过 <code>@Bean</code> 可注入。任何一个标注了 <code>@Bean</code> 的方法，其返回值将作为 Bean 定义注册到 Spring 的 IOC 容器。方法名将默认成该<br>Bean 定义的 ID。</li>
</ol>
</li>
</ul>
</li>
<li><strong>@EnableAutoConfiguration</strong>：开启 Spring Boot 注解功能。</li>
<li><strong>@ComponentScan</strong>：扫描路径设置。<ol>
<li>对应 XML 配置中的元素。</li>
<li>自动扫描并加载符合条件的组件。</li>
<li>将 Bean 定义加载到 IOC 容器中。</li>
</ol>
</li>
</ul>
<h3 id="BeanFactory-和-ApplicationContext-的区别"><a href="#BeanFactory-和-ApplicationContext-的区别" class="headerlink" title="BeanFactory 和 ApplicationContext 的区别"></a>BeanFactory 和 ApplicationContext 的区别</h3><ul>
<li><strong>两者都是接口</strong>，ApplicationContext 间接继承了 BeanFactory。</li>
<li><strong>BeanFactory</strong> 是最底层接口，只提供了实例化对象和获取对象的功能。</li>
<li><strong>ApplicationContext</strong> 是 Spring 的一个更高级容器，提供更多有用功能，包括：Bean 的详细信息，国际化，统一加载资源、事件机制和<br>Web 应用的支持等等。</li>
<li><strong>BeanFactory</strong> 采用延迟加载的形式来注入 Bean，ApplicationContext 相反，是在 IOC 启动时一次性创建所有<br>Bean，这么好处是可以及时发现配置文件的错误，缺点是造成浪费。</li>
</ul>
<h3 id="BeanFactory-和-FactoryBean-的区别和联系"><a href="#BeanFactory-和-FactoryBean-的区别和联系" class="headerlink" title="BeanFactory 和 FactoryBean 的区别和联系"></a>BeanFactory 和 FactoryBean 的区别和联系</h3><ul>
<li><strong>两者都是接口</strong>。</li>
<li><strong>BeanFactory</strong> 是用来创建 Bean 和获取 Bean 的。</li>
<li><strong>FactoryBean</strong> 跟普通 Bean 不同，其返回的对象不是指定类的一个实例，而是 FactoryBean 的 <code>getObject</code> 方法所返回的实例。</li>
<li><strong>通过 BeanFactory 和 beanName 获取 Bean 时</strong>，如果 beanName 不加 <code>&amp;</code> 则获取到对应 Bean 的实例；如果 beanName 加上 <code>&amp;</code><br>，则获取到 FactoryBean 本身的实例。</li>
<li><strong>FactoryBean</strong> 通常是用来创建比较复杂的 Bean（如创建 MyBatis 的 SqlSessionFactory 很复杂），一般的 Bean 直接用 XML<br>配置即可，但如果创建一个 Bean 的创建过程中涉及到很多其他的 Bean 和复杂的逻辑，用 XML 配置比较困难，这时可以考虑用<br>FactoryBean。</li>
</ul>
<h3 id="Spring-框架是如何解决-Bean-之间的循环依赖的"><a href="#Spring-框架是如何解决-Bean-之间的循环依赖的" class="headerlink" title="Spring 框架是如何解决 Bean 之间的循环依赖的"></a>Spring 框架是如何解决 Bean 之间的循环依赖的</h3><ul>
<li>Spring 先用构造函数进行实例化，然后填充属性，再对其进行附加操作和其他初始化，正是这样的生命周期，才有了 Spring<br>解决循环依赖。这样的解决机制是根据 Spring 框架内定义的三级缓存来实现的。</li>
<li><strong>三级缓存</strong>：<ol>
<li><strong>singletonObjects</strong>：第一级缓存，里面放置的是实例化好的单例对象。</li>
<li><strong>earlySingletonObjects</strong>：第二级缓存，里面存放的是提前曝光的单例对象。</li>
<li><strong>singletonFactories</strong>：第三级缓存，里面存放的是要被实例化的对象的对象工厂。</li>
</ol>
</li>
<li>所以当一个 Bean 调用构造函数进行实例化后，即使属性还未填充，就可以通过三级缓存向外暴露依赖的引用值（所以循环依赖问题的解决也是基于<br>Java 的引用传递），这也说明了另外一点，基于构造函数的注入，如果有循环依赖，Spring 是不能够解决的。还要说明一点，Spring 默认的<br>Bean Scope 是单例的，而三级缓存中都包含 singleton，可见是对于单例 Bean 之间的循环依赖的解决，Spring 是通过三级缓存来实现的。</li>
</ul>
<h3 id="Spring-的-Import-注解的作用"><a href="#Spring-的-Import-注解的作用" class="headerlink" title="Spring 的 @Import 注解的作用"></a>Spring 的 <code>@Import</code> 注解的作用</h3><ol>
<li>将没有使用 <code>@Component</code> 注解的普通 class 加入到 Spring 容器，由 Spring 管理。</li>
<li>导入一个 Configuration 类（比如你想组合多个 Java Config 类到一个 Java Config 类，或者你引入的第三方 jar 包中的 Java<br>Config 类没在你 Spring Boot 程序的子包下，即没有被扫描进 Spring 容器）。</li>
<li>通过实现了 <code>ImportSelector</code> 接口的类，导入多个 class 到 Spring 容器（Spring Boot 的自动装配<br><code>@EnableAutoConfiguration</code>）。</li>
<li>通过实现 <code>ImportBeanDefinitionRegistrar</code> 接口的方式（MyBatis 整合 Spring：<code>MapperScannerRegistrar.java</code> 和<br><code>@MapperScan</code> 注解。</li>
<li>使用@Import搭配@Configuration导入到Spring容器。</li>
</ol>
<h3 id="同一个类中调用-Transaction注解的方法会有事务效果吗？"><a href="#同一个类中调用-Transaction注解的方法会有事务效果吗？" class="headerlink" title="同一个类中调用 @Transaction注解的方法会有事务效果吗？"></a>同一个类中调用 @Transaction注解的方法会有事务效果吗？</h3><p>没有，可以Autowired注入自己，然后再调用注入的类中的方法，即自己依赖自己，循环依赖</p>
<h3 id="springboot启动过程中如何加载META-INF-spring-factories"><a href="#springboot启动过程中如何加载META-INF-spring-factories" class="headerlink" title="springboot启动过程中如何加载META-INF&#x2F;spring.factories"></a>springboot启动过程中如何加载META-INF&#x2F;spring.factories</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; s = SpringFactoriesLoader.loadFactoryNames(type, classLoader);</span><br></pre></td></tr></table></figure>

<h3 id="IOC和AOP的原理和应用"><a href="#IOC和AOP的原理和应用" class="headerlink" title="IOC和AOP的原理和应用"></a>IOC和AOP的原理和应用</h3><ol>
<li>IOC本质就是依赖注入，在开发过程中，A如果需要引用的B，那就需要new B()<br>;但这样耦合度较高，如果B做了调整，那A也需要相应调整。在spring引入ioc之后，可以直接通过工厂模式加反射机制，将其托管给spring容器（常见的dto的构造器原理）。这样就降低了代码的耦合程度。</li>
<li></li>
</ol>
<p>AOP本质是面向切面编程，除了spring中的应用之外，更多算是一种思想，将代码以切面的形式区分为核心切面和横切面。开发人员在开发过程中只需要考虑自己的核心业务逻辑，横切逻辑无需考虑在内。在spring中的应用就是将公用的逻辑提取出来，在代码执行时加载，如权限控制，日志管理，事务COMMIT等。这个思想在开发过程中也可以继续沿用。</p>
<h3 id="SpringMVC的大致实现过程"><a href="#SpringMVC的大致实现过程" class="headerlink" title="SpringMVC的大致实现过程"></a>SpringMVC的大致实现过程</h3><ol>
<li>用户发起request请求，如果有多个servlet，则通过servletmapping来指定具体的servlet。</li>
<li>通过servlet指定的url去需要指定的controller。</li>
<li>通过controller去调用modelandview，返回指定视图view。</li>
<li>将返回model组装返回给response。</li>
</ol>
<h3 id="Spring事务的传播级别"><a href="#Spring事务的传播级别" class="headerlink" title="Spring事务的传播级别"></a>Spring事务的传播级别</h3><ol>
<li>spring的默认级别，判断上下文是否存在事务，若存在则加入当前事务，若不存在，则新建事务。</li>
<li>判断上下文是否存在事务，若不存在，则以非事务方式运行</li>
<li>判断上下文是否存在事务，若存在，则抛出异常</li>
<li>判断上下文是否存在事务，若不存在，则抛出异常</li>
<li>每次执行都会创建新事务，同事挂起上下文中的事务，执行完成后再恢复上下文中的事务，子事务的执行不影响父事务的执行和回滚</li>
<li>判断上下文中是否存在事务，若存在，则挂起，直到当前事务执行完成再恢复（降低事务大小，将非核心逻辑包裹执行）。</li>
<li>嵌套事务，若上下文中存在事务则嵌套执行，若没有，则新建事务。</li>
</ol>
<h3 id="Spring如何自定义注解"><a href="#Spring如何自定义注解" class="headerlink" title="Spring如何自定义注解"></a>Spring如何自定义注解</h3><ol>
<li>@Target(ElementType.TYPE)注解，是说这个注解可以作用于类，接口或枚举类型;</li>
<li>@Component 表示这个注解是spring组件注解，会被spring bean加载</li>
<li>@Documented 表示这个注解会被放在javadoc中</li>
<li>@Retention(RetentionPolicy.RUNTIME) 表示注解运行时保留，可以通过反射读取</li>
<li>@interface 接口属性</li>
</ol>
<h3 id="除了eurka的其他注册中心？"><a href="#除了eurka的其他注册中心？" class="headerlink" title="除了eurka的其他注册中心？"></a>除了eurka的其他注册中心？</h3><ol>
<li>市面主流的注册中心有很多，根据自身需要去选用即可</li>
<li>eureka特点是易于集成到Spring colud生态，高可用，支持多节点复制。缺点是一致性较弱，功能也比较简单。</li>
<li>zookeeper拥有强一致性，但配置比较复杂，同时写的性能也比较差</li>
<li>consul支持服务发现和多数据中心，但配置也比较复杂，强一致性也会影响性能。</li>
<li>Nacos，没有eurkea和consul来的成熟，</li>
<li>etcd，拥有高可用，强一致性，但配置较为复杂，且功能也比较单一，主要用于键值存储</li>
</ol>
<h3 id="Spring-Boot-和Spring-Cloud的区别"><a href="#Spring-Boot-和Spring-Cloud的区别" class="headerlink" title="Spring Boot 和Spring Cloud的区别"></a>Spring Boot 和Spring Cloud的区别</h3><ol>
<li>Spring Boot是快速开发和运行Spring的工具，适合单体应用和微服务里面的单个服务。</li>
<li>Spring Cloud是构建分布式系统和微服务的工具集合，适合复杂的分布式场景。</li>
</ol>
<h2 id="Mysql相关"><a href="#Mysql相关" class="headerlink" title="Mysql相关"></a>Mysql相关</h2><h3 id="mybatis方言处理"><a href="#mybatis方言处理" class="headerlink" title="mybatis方言处理"></a>mybatis方言处理</h3><ol>
<li>定义mapper.xml文件，在里面加入方言支持（只需要列出必要字段）</li>
<li>因为mapper XML 文件不支持继承，(一个接口中的方法在XML文件中必须有实现-否则启动报错)，所以采用 Mapper.java 接口类继承的方式</li>
</ol>
<h3 id="数据库事务特性（ACID原则）："><a href="#数据库事务特性（ACID原则）：" class="headerlink" title="数据库事务特性（ACID原则）："></a>数据库事务特性（ACID原则）：</h3><ol>
<li>原子性：一个事务多个操作，要么同时成功提交，要么同时失败回滚。</li>
<li>一致性：一个事务执行前后，必须从一个一致状态变成另一个一致状态，比如A和B一共有400元，两者无论互相转账几次，都应该是400元。</li>
<li>隔离性：一个事务内部操作和使用数据，对其他同时进行的事务，都是隔离的</li>
<li>持久性：数据库修改后应该是持久修改。后面就算数据库出现问题，数据恢复后，数据也不应该发生变化</li>
</ol>
<h3 id="数据库可能出现的问题："><a href="#数据库可能出现的问题：" class="headerlink" title="数据库可能出现的问题："></a>数据库可能出现的问题：</h3><ol>
<li>脏读：事务A读取到了事务B尚未提交的数据</li>
<li>不可重复读：事务A第一次读取数据之后，事务B提交了数据，事务A第二次读取时候发现数据和第一次读取不一致。</li>
<li>幻读：事务A修改了表里面的所有数据但没有提交，这时事务B对这个表新增了一行，然后提交了，事务A提交之后发现有一行没有修改。这种现象叫幻读。若要解决，需要在修改前进行锁表</li>
</ol>
<h3 id="数据库隔离级别："><a href="#数据库隔离级别：" class="headerlink" title="数据库隔离级别："></a>数据库隔离级别：</h3><ol>
<li>读未提交，</li>
<li>读已提交</li>
<li>可重复读</li>
<li>串行化</li>
</ol>
<h3 id="mysql的mvcc的并发控制的问题"><a href="#mysql的mvcc的并发控制的问题" class="headerlink" title="mysql的mvcc的并发控制的问题"></a>mysql的mvcc的并发控制的问题</h3><p>概念：MVCC又叫多版本并发控制，提供访问数据库时，对事务内读取到的内存做处理，避免写操作阻塞读操作。</p>
<p>MVCC实现方式：</p>
<ul>
<li>更新时并非直接更新数据库，而是将旧的数据标记为过时的，新的数据以新增方式写入，后续通过垃圾回收机制回收旧的数据。</li>
<li>mysql和innodb使用另外一种，数据库只保存最新的数据，但会通过undo动态重构旧版本数据。</li>
</ul>
<p>InnoDB的MVCC实现机制：通过在数据后面添加两个隐藏列来实现，分别是创建时间和删除时间，此处的时间不是时间戳，是版本号。每开启一个新事务，版本号递增。</p>
<h3 id="mysql最左匹配原则的原理"><a href="#mysql最左匹配原则的原理" class="headerlink" title="mysql最左匹配原则的原理"></a>mysql最左匹配原则的原理</h3><p>原理：索引在查询时，会从联合索引的最左边开始查起。</p>
<p>比如索引为A\B\C.当查询AB或BA时，索引可以生效，查询A\AB\ABC时索引生效</p>
<h3 id="mysql的InnoDB和MyISAM"><a href="#mysql的InnoDB和MyISAM" class="headerlink" title="mysql的InnoDB和MyISAM"></a>mysql的InnoDB和MyISAM</h3><ul>
<li>共同点：这两个都是mysql常见的存储引擎。</li>
<li>区别：</li>
</ul>
<ol>
<li>事务支持：Innodb支持事务，适合需要高可靠性的应用；但myisam不支持，不能保证数据的一致性和完整性</li>
<li>锁定机制：Innodb采用行级锁，适合高并发场景，能有效减少冲突；myisam使用表级锁，并发写入时性能较差</li>
<li>外键支持：Innodb支持外键，确保数据完整性，但myisam不支持外键</li>
<li>崩溃恢复：Innodb具备崩溃回复能力，但myisam需要手动恢复</li>
<li>性能：Innodb在写操作时表现更好，适合频繁写入的场景；myisam适合读多写少的业务场景</li>
<li>存储结构：Innodb的数据与索引存储在同一个文件中（.ibd），支持表空间管理；myisam的数据和索引分开存储</li>
<li>全文索引：Innodb再5.6之后支持全文索引，但myisam一直都支持</li>
<li>压缩：Innodb支持表压缩，压缩后节省存储空间，但myisam压缩后为只读模式</li>
<li>适用场景：Innodb适合需要事务、高并发、数据完整性要求较高的系统，如电商系统；myisam适合读多写少、不需要事务的系统，如日志系统、数据仓库等</li>
<li>ACID兼容：Innodb支持ACID；myisam不支持</li>
</ol>
<blockquote>
<ul>
<li>mysql有innodb和myisam两种类型，其中innodb使用聚簇索引，myisam使用非聚簇索引：</li>
<li>聚簇索引是对磁盘数据进行重新组织排列的算法，特点是存储数据的顺序和索引顺序一致，一般主键会默认创建聚簇索引，一个表只有一个聚簇索引。</li>
<li>innodb分主索引和次索引，主索引节点和数据放在一起，次索引放在主键的位置。</li>
<li>myisam的主次索引指向的都是该数据在磁盘的位置。</li>
<li>innodb的二级索引存放的是key+主键。通过二级索引去查询时会先查询主键，再通过主键来查找数据块。</li>
<li>myisam的主索引和二级索引一样，存放都是行+列的组合，存放的是数据地址。</li>
</ul>
</blockquote>
<h4 id="聚簇索引："><a href="#聚簇索引：" class="headerlink" title="聚簇索引："></a>聚簇索引：</h4><ol>
<li>索引项直接对数据库，可以直达</li>
<li>主键缺省可以用它</li>
<li>索引项排序和数据行完全一致。</li>
<li>一个表只有一个聚簇索引（数据一旦存储，顺序只能有一种）。</li>
</ol>
<h4 id="非聚簇索引："><a href="#非聚簇索引：" class="headerlink" title="非聚簇索引："></a>非聚簇索引：</h4><ol>
<li>不能直达，可能要多次链式访问多页表之后，才能到达</li>
<li>一个表可以有多个非聚簇索引</li>
</ol>
<blockquote>
<ul>
<li>聚簇索引优点：数据条目少的时候，无需回行（主键直接挂数据块）</li>
<li>缺点：不规则的插入数据可能会导致频繁的分裂</li>
</ul>
</blockquote>
<h3 id="数据库死锁"><a href="#数据库死锁" class="headerlink" title="数据库死锁"></a>数据库死锁</h3><ol>
<li>概念：多个线程资源并发请求因互相争夺资源引起的互相等待的现象</li>
<li>本质原因：<ul>
<li>系统资源有限</li>
<li>进程推进顺序不合理</li>
</ul>
</li>
<li>产生死锁的四个必要条件：<ul>
<li>互斥：某种资源只允许一个进程访问，访问期间其他进程不得访问，直到该进程访问结束。</li>
<li>占有且等待：一个进程本身占有资源（一种或多种），而且还有资源未得到满足，等待其他进程释放资源。</li>
<li>不可抢占：别人已经占有了某项资源，不能因为自己也需要这项资源，就去把资源抢占过来</li>
<li>循环等待：存在一个进程链，每个进程都占有下一个进程所需要的的至少一种资源。<br>满足以上四个条件才会形成死锁，破坏其中任意一个，都可以解决死锁问题。</li>
</ul>
</li>
<li>解决死锁的方案：<ul>
<li>互斥是所有非共享资源所必须的，不仅不能破坏，还应该加以保证。因此只能从另外三个条件着手</li>
<li>破坏占有且等待：<ul>
<li>方法一：在进程执行初期，一次性申请够所有需要的资源。如此做会造成资源浪费，会导致饥饿现象，</li>
<li>方法二：允许进程获取期初运行所需的资源，运行过程中逐步放开分配掉的已经使用完毕的资源，然后去获取新的资源，可解决方法一问题。</li>
</ul>
</li>
<li>破坏不可抢占条件：当一个进程请求资源没有获得满足时，应释放掉本身已经占有的资源，如果会导致之前做的工作可能白费，会延长进程周期，加大资源消耗。</li>
<li>破坏循环等待：通过定义资源的线性顺序来预防，为每个资源编号，进程只能申请大于当前编号的资源。会降低资源利用率。</li>
</ul>
</li>
<li>预防死锁：<ul>
<li>若进程启动会导致死锁，则不启动该进程</li>
<li>若进程申请追加资源会导致死锁，则拒绝该申请<blockquote>
<p>预防死锁通常采用银行家算法：可用资源向量、最大需求矩阵、分配矩阵、需求矩阵。通过一系列算法确保分配的资源不会导致死锁后才会进行资源分配。</p>
</blockquote>
</li>
</ul>
</li>
<li>解除死锁：<ul>
<li>抢占资源：从一个或多个进程中抢占足够数量的资源，提供给死锁进程</li>
<li>终止进程：<ul>
<li>简单粗暴，终止所有死锁进程。可能会导致执行了很久的程序重新执行</li>
<li>逐个终止进程，直到死锁状态解除，可按照以下顺序来终止：进程优先级、进程已运行时间和还需要运行的时间、进程已占用系统资源、进程运行完成还需要占用的资源、终止进程的数目、进程是交互还是批处理。</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="mysql索引失效的情况："><a href="#mysql索引失效的情况：" class="headerlink" title="mysql索引失效的情况："></a>mysql索引失效的情况：</h3><ol>
<li>使用like，左边有百分号的情况下索引失效，右边有百分号时，索引有效</li>
<li>出现not，&lt;&gt;,!&#x3D;号时，索引失效</li>
<li>存在隐藏的字段类型转换时索引失效，比如查询条件是varchar类型，如果查询时不加引号，可能会自动转换成int类型，导致索引失效</li>
<li>or语句前后没有同时使用索引时，索引失效</li>
<li>违反最左匹配原则时，索引失效</li>
<li>对索引字段使用计算，有函数操作时，索引失效</li>
<li>如果全表扫描的速度比索引快，则索引失效</li>
</ol>
<h3 id="为什么不能用select"><a href="#为什么不能用select" class="headerlink" title="为什么不能用select *"></a>为什么不能用select *</h3><ol>
<li>性能问题：不必要的数据传输，会导致索引利用不足，增加io开销</li>
<li>可维护性差：代码的可读性降低，表结构变更容易出问题</li>
<li>有数据泄漏风险</li>
<li>造成资源浪费</li>
<li>扩展性差</li>
<li>orm框架的兼容问题，表结构发生变化，可能导致映射错误</li>
</ol>
<h3 id="为什么不能使用insert-a-（select-b）"><a href="#为什么不能使用insert-a-（select-b）" class="headerlink" title="为什么不能使用insert a （select b）"></a>为什么不能使用insert a （select b）</h3><ol>
<li>列未必完全匹配，容易出错</li>
<li>可能会出现主键冲突</li>
<li>如果有并发，会出现数据一致性的问题</li>
<li>非空约束也可能导致插入失败</li>
<li>在跨数据库时，会出现兼容性问题</li>
<li>如果查询的是一张大表，可能会导致锁表</li>
</ol>
<h3 id="mysql主从库设计方案"><a href="#mysql主从库设计方案" class="headerlink" title="mysql主从库设计方案"></a>mysql主从库设计方案</h3><ul>
<li>主从复制的基本原理：</li>
</ul>
<ol>
<li>主库（master）：负责写操作，并将这些操作记录到二进制日志（Binary log）中。</li>
<li>从库（slave）：从主库读取二进制文件，并在从库重放这些操作，从而实现数据同步</li>
</ol>
<p><strong>注意事项：</strong></p>
<blockquote>
<ul>
<li>主从库的配置应尽可能一致，避免出现性能瓶颈；</li>
<li>主从库之间的网络延迟应尽可能低且稳定。</li>
<li>定期检查数据差异</li>
</ul>
</blockquote>
<p><strong>优势：</strong></p>
<ol>
<li>高可用性和扩展性：读操作可以配置多个从库，将压力分散到不同的从库，减轻主库压力。写操作仍然在主库进行。</li>
<li>主库故障时，可以将从库切换到主库，自动切换工具（MHA，Orchestrator）</li>
</ol>
<p><strong>一致性问题：</strong> 至少确保一个从库接收到主库的更新，再返回给客户端</p>
<p><strong>监控和维护：</strong></p>
<ol>
<li>监控从库的复制延迟，确保数据同步的及时性，使用grafana监控数据性能</li>
<li>定期备份数据库数据，及清理binlog文件</li>
</ol>
<h2 id="java基础相关"><a href="#java基础相关" class="headerlink" title="java基础相关"></a>java基础相关</h2><h3 id="JAVA本身有值传递吗"><a href="#JAVA本身有值传递吗" class="headerlink" title="JAVA本身有值传递吗"></a>JAVA本身有值传递吗</h3><p>JAVA所有传递都是值传递，本身不存在引用传递</p>
<h3 id="单例模式和工厂模式"><a href="#单例模式和工厂模式" class="headerlink" title="单例模式和工厂模式"></a>单例模式和工厂模式</h3><p>参考：<a target="_blank" rel="noopener" href="https://www.runoob.com/design-pattern/singleton-pattern.html">单例模式</a></p>
<ul>
<li>单例模式：只能有一个实例、必须创建自己的唯一实例，必须对外所有接口提供自身创建的实例<ul>
<li>懒汉模式，线程非安全,不支持多线程  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span> <span class="params">()</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>懒汉模式，线程安全，支持多线程，但效率差  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span> <span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>饿汉模式，线程安全，常用方式，但容易产生垃圾对象  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span> <span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>枚举  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">whateverMethod</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="JVM相关"><a href="#JVM相关" class="headerlink" title="JVM相关"></a>JVM相关</h3><h4 id="java文件从开始到执行成功，中间经历了那些步骤？"><a href="#java文件从开始到执行成功，中间经历了那些步骤？" class="headerlink" title="java文件从开始到执行成功，中间经历了那些步骤？"></a>java文件从开始到执行成功，中间经历了那些步骤？</h4><ol>
<li>生成.java文件</li>
<li>编译成.class文件</li>
<li>执行jvm.cfg</li>
<li>通过jvm.cfg文件找到jvm.dll</li>
<li>通过jvm.dll找到JNI</li>
<li>通过JNI找到对应的main函数执行</li>
</ol>
<h4 id="JVM的加载机制"><a href="#JVM的加载机制" class="headerlink" title="JVM的加载机制"></a>JVM的加载机制</h4><ol>
<li>通过class文件执行类加载子系统</li>
<li>类加载子系统加载内存空间：方法区、java堆、java栈、本地方法栈</li>
<li>通过垃圾回收器进行内存释放</li>
<li>pc寄存器挂载于内存空间中</li>
<li>本地方法栈执行本地方法接口，挂载本地方法库</li>
<li>最终通过执行引擎来内存空间中的堆栈</li>
</ol>
<h4 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h4><p>双亲委派模型是jvm类加载机制的核心原则，即当一个类加载进来时，会先将请求委派给父类加载器，如果父类不能加载再由当前类来加载，如果所有的类加载器都加载不了，则抛出ClassNotFoundException异常。</p>
<h3 id="垃圾回收机制"><a href="#垃圾回收机制" class="headerlink" title="垃圾回收机制"></a>垃圾回收机制</h3><p>在jvm运行过程中当对象不再被引用时候，会系统会自动进行垃圾回收，其中垃圾回收有以下几种算法</p>
<ul>
<li>（1）引用计数法</li>
<li>（2）可达性分析算法</li>
<li>（3）标记清除算法</li>
<li>（4）标记复制算法</li>
<li>（5）标记整理算法</li>
</ul>
<h3 id="validate关键字的作用"><a href="#validate关键字的作用" class="headerlink" title="validate关键字的作用"></a>validate关键字的作用</h3><p>用于给常量加锁，保证其原子性，让其走主内存去获取数据。但不太稳定，当加锁的基本类型变成对象时，将会不生效，所以没有把握的情况下最好用synchronized关键字</p>
<h3 id="CAS原理"><a href="#CAS原理" class="headerlink" title="CAS原理"></a>CAS原理</h3><p>简单翻译为：比较并交换，由三部分组成，内存位置，原值，新值，执行时先记录原值，然后去执行逻辑，若逻辑执行完成更新这个值时发现这个值没有发生变化，则cas操作成功。若发生变化，则失败重新操作。<br>导致问题：aba问题</p>
<h3 id="ArrayList和LinkedList的区别"><a href="#ArrayList和LinkedList的区别" class="headerlink" title="ArrayList和LinkedList的区别"></a>ArrayList和LinkedList的区别</h3><p>（1）ArrayList是数组结构而LinkedList是链表结构。<br>（2）在进行get、set时，ArrayList可以直接从index的位置去读取，而LinkedList需要去for循环查找，所以性能较差<br>（3）在进行增删时，ArrayList主要耗时为system.arrayCopy操作，而LinkedList是循环，所以性能快慢不好说。<br>（4）LinkedList线程不安全，单线程里面建议使用ArrayList，多线程建议使用copyOnWriteArrayList<br>（5）copyOnWriteArrayList在读时不加锁，但写时候加锁，写的操作是复制底层数组，修改新数组，替换旧数组，使用的volatile关键字加锁</p>
<h3 id="string类为什么是final的"><a href="#string类为什么是final的" class="headerlink" title="string类为什么是final的"></a>string类为什么是final的</h3><p>参考：<a target="_blank" rel="noopener" href="https://www.zhihu.com/question/31345592">String类为什么是final的</a><br>为了安全，如果做成可变的，在开发过程中，如果字符串可以随意变化，后面的赋值影响到了前面的逻辑，最终使逻辑变得更加复杂难懂。如果确实需要可变，可以用stringbuilder。不可变可保证线程安全。</p>
<h3 id="过滤器、监听器、拦截器、触发器"><a href="#过滤器、监听器、拦截器、触发器" class="headerlink" title="过滤器、监听器、拦截器、触发器"></a>过滤器、监听器、拦截器、触发器</h3><h4 id="过滤器："><a href="#过滤器：" class="headerlink" title="过滤器："></a>过滤器：</h4><ol>
<li>在请求进入容器之后、获取servelt之前生效，返回时也是在servelt请求之后生效。生命周期由servelt容器管理。</li>
<li>实现基于回调函数</li>
<li>常用的场景式过滤敏感信息、设置字符编码、进行url级别的权限控制。</li>
<li>可通过webFilter注解实现</li>
</ol>
<h4 id="拦截器："><a href="#拦截器：" class="headerlink" title="拦截器："></a>拦截器：</h4><ol>
<li>请求在进入controller前后、可以获取ioc容器的各个bean，生命周期由ioc容器管理</li>
<li>依赖的是反射机制</li>
<li>用于面向切面编程，常用有登录权限控制、事务管理、日志管理等。</li>
<li>通过实现HandlerInterceptor来自定义拦截器</li>
</ol>
<h4 id="触发器："><a href="#触发器：" class="headerlink" title="触发器："></a>触发器：</h4><p>触发器常用于定时任务，比如一些需要定点执行的操作可用触发器完成</p>
<h4 id="监听器："><a href="#监听器：" class="headerlink" title="监听器："></a>监听器：</h4><p>用于对web容器中对象增删查改后相关的业务操作。</p>
<h3 id="hashMap相关"><a href="#hashMap相关" class="headerlink" title="hashMap相关"></a>hashMap相关</h3><ol>
<li>hashMap的原理：HashMap以数组+链表形式实现，数组是HashMap的主体，每个数组元素上都有一个链表结构。</li>
<li>负载因子：<br>负载因子初始为0.75，可以手动调整，负载因子的大小决定hashMap容器的容量在多大时进行扩容，比如目前大小是16，那就是16*0.75 &#x3D;<br>12时进行扩容。负载因子增大可以提升空间利用率，但会导致红黑树会变得更加复杂,进而导致查询效率降低。而负载因子调小可以让hashmap更快速扩容，提升查询效率，但会导致资源浪费。0.75是总结出来的比较合适的一个数，如果有个性化需要，也可以进行调整。</li>
<li>LinkedHashMap:是hashMap的一个子类，记录了插入顺序，如果需要输入顺序和输出顺序相同，则可以用它。</li>
<li>treeMap：录入时会对键值进行排序，默认按升序</li>
<li>HashSet：简化版的hashMap，存的是不重复的键的集合，不是key-value结构。线程非安全。</li>
</ol>
<h3 id="java中的多态有什么特性"><a href="#java中的多态有什么特性" class="headerlink" title="java中的多态有什么特性"></a>java中的多态有什么特性</h3><p>概念：允许统一操作作用于不同对象产生的不同行为。<br>类型：</p>
<ol>
<li>编译时多态，通过方法重载实现</li>
<li>运行时多态，通过方法重写和向上转型实现</li>
</ol>
<ul>
<li><p>运行时多态（核心机制）：</p>
<ul>
<li><p>实现方案：</p>
<ul>
<li>继承+方法重写：子类重写父类的方法</li>
<li>向上转型：父类引用指向子类对象</li>
<li>动态绑定：JVM在运行时根据对象实际决定调用哪个方法</li>
</ul>
<p>例：<br>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"> class Animal &#123;</span><br><span class="line">void sound() &#123;</span><br><span class="line">System.out.println(&quot;Animal makes sound&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">class Dog extends Animal &#123;</span><br><span class="line">    @Override</span><br><span class="line">    void sound() &#123;</span><br><span class="line">        System.out.println(&quot;Dog barks&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">class Cat extends Animal &#123;</span><br><span class="line">    @Override</span><br><span class="line">    void sound() &#123;</span><br><span class="line">        System.out.println(&quot;Cat meows&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">public class Test &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Animal animal1 = new Dog(); // 向上转型</span><br><span class="line">        Animal animal2 = new Cat(); // 向上转型</span><br><span class="line">  </span><br><span class="line">        animal1.sound(); // 输出 &quot;Dog barks&quot;（动态绑定）</span><br><span class="line">        animal2.sound(); // 输出 &quot;Cat meows&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
</li>
</ul>
</li>
<li><p>编译时多态：同一个类有多个不同的同名方法，参数列表不同（类型、数量、顺序）</p>
<ul>
<li>绑定机制：编译时根据参数类型来确定调用哪个方法（静态绑定）</li>
</ul>
</li>
</ul>
<p><strong>总结：</strong></p>
<blockquote>
<ul>
<li>多态性本质：同一操作在不同对象上会表现出不同的行为</li>
<li>核心价值：提高代码的灵活性、可扩展性、可维护性</li>
<li>实现关键：继承&#x2F;接口+方法重写+向上转型+动态绑定。</li>
<li>合理利用多态性，可以使代码简洁，解耦。适应复杂的需求变化</li>
</ul>
</blockquote>
<h3 id="StringBuffer和StringBuilder的区别"><a href="#StringBuffer和StringBuilder的区别" class="headerlink" title="StringBuffer和StringBuilder的区别"></a>StringBuffer和StringBuilder的区别</h3><p>StringBuffer线程安全，其append使用了synchronized关键字来修饰，StringBuilder线程不安全</p>
<h3 id="重写和重载的区别"><a href="#重写和重载的区别" class="headerlink" title="重写和重载的区别"></a>重写和重载的区别</h3><ol>
<li>重载必须是在同一个类中，方法名相同，但后面具体的参数不同；重写是子类重写父类的方法</li>
<li>静态方法可以重载，但不能重写</li>
<li>重载是在编译时多态；重写是在运行时多态</li>
</ol>
<h2 id="多线程相关"><a href="#多线程相关" class="headerlink" title="多线程相关"></a>多线程相关</h2><h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><p><strong>常见线程池：</strong></p>
<ol>
<li>Executors.newCacheThreadPool()：<ul>
<li>可缓存线程池，先查看池中有没有以前建立的线程，如果有，就直接使用。如果没有，就建一个新的线程加入池中，缓存型池子通常用于执行一些生存期很短的异步型任务。该线程池无限大</li>
</ul>
</li>
<li>Executors.newFixedThreadPool(int n)：<ul>
<li>创建一个可重用固定个数的线程池，以共享的无界队列方式来运行这些线程。</li>
<li>定长线程池的大小最好根据系统资源进行设置。</li>
<li>CPU 核数 &#x3D; Runtime.getRuntime().availableProcessors()</li>
<li>如果是计算密集型：线程数设置为CPU核数+1</li>
<li>如果是IO密集型，线程数设置为2倍的CPU核数</li>
</ul>
</li>
<li>Executors.newScheduledThreadPool(int n)：<ul>
<li>创建一个定长线程池，支持定时及周期性任务执行</li>
</ul>
</li>
<li>Executors.newSingleThreadExecutor()：<ul>
<li>创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。</li>
</ul>
</li>
<li>ThreadPoolExecutor：自定义线程池</li>
</ol>
<h3 id="BlockingQueue（缓冲队列）"><a href="#BlockingQueue（缓冲队列）" class="headerlink" title="BlockingQueue（缓冲队列）"></a>BlockingQueue（缓冲队列）</h3><ol>
<li>缓冲队列BlockingQueue简介：<ul>
<li>BlockingQueue是双缓冲队列。BlockingQueue内部使用两条队列，允许两个线程同时向队列一个存储，一个取出操作。在保证并发安全的同时，提高了队列的存取效率。</li>
<li>常用的几种BlockingQueue：<ul>
<li>ArrayBlockingQueue（int i）:规定大小的BlockingQueue，其构造必须指定大小。其所含的对象是FIFO顺序排序的。<br>2）LinkedBlockingQueue（）或者（inti）:<br>大小不固定的BlockingQueue，若其构造时指定大小，生成的BlockingQueue有大小限制，不指定大小，其大小有Integer.MAX_VALUE来决定。其所含的对象是FIFO顺序排序的。</li>
<li>PriorityBlockingQueue（）或者（int i）:类似于LinkedBlockingQueue，但是其所含对象的排序不是FIFO，而是依据对象的自然顺序或者构造函数的Comparator决定。</li>
<li>SynchronizedQueue（）:特殊的BlockingQueue，对其的操作必须是放和取交替完成。</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="线程池的七大核心参数"><a href="#线程池的七大核心参数" class="headerlink" title="线程池的七大核心参数"></a>线程池的七大核心参数</h3><ol>
<li>核心线程数（corePoolSize）：线程池的核心线程数也是最小线程数，这些线程不会被回收，即使没有线程执行，也只会处于空闲状态，如果线程池中的线程数小于核心线程数，则会在执行任务时创建。</li>
<li>最大线程数（maximumPoolSize）：线程池所允许的最大线程数量，当核心线程数满了，且队列满了之后，会继续创建线程。</li>
<li>keepAliveTime：超过核心线程数的临时线程的存活时间</li>
<li>unit：存活时间的单位，s、ms等等</li>
<li>工作队列（workQueue）：当核心线程数满了之后，会创建工作队列，缓冲队列是一个先进先出的模式底层实现设计java的AQS机制。</li>
<li>创建线程的工厂类：通常我们会自定义一个线程工厂的名称，以方便快速定位线程</li>
<li>线程拒绝策略，当线程池和队列满了之后，会执行线程的拒绝策略</li>
</ol>
<h3 id="线程池的四大拒绝策略"><a href="#线程池的四大拒绝策略" class="headerlink" title="线程池的四大拒绝策略"></a>线程池的四大拒绝策略</h3><ol>
<li>线程池默认拒绝策略：抛异常处理</li>
<li>直接丢弃不处理</li>
<li>丢弃最老的线程队列</li>
<li>等待调用execute进行处理，页面进行loding状态</li>
</ol>
<h3 id="线程池使用原则"><a href="#线程池使用原则" class="headerlink" title="线程池使用原则"></a>线程池使用原则</h3><ol>
<li>线程工厂类参数一定要传，且一定要有意义，方便后期问题定位</li>
<li>尽量避免为局部变量创建线程池，引入线程池的目的是为了提高资源的复用率，为局部变量创建线程池很难达到这个效果，而且如果忘记调用shutdown，多次运行后会出现内存泄露的情况（OutOfMemoryError）</li>
<li>设计可监控的线程池<ol>
<li>对拒绝策略监控，一旦进入拒绝策略，说明最大线程数都处理不过来了，这种情况必须进行处理</li>
<li>监控队列大小：如果队列有积压，说明服务可能会有问题，需要关注。</li>
<li>监控活跃线程数量，如果线程池设置过大，会造成资源的浪费，可以根据日常活跃线程数来调整线程池大小。</li>
<li>监控线程总数，创建线程时候+1，销毁时-1，这样来监控是否有资源泄露。</li>
</ol>
</li>
</ol>
<h3 id="进程和线程的区别"><a href="#进程和线程的区别" class="headerlink" title="进程和线程的区别"></a>进程和线程的区别</h3><ol>
<li>线程是进程的基本单元，一个进程至少有一个线程</li>
<li>进程是系统正在运行的基本程序，每个进程是独立的。举个例子：手机里可以同时运行，微信，QQ，淘宝，京东，而这几个每个软件都可以有多线程执行。</li>
</ol>
<h3 id="Threadlocal"><a href="#Threadlocal" class="headerlink" title="Threadlocal"></a>Threadlocal</h3><p>本地线程变量，多线程访问同一个共享变量时候会有并发问题，如果创建一个ThreadLocal变量来修饰的话，每个线程都会有这个变量的一个副本，实际操作时操作的是本地内存中的变量，从而规避线程安全问题。</p>
<h3 id="AQS机制（抽象队列同步器）"><a href="#AQS机制（抽象队列同步器）" class="headerlink" title="AQS机制（抽象队列同步器）"></a>AQS机制（抽象队列同步器）</h3><p>AQS是java并发包的核心框架，通过FIFO等待队列和状态管理机制，实现锁的等待和唤醒。</p>
<ul>
<li>核心思想：<ol>
<li>资源共享模式：<ul>
<li>独占模式：同一时刻，只有一个线程可以访问资源</li>
<li>共享模式：统一时刻，有多个线程可以访问资源</li>
</ul>
</li>
<li>状态管理：<ul>
<li>AQS是使用一个volatile的int类型变量state来表示同步状态，通过getState(),setState(),compareAndSetState()方法来操作状态</li>
</ul>
</li>
<li>等待队列：<ul>
<li>AQS维护一个FIFO（先进先出）的双向队列，用户存储等待获取资源的线程；每个节点代表一个等待线程，包含引用、等待状态等信息</li>
</ul>
</li>
<li>模板方法设计模式：<ul>
<li>AQS是一个抽象类，定义了获取和释放资源的方法（如acquire(),release()）。</li>
<li>具体的同步器需要实现tryAcquire()和tryRelease()方法，定义如何获取和释放资源</li>
</ul>
</li>
</ol>
</li>
<li>优点：<ol>
<li>比较灵活，可以自由的实现各种同步工具。</li>
<li>使用cas操作和volatile变量，避免锁的开销</li>
<li>可以根据AQS实现自定义的同步器</li>
</ol>
</li>
<li>缺点：<ol>
<li>实现较为复杂，需要深入理解其内部逻辑</li>
<li>调试比较困难，尤其是涉及并发的场景</li>
</ol>
</li>
</ul>
<blockquote>
<p>总结：AQS是java并发包的核心框架，通过状态管理、等待队列和模板方法设计模式，提供灵活、高性能的同步机制。</p>
</blockquote>
<h3 id="在线程池中，execute-和submit-有什么区别？"><a href="#在线程池中，execute-和submit-有什么区别？" class="headerlink" title="在线程池中，execute()和submit()有什么区别？"></a>在线程池中，execute()和submit()有什么区别？</h3><p>这是线程池中提交任务的两种方法</p>
<ul>
<li>区别：<ol>
<li>execute()没有返回值，直接返回void类型，但submit()会返回Future类型，可以通过Future.get()来获取异常信息</li>
<li>execute()适用于不需要返回结果的简单业务场景，submit()适用于需要获取结果或处理异常的任务。</li>
</ol>
</li>
</ul>
<h2 id="分布式问题"><a href="#分布式问题" class="headerlink" title="分布式问题"></a>分布式问题</h2><h3 id="如何设计一个秒杀系统"><a href="#如何设计一个秒杀系统" class="headerlink" title="如何设计一个秒杀系统"></a>如何设计一个秒杀系统</h3><ol>
<li>秒杀系统的常见问题：<ol>
<li>频繁访问数据库，导致服务挂掉</li>
<li>缓存穿透、缓存击穿和缓存雪崩</li>
<li>链接暴露，被提前秒杀</li>
<li>流量过大</li>
<li>超卖</li>
</ol>
</li>
<li>解决方案：<ol>
<li>服务单一职责，新建秒杀数据库，就算真的挂掉也不影响其他服务</li>
<li>缓存问题方案见redis</li>
<li>链接被别人以F12的方式提前搞走，进行提前秒杀，通过加密让前端获取动态链接，保证链接不会提前暴露</li>
<li>流量过大可以采用redis集群，哨兵机制，已经mq消峰</li>
<li>数据加载到redis中，通过redis事务的原子性来控制超卖</li>
<li>其他手段：秒杀前前端按钮置灰，不允许频繁点击，连续点击多次就提示其等等再点。</li>
<li>解决超卖问题：悲观锁，乐观锁，队列形式：做订单队列。一个一个处理，达到阈值就显示卖完。用redis的原子自增操作：讲操作改为先申请后确认，再有在redis处理完后再进行异步写库。有可能导致数据一致和少卖的情况（申请后不确认付款，也会占用名额）。</li>
<li>京东库存系统关于超卖的处理：首先设置预占库存，若可用库存不足，则不再对外销售，其次用乐观锁，在写库时查版本号，最后有安全库存的设置。保证有少量超卖也无所谓。</li>
</ol>
</li>
</ol>
<h3 id="哨兵机制"><a href="#哨兵机制" class="headerlink" title="哨兵机制"></a>哨兵机制</h3><ul>
<li>在redis集群中会有主服务器和从服务器，若其中一个服务器出现问题，则需要进行故障转移，如何判断，转移，就需要用到哨兵机制</li>
<li>哨兵机制主要执行以下三个任务：</li>
</ul>
<ol>
<li>监控：定期向主从服务器发送请求，看是否能正常返回，不可以就认为可能出现问题</li>
<li>提醒：当哨兵监控到服务器问题后，会向管理员发送故障提醒</li>
<li>）自动故障转移：当主服务器出现问题，哨兵会自动选举新的主服务器，当客户端请求过来时，返回新的请求地址。</li>
</ol>
<h3 id="如果服务器崩溃了，在不影响客户使用的前提下，应该怎么处理"><a href="#如果服务器崩溃了，在不影响客户使用的前提下，应该怎么处理" class="headerlink" title="如果服务器崩溃了，在不影响客户使用的前提下，应该怎么处理"></a>如果服务器崩溃了，在不影响客户使用的前提下，应该怎么处理</h3><ol>
<li>高可用架构，尽可能减少对客户的影响</li>
<li>负载均衡：将流量发送到不同的服务器</li>
<li>集群部署：确保多台服务器同时运行</li>
<li>自动故障转移：使用主从复制或分布式一致性协议，实现自动故障转移</li>
<li>监控告警：监控CPU、内存、磁盘、网络等，设置阈值，达到就告警</li>
<li>定期对服务器进行健康检查</li>
<li>崩溃后快速恢复：自动重启、故障隔离、数据恢复</li>
<li>容灾恢复：备份策略、容灾演练、多区域部署</li>
<li>客户端容错处理：重试机制、缓存数据、优雅降级（友好的错误提示）</li>
<li>日志与故障分析：日志收集、故障分析、改进措施</li>
</ol>
<h2 id="算法相关"><a href="#算法相关" class="headerlink" title="算法相关"></a>算法相关</h2><h3 id="雪花算法："><a href="#雪花算法：" class="headerlink" title="雪花算法："></a>雪花算法：</h3><blockquote>
<p>雪花算法是Twitter公司发明的一种算法，主要目的是解决在分布式环境下，ID怎样生成的问题</p>
</blockquote>
<ol>
<li>分布式ID生成规则硬性要求：全局唯一：不能出现重复的ID号，单调递增</li>
<li>分布式ID生成可用性要求：<ul>
<li>高可用：发布一个获取分布式ID的请求，服务器就要保证99.999%的情况下给创建一个全局唯一的分布式ID。</li>
<li>低延迟：发布一个获取分布式ID的请求，要快，急速。</li>
<li>高QPS：假如并发一口气10万个创建分布式ID请求同时杀过来，服务器要顶得住并且成功创建10万个分布式ID</li>
</ul>
</li>
<li></li>
</ol>
<p>经测试snowflake每秒能生成26万个自增可排序的ID。snowflake生成的ID结果是一个64bit大小的整数，为一个Long型（转换成字符串后长度最多19）。分布式系统内不会产生ID碰撞（datacenter和workerId作区分）并且效率高。不依赖数据库等第三方系统，以服务的方式部署，稳定性更高，生成ID的性能也非常高，可以根据自身业务分配bit位，非常灵活。</p>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="followme">
  <span>欢迎关注我的其它发布渠道</span>

  <div class="social-list">

      <div class="social-item">
          <span class="social-link">
            <span class="icon">
              <i class="fab fa-weixin"></i>
            </span>

            <span class="label">WeChat</span>
          </span>

          <img class="social-item-img" src="/images/wechat_channel.png">
      </div>
  </div>
</div>

          <div class="post-tags">
              <a href="/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/" rel="tag"># 面试题</a>
              <a href="/tags/Java/" rel="tag"># Java</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2022/10/01/technology/java/java_review/" rel="prev" title="Java基础知识面试题">
                  <i class="fa fa-angle-left"></i> Java基础知识面试题
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2022/10/02/technology/java/java_gc_recycle/" rel="next" title="Java GC垃圾回收">
                  Java GC垃圾回收 <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>


  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">zhyyao</span>
  </div>

<div class="powered-by">
<i class="fa fa-user-md"></i><span id="busuanzi_container_site_uv">
  本站访客数:<span id="busuanzi_value_site_pv"></span>
</span>
</div>

<!--
  <div class="powered-by">由 Zhyyao 强力驱动
  </div>
-->

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdn.jsdelivr.net/npm/darkmode-js@1.5.7/lib/darkmode-js.min.js"></script>
<script>
var options = {
  bottom: '64px', // default: '32px'
  right: 'unset', // default: '32px'
  left: '32px', // default: 'unset'
  time: '0.5s', // default: '0.3s'
  mixColor: '#fff', // default: '#fff'
  backgroundColor: '#fff',  // default: '#fff'
  buttonColorDark: '#100f2c',  // default: '#100f2c'
  buttonColorLight: '#fff', // default: '#fff'
  saveInCookies: true, // default: true,
  label: '🌓', // default: ''
  autoMatchOsTheme: true // default: true
}
const darkmode = new Darkmode(options);
darkmode.showWidget();
</script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/next-theme-pjax/0.6.0/pjax.min.js" integrity="sha256-vxLn1tSKWD4dqbMRyv940UYw4sXgMtYcK6reefzZrao=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/lozad.js/1.16.0/lozad.min.js" integrity="sha256-mOFREFhqmHeQbXpK2lp4nA3qooVgACfh88fpJftLBbc=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/sidebar.js"></script><script src="/js/next-boot.js"></script><script src="/js/pjax.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>







  





</body>
</html>

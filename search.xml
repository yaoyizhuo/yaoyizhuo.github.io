<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Go-GC垃圾回收</title>
    <url>/2021/02/03/technology/golang/gc_recycle/</url>
    <content><![CDATA[<h2 id="Go垃圾回收"><a href="#Go垃圾回收" class="headerlink" title="Go垃圾回收"></a>Go垃圾回收</h2><ul>
<li><p>G0 V1.3之前的标记-清除(mark and sweep)算法</p>
</li>
<li><p>Go V1.3之前的标记-清扫(mark and sweep)的缺点</p>
</li>
<li><p>Go V1.5的三色并发标记法</p>
</li>
<li><p>Go V1.5的三色标记为什么需要STW</p>
</li>
<li><p>Go V1.5的三色标记为什么需要屏障机制(“强-弱” 三色不变式、插入屏障、删除屏障 )</p>
</li>
<li><p>Go V1.8混合写屏障机制</p>
</li>
<li><p>Go V1.8混合写屏障机制的全场景分析</p>
</li>
</ul>
<h2 id="Go-V1-3-标记-清除算法"><a href="#Go-V1-3-标记-清除算法" class="headerlink" title="Go V1.3 标记-清除算法"></a>Go V1.3 标记-清除算法</h2><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><ul>
<li><p>标记(Mark phase)</p>
</li>
<li><p>清除(Sweep phase)</p>
</li>
</ul>
<p><strong>第一步</strong>，暂停程序业务逻辑, 找出不可达的对象，然后做上标记。</p>
<p>操作非常简单，但是有一点需要额外注意：mark and sweep算法在执行的时候，需要程序暂停！即 <code>STW(stop the world)</code>。也就是说，这段时间程序会卡在哪儿。</p>
<img data-src="/2021/02/03/technology/golang/gc_recycle/image.png" class="" title="image.png">


<p><strong>第二步</strong>, 开始标记，程序找出它所有可达的对象，并做上标记。如下图所示：</p>
<img data-src="/2021/02/03/technology/golang/gc_recycle/image_1.png" class="" title="image.png">

<p><strong>第三步</strong>, 标记完了之后，然后开始清除未标记的对象. 结果如下.</p>
<img data-src="/2021/02/03/technology/golang/gc_recycle/image_2.png" class="" title="image.png">

<p><strong>第四步</strong>, 停止暂停，让程序继续跑。然后循环重复这个过程，直到process程序生命周期结束。</p>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li>STW，stop the world；让程序暂停，程序出现卡顿 (重要问题)。</li>
<li>标记需要扫描整个heap</li>
<li>清除数据会产生heap碎片</li>
</ul>
<p>所以Go V1.3版本之前就是以上来实施的, 流程是</p>
<img data-src="/2021/02/03/technology/golang/gc_recycle/image_3.png" class="" title="image.png">
<p>Go V1.3 做了简单的优化,将STW提前, 减少STW暂停的时间范围.如下所示</p>
<img data-src="/2021/02/03/technology/golang/gc_recycle/image_4.png" class="" title="image.png">
<p><strong>这里面最重要的问题就是：mark-and-sweep 算法会暂停整个程序。</strong><br>Go是如何面对并这个问题的呢？接下来G V1.5版本 就用三色并发标记法来优化这个问题.</p>
<h2 id="Go-V1-5的三色并发标记法"><a href="#Go-V1-5的三色并发标记法" class="headerlink" title="Go V1.5的三色并发标记法"></a>Go V1.5的三色并发标记法</h2><p>三色标记法 实际上就是通过三个阶段的标记来确定清楚的对象都有哪些. 我们来看一下具体的过程.</p>
<p><strong>第一步</strong>, 就是只要是新创建的对象,默认的颜色都是标记为“白色”.</p>
<img data-src="/2021/02/03/technology/golang/gc_recycle/image_5.png" class="" title="image.png">
<p>这里面需要注意的是, 所谓“程序”, 则是一些对象的跟节点集合.</p>
<img data-src="/2021/02/03/technology/golang/gc_recycle/image_6.png" class="" title="image.png">
<p>所以上图,可以转换如下的方式来表示.</p>
<p><strong>第二步</strong>, 每次GC回收开始, 然后从根节点开始遍历所有对象，把遍历到的对象从白色集合放入“灰色”集合。</p>
<img data-src="/2021/02/03/technology/golang/gc_recycle/image_7.png" class="" title="image.png">
<p><strong>第三步</strong>, 遍历灰色集合，将灰色对象引用的对象从白色集合放入灰色集合，之后将此灰色对象放入黑色集合</p>
<img data-src="/2021/02/03/technology/golang/gc_recycle/image_8.png" class="" title="image.png">
<p><strong>第四步</strong>, 重复第三步, 直到灰色中无任何对象.</p>
<img data-src="/2021/02/03/technology/golang/gc_recycle/image_9.png" class="" title="image.png">
<img data-src="/2021/02/03/technology/golang/gc_recycle/image_10.png" class="" title="image.png">
<p><strong>第五步</strong>，回收所有的白色标记表的对象. 也就是回收垃圾.</p>
<img data-src="/2021/02/03/technology/golang/gc_recycle/image_11.png" class="" title="image.png">

<p>以上便是<code>三色并发标记法</code>, 不难看出,我们上面已经清楚的体现<code>三色</code>的特性</p>
<h2 id="没有STW的三色标记法"><a href="#没有STW的三色标记法" class="headerlink" title="没有STW的三色标记法"></a>没有STW的三色标记法</h2><p>我们还是基于上述的三色并发标记法来说, 他是一定要依赖STW的. 因为如果不暂停程序, 程序的逻辑改变对象引用关系, 这种动作如果在标记阶段做了修改，会影响标记结果的正确性。我们举一个场景.</p>
<p>如果三色标记法, 标记过程不使用STW将会发生什么事情?</p>
<img data-src="/2021/02/03/technology/golang/gc_recycle/image_12.png" class="" title="image.png">
<hr>
<img data-src="/2021/02/03/technology/golang/gc_recycle/image_13.png" class="" title="image.png">




<img data-src="/2021/02/03/technology/golang/gc_recycle/image_14.png" class="" title="image.png">
<img data-src="/2021/02/03/technology/golang/gc_recycle/image_15.png" class="" title="image.png">
<img data-src="/2021/02/03/technology/golang/gc_recycle/image_16.png" class="" title="image.png">
<p>可以看出，有两个问题, 在三色标记法中,是不希望被发生的</p>
<ul>
<li><p><strong>条件1:</strong> 一个白色对象被黑色对象引用(白色被挂在黑色下)</p>
</li>
<li><p><strong>条件2:</strong> 灰色对象与它之间的可达关系的白色对象遭到破坏(灰色同时丢了该白色)</p>
</li>
</ul>
<p>当以上两个条件同时满足时, 就会出现对象丢失现象!</p>
<p>当然, 如果上述中的白色对象3, 如果他还有很多下游对象的话, 也会一并都清理掉.</p>
<p>为了防止这种现象的发生，最简单的方式就是STW，直接禁止掉其他用户程序对对象引用关系的干扰，但是STW的过程有明显的资源浪费，对所有的用户程序都有很大影响，如何能在保证对象不丢失的情况下合理的尽可能的提高GC效率，减少STW时间呢？</p>
<p>答案就是, 那么我们只要使用一个机制,来破坏上面的两个条件就可以了.</p>
<p>五、屏障机制</p>
<p>我们让GC回收器,满足下面两种情况之一时,可保对象不丢失. 所以引出两种方式.</p>
<h3 id="“强-弱”-三色不变式"><a href="#“强-弱”-三色不变式" class="headerlink" title="“强-弱” 三色不变式"></a>“强-弱” 三色不变式</h3><p>01</p>
<ul>
<li><strong>强三色不变式</strong></li>
</ul>
<p>不存在黑色对象引用到白色对象的指针。</p>
<img data-src="/2021/02/03/technology/golang/gc_recycle/image_17.png" class="" title="image.png">
<ul>
<li><strong>弱三色不变式</strong></li>
</ul>
<p>所有被黑色对象引用的白色对象都处于灰色保护状态.</p>
<img data-src="/2021/02/03/technology/golang/gc_recycle/image_18.png" class="" title="image.png">

<p>为了遵循上述的两个方式,Golang团队初步得到了如下具体的两种屏障方式“插入屏障”, “删除屏障”.</p>
<h3 id="插入屏障"><a href="#插入屏障" class="headerlink" title="插入屏障"></a>插入屏障</h3><p>02</p>
<p><code>具体操作</code>: 在A对象引用B对象的时候，B对象被标记为灰色。(将B挂在A下游，B必须被标记为灰色)</p>
<p><code>满足</code>: 强三色不变式. (不存在黑色对象引用白色对象的情况了， 因为白色会强制变成灰色)</p>
<p>伪码如下:</p>
<p><code>添加下游对象``(``当前下游对象**slot**``,</code> <code>新下游对象**ptr**``) &#123;     //1     标记灰色(``新下游对象**ptr**``)          //2    `` 当前下游对象**slot**</code> <code>=</code> <code>新下游对象**ptr**``   &#125;</code></p>
<p>场景：</p>
<figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="code"><pre><span class="line">A.添加下游对象(nil, B)   //A 之前没有下游， 新添加一个下游对象B， B被标记为灰色</span><br><span class="line">A.添加下游对象(C, B)     //A 将下游对象C 更换为B，  B被标记为灰色</span><br></pre></td></tr></table></figure>


<p>这段伪码逻辑就是写屏障,. 我们知道,黑色对象的内存槽有两种位置, <code>栈</code>和<code>堆</code>. 栈空间的特点是容量小,但是要求相应速度快,因为函数调用弹出频繁使用, 所以“插入屏障”机制,在栈空间的对象操作中不使用. 而仅仅使用在堆空间对象的操作中.</p>
<p>接下来，我们用几张图，来模拟整个一个详细的过程， 希望您能够更可观的看清晰整体流程。</p>
<img data-src="/2021/02/03/technology/golang/gc_recycle/image_19.png" class="" title="image.png">
<img data-src="/2021/02/03/technology/golang/gc_recycle/image_20.png" class="" title="image.png">
<img data-src="/2021/02/03/technology/golang/gc_recycle/image_21.png" class="" title="image.png">

<img data-src="/2021/02/03/technology/golang/gc_recycle/image_22.png" class="" title="image.png">



<img data-src="/2021/02/03/technology/golang/gc_recycle/image_23.png" class="" title="image.png">

<img data-src="/2021/02/03/technology/golang/gc_recycle/image_24.png" class="" title="image.png">

<p>但是如果栈不添加,当全部三色标记扫描之后,栈上有可能依然存在白色对象被引用的情况(如上图的对象9). 所以要对栈重新进行三色标记扫描, 但这次为了对象不丢失, 要对本次标记扫描启动STW暂停. 直到栈空间的三色标记结束.</p>
<img data-src="/2021/02/03/technology/golang/gc_recycle/image_25.png" class="" title="image.png">

<img data-src="/2021/02/03/technology/golang/gc_recycle/image_26.png" class="" title="image.png">

<img data-src="/2021/02/03/technology/golang/gc_recycle/image_27.png" class="" title="image.png">

<p>最后将栈和堆空间 扫描剩余的全部 白色节点清除. 这次STW大约的时间在10~100ms间.</p>
<img data-src="/2021/02/03/technology/golang/gc_recycle/image_28.png" class="" title="image.png">

<hr>
<h3 id="删除屏障"><a href="#删除屏障" class="headerlink" title="删除屏障"></a>删除屏障</h3><p>03</p>
<p><code>具体操作</code>: 被删除的对象，如果自身为灰色或者白色，那么被标记为灰色。</p>
<p><code>满足</code>: 弱三色不变式. (保护灰色对象到白色对象的路径不会断)</p>
<p>伪代码：</p>
<p><code>添加下游对象``(``当前下游对象**slot**``，</code> <code>新下游对象**ptr**``) &#123;     //1     if (``当前下游对象**slot**``是灰色 ||</code> <code>当前下游对象**slot**``是白色) &#123;             标记灰色(``当前下游对象**slo**``**t**``) //slot为被删除对象， 标记为灰色     &#125;          //2</code>  <code>当前下游对象**slot**</code> <code>=</code> <code>新下游对象**ptr**``   &#125;</code></p>
<p>场景：</p>
<figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="code"><pre><span class="line">A.添加下游对象(B, nil)   //A对象，删除B对象的引用。B被A删除，被标记为灰(如果B之前为白)</span><br><span class="line">A.添加下游对象(B, C)     //A对象，更换下游B变成C。B被A删除，被标记为灰(如果B之前为白)</span><br></pre></td></tr></table></figure>


<p>接下来，我们用几张图，来模拟整个一个详细的过程， 希望您能够更可观的看清晰整体流程。</p>
<img data-src="/2021/02/03/technology/golang/gc_recycle/image_29.png" class="" title="image.png">
<img data-src="/2021/02/03/technology/golang/gc_recycle/image_30.png" class="" title="image.png">
<img data-src="/2021/02/03/technology/golang/gc_recycle/image_31.png" class="" title="image.png">

<img data-src="/2021/02/03/technology/golang/gc_recycle/image_32.png" class="" title="image.png">

<img data-src="/2021/02/03/technology/golang/gc_recycle/image_33.png" class="" title="image.png">

<img data-src="/2021/02/03/technology/golang/gc_recycle/image_34.png" class="" title="image.png">

<img data-src="/2021/02/03/technology/golang/gc_recycle/image_35.png" class="" title="image.png">





<p>这种方式的回收精度低，一个对象即使被删除了最后一个指向它的指针也依旧可以活过这一轮，在下一轮GC中被清理掉。</p>
<p>六、Go V1.8的混合写屏障(hybrid write barrier)机制</p>
<p>插入写屏障和删除写屏障的短板：</p>
<ul>
<li><strong>插入写屏障</strong>：结束时需要STW来重新扫描栈，标记栈上引用的白色对象的</li>
</ul>
<p>存活；</p>
<ul>
<li><strong>删除写屏障</strong>：回收精度低，GC开始时STW扫描堆栈来记录初始快照，这个</li>
</ul>
<p>过程会保护开始时刻的所有存活对象。</p>
<p>Go V1.8版本引入了混合写屏障机制（hybrid write barrier）,避免了对栈</p>
<p>re-scan的过程，极大的减少了STW的时间。结合了两者的优点。</p>
<hr>
<h3 id="混合写屏障规则"><a href="#混合写屏障规则" class="headerlink" title="混合写屏障规则"></a>混合写屏障规则</h3><p>01</p>
<p><code>具体操作</code>:</p>
<p>1、GC开始将栈上的对象全部扫描并标记为黑色(之后不再进行第二次重复扫描，无需STW)，</p>
<p>2、GC期间，任何在栈上创建的新对象，均为黑色。</p>
<p>3、被删除的对象标记为灰色。</p>
<p>4、被添加的对象标记为灰色。</p>
<p><code>满足</code>: 变形的弱三色不变式.</p>
<p>伪代码：</p>
<p><code>添加下游对象``(``当前下游对象**slot**``,</code> <code>新下游对象**ptr**``) &#123;         //1         标记灰色(``当前下游对象**slot**``) //只要当前下游对象被移走，就标记灰色                  //2         标记灰色(``新下游对象**ptr**``)                      //3</code>      <code>当前下游对象**slot**</code> <code>=</code> <code>新下游对象**ptr**``   &#125;</code></p>
<p>这里我们注意， 屏障技术是不在栈上应用的，因为要保证栈的运行效率。</p>
<h3 id="混合写屏障的具体场景分析"><a href="#混合写屏障的具体场景分析" class="headerlink" title="混合写屏障的具体场景分析"></a>混合写屏障的具体场景分析</h3><p>02</p>
<pre><code>    接下来，我们用几张图，来模拟整个一个详细的过程， 希望您能够更可观的看清晰整体流程。
</code></pre>
<p>注意混合写屏障是Gc的一种屏障机制，所以只是当程序执行GC的时候，才会触发这种机制。</p>
<h3 id="GC开始：扫描栈区，将可达对象全部标记为黑"><a href="#GC开始：扫描栈区，将可达对象全部标记为黑" class="headerlink" title="GC开始：扫描栈区，将可达对象全部标记为黑"></a>GC开始：扫描栈区，将可达对象全部标记为黑</h3><img data-src="/2021/02/03/technology/golang/gc_recycle/image_36.png" class="" title="image.png">

<img data-src="/2021/02/03/technology/golang/gc_recycle/image_37.png" class="" title="image.png">



<h3 id="场景一：对象被一个堆对象删除引用，成为栈对象的下游"><a href="#场景一：对象被一个堆对象删除引用，成为栈对象的下游" class="headerlink" title="场景一：对象被一个堆对象删除引用，成为栈对象的下游"></a>场景一：对象被一个堆对象删除引用，成为栈对象的下游</h3><figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="code"><pre><span class="line">//前提：堆对象4-&gt;对象7 = 对象7；//对象7 被 对象4引用</span><br><span class="line">栈对象1-&gt;对象7 = 堆对象7；//将堆对象7 挂在 栈对象1 下游</span><br><span class="line">堆对象4-&gt;对象7 = null；//对象4 删除引用 对象7</span><br></pre></td></tr></table></figure>


<img data-src="/2021/02/03/technology/golang/gc_recycle/image_38.png" class="" title="image.png">

<img data-src="/2021/02/03/technology/golang/gc_recycle/image_39.png" class="" title="image.png">





<h3 id="场景二：对象被一个栈对象删除引用，成为另一个栈对象的下游"><a href="#场景二：对象被一个栈对象删除引用，成为另一个栈对象的下游" class="headerlink" title="场景二：对象被一个栈对象删除引用，成为另一个栈对象的下游"></a>场景二：对象被一个栈对象删除引用，成为另一个栈对象的下游</h3><p>new 栈对象9；</p>
<p>对象9-&gt;对象3 &#x3D; 对象3；      &#x2F;&#x2F;将栈对象3 挂在 栈对象9 下游</p>
<p>对象2-&gt;对象3 &#x3D; null；      &#x2F;&#x2F;对象2 删除引用 对象3</p>
<img data-src="/2021/02/03/technology/golang/gc_recycle/image_40.png" class="" title="image.png">

<img data-src="/2021/02/03/technology/golang/gc_recycle/image_41.png" class="" title="image.png">
<img data-src="/2021/02/03/technology/golang/gc_recycle/image_42.png" class="" title="image.png">


<h3 id="场景三：对象被一个堆对象删除引用，成为另一个堆对象的下游"><a href="#场景三：对象被一个堆对象删除引用，成为另一个堆对象的下游" class="headerlink" title="场景三：对象被一个堆对象删除引用，成为另一个堆对象的下游"></a>场景三：对象被一个堆对象删除引用，成为另一个堆对象的下游</h3><figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="code"><pre><span class="line">堆对象10-&gt;对象7 = 堆对象7；//将堆对象7 挂在 堆对象10 下游</span><br><span class="line">堆对象4-&gt;对象7 = null；//对象4 删除引用 对象7</span><br></pre></td></tr></table></figure>


<img data-src="/2021/02/03/technology/golang/gc_recycle/image_43.png" class="" title="image.png">
<img data-src="/2021/02/03/technology/golang/gc_recycle/image_44.png" class="" title="image.png">
<img data-src="/2021/02/03/technology/golang/gc_recycle/image_45.png" class="" title="image.png">


<h3 id="场景四：对象从一个栈对象删除引用，成为另一个堆对象的下游"><a href="#场景四：对象从一个栈对象删除引用，成为另一个堆对象的下游" class="headerlink" title="场景四：对象从一个栈对象删除引用，成为另一个堆对象的下游"></a>场景四：对象从一个栈对象删除引用，成为另一个堆对象的下游</h3><p>栈对象1-&gt;对象2 &#x3D; null；      &#x2F;&#x2F;对象1 删除引用 对象2</p>
<p>堆对象4-&gt;对象2 &#x3D; 栈对象2；    &#x2F;&#x2F;对象4 添加 下游 栈对象2</p>
<p>堆对象4-&gt;对象7 &#x3D; null;       &#x2F;&#x2F;对象4 删除引用 对象7null；&#x2F;&#x2F;对象4 删除引用 对象7</p>
<img data-src="/2021/02/03/technology/golang/gc_recycle/image_46.png" class="" title="image.png">
<img data-src="/2021/02/03/technology/golang/gc_recycle/image_47.png" class="" title="image.png">
<img data-src="/2021/02/03/technology/golang/gc_recycle/image_48.png" class="" title="image.png">


<pre><code>    Golang中的混合写屏障满足`弱三色不变式`，结合了删除写屏障和插入写屏障的优点，只需要在开始时并发扫描各个goroutine的栈，使其变黑并一直保持，这个过程不需要STW，而标记结束后，因为栈在扫描后始终是黑色的，也无需再进行re-scan操作了，减少了STW的时间。
</code></pre>
<hr>
<p>七、总结</p>
<pre><code>    以上便是Golang的GC全部的标记-清除逻辑及场景演示全过程。
</code></pre>
<p>GoV1.3- 普通标记清除法，整体过程需要启动STW，效率极低。</p>
<p>GoV1.5- 三色标记法， 堆空间启动写屏障，栈空间不启动，全部扫描之后，需要重新扫描一次栈(需要STW)，效率普通</p>
<p>GoV1.8-三色标记法，混合写屏障机制， 栈空间不启动，堆空间启动。整个过程几乎不需要STW，效率较高。</p>
<p>参考文献:</p>
<p><a href="https://www.cnblogs.com/wangyiyang/p/12191591.html">https://www.cnblogs.com/wangyiyang/p/12191591.html</a><br><a href="https://www.jianshu.com/p/eb6b3aff9ca5">https://www.jianshu.com/p/eb6b3aff9ca5</a><br><a href="https://zhuanlan.zhihu.com/p/74853110">https://zhuanlan.zhihu.com/p/74853110</a></p>
]]></content>
      <categories>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>底层原理</tag>
        <tag>面试题</tag>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title>Gin源码解析</title>
    <url>/2021/02/03/technology/golang/gin_code_analyse/</url>
    <content><![CDATA[<p>gin框架使用的定制版本的http router。<br>http router的原理是大量使用公共前缀的树结构，</p>
<p>它基本是一个紧凑的trie terr或者只是一个RadixTree（基数树）</p>
<p>学到的优秀设计：</p>
<h2 id="gin中的Context-poll"><a href="#gin中的Context-poll" class="headerlink" title="gin中的Context poll"></a>gin中的Context poll</h2><p><strong>Poll用于存储哪些被分配了但是没有被使用,而未来有可能会被使用的值,以减少垃圾回收的压力.</strong></p>
<p>在Web应用中,后台处理用户的每条请求都会为当前请求创建一个上下文环境Context,用于存储请求信息及相关信息等.Context满足一个长生命周期的特点,且用户请求也属于并发环境,所以对于线程安全的Poll非常适合用来维护Context的临时对象池.</p>
<p>Gin在结构体Engine中定义了一个poll</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Engine <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="comment">// ... 省略了其他字段</span></span><br><span class="line">pool    sync.Pool</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>初始化engine时定义了poll的New函数:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">engine.pool.New = <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="keyword">interface</span>&#123;&#125; &#123;</span><br><span class="line">    <span class="keyword">return</span> engine.allocateContext()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// allocateContext</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(engine *Engine)</span></span> allocateContext() *Context &#123;</span><br><span class="line">    <span class="comment">// 构造新的上下文对象</span></span><br><span class="line">    <span class="keyword">return</span> &amp;Context&#123;engine: engine&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="ServerHttp"><a href="#ServerHttp" class="headerlink" title="ServerHttp"></a>ServerHttp</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 从 pool 中获取，并转化为 *Context</span></span><br><span class="line">c := engine.pool.Get().(*Context)</span><br><span class="line">c.writermem.reset(w)</span><br><span class="line">c.Request = req</span><br><span class="line">c.reset() <span class="comment">// reset</span></span><br><span class="line"></span><br><span class="line">engine.handleHTTPRequest(c)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 再扔回 pool 中</span></span><br><span class="line">engine.pool.Put(c)</span><br></pre></td></tr></table></figure>

<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ol>
<li>基于sync.poll使用对象池poll，从池中获取后对它转化Context，减少每次创建方法的CG和内存申请的频率,使用完之后,再扔回对象池中.</li>
</ol>
<p>避免对象的引用的干扰，在不影响项目的实际功能的情况下取出对象。</p>
<ol start="2">
<li>在设计for循环时的优秀设计：</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>,lens=<span class="built_in">len</span>(arr);i&lt;lens;i++&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<ol start="3">
<li>提倡最小执行代码原则：</li>
</ol>
<p>把应该立即返回的条件写在前面</p>
<p>4.在写完一个结构体后，在结构体下方新建一个接口类型的匿名变量</p>
<blockquote>
<p>目的：为了确保结构体实现了这个接口，把错误保留在编译阶段</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Engine <span class="keyword">struct</span>&#123;...&#125;</span><br><span class="line"><span class="keyword">var</span> _ Irouter [匿名变量的类型] = &amp;Engine&#123;&#125;</span><br></pre></td></tr></table></figure>


<p>5.为什么不用map而要用树遍历的方法？ map比较slice更占内存</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(trees methodTrees)</span></span> get(method <span class="type">string</span>) *node &#123;</span><br><span class="line">    <span class="keyword">for</span> _, tree := <span class="keyword">range</span> trees &#123;</span><br><span class="line">        <span class="keyword">if</span> tree.method == method &#123;</span><br><span class="line">            <span class="keyword">return</span> tree.root</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>6.当已知一个切片的容量时，我可以在初始化的时候一次性把切片的容量申请到位，避免动态申请slice。</p>
]]></content>
      <categories>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>面试题</tag>
        <tag>Golang</tag>
        <tag>Gin框架</tag>
      </tags>
  </entry>
  <entry>
    <title>Go语言底层基础知识</title>
    <url>/2021/02/01/technology/golang/go_basic/</url>
    <content><![CDATA[<h2 id="new和make的区别"><a href="#new和make的区别" class="headerlink" title="new和make的区别"></a>new和make的区别</h2><ol>
<li>new和make都是全部用来分配内存的关键字，new(T)创建一个没有任何数据的类型为T的实例，并返回该实例的指针；make(T, args)只能创建 slice、map和channel，并且返回一个有初始值args（非零）的T类型的实例，非指针。</li>
<li>对于返回值，new用于类型的内存分配，并且内存置零，返回的是一个指向类型的指针；make是对他们的初始化，（非0值）返回的是一个类型引用对象 ，对于引用类型的变量，我们不光要声明它，还要为它分配内容空间 。</li>
<li>对于入参，new只有一个Type参数，Type可以是任何类型的数据；make传入Type参数（map、slice、chan）中的一种，还有一个size  。（map：根据slice大小分配资源，以足够存储size个元素，如果省略size，会默认分配一个小的起始size ；slice ：第一个是长度，第二个是cap（容量）；对于chan，size表示缓冲区容量；如果省略则表示channel为无缓冲的channel）<br>总结：</li>
</ol>
<ul>
<li><p>new() 是分配内存给一个零值的指针，返回的是这个类型的指针，还可以返回自己定义的结构体，置零之后的。</p>
</li>
<li><p>make（）是开辟一块内存，并且初始化，返回这个经过初始化的对象，只能初始化slice、map、chan，返回的是这个类型的引用，它可以设置初始化的长度，如果是slice，则可以添加一个参数，容量，容量的大小要小于slice的大小。</p>
</li>
</ul>
<h2 id="array和slice的区别"><a href="#array和slice的区别" class="headerlink" title="array和slice的区别"></a>array和slice的区别</h2><ol>
<li>array在定义的时候必须传入数组的长度，并且是一个常量，并且不可改变，数组的赋值都是值传递，所以一般情况会就比较耗费内存。</li>
<li>slice是通过指针引用底层数组，是对数组一个连续片段的引用，这个片段可以是全部的数组，也可以是其中的一个片段，slice自身是一个结构体，切片的长度可以改变。切片在进行append时，未超过切片的容量，进行浅拷贝（传递引用），超过容量，进行扩容的时候才会执行深拷贝（生成一个新的内存空间，不共享。）</li>
</ol>
<h2 id="通道是什么"><a href="#通道是什么" class="headerlink" title="通道是什么"></a>通道是什么</h2><p>通道是go中的一个通信方式，提供goroutine进行通信，可以为并发的两个实体之间提供通信通道，而不是共享内存的方式。<br>通道分为无缓冲通道和有缓冲通道:</p>
<ul>
<li>对于无缓冲通道，接收方从通道接收东西的时候，如果通道中没有消息，则接收方进入阻塞，直到通道中有消息。对于发送方，直到接收方收到消息之后，才能继续给通道发送消息。</li>
<li>对于有缓冲通道，指的是在通道中可以缓冲指定数量的数据，直到数据填满，发送方阻塞，直到接收方接收，采用了环形数组的方式进行存储。</li>
</ul>
<p>通道在Go中的代码定义:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> hchan <span class="keyword">struct</span> &#123;</span><br><span class="line">  qcount   <span class="type">uint</span>           <span class="comment">// 当前队列中剩余元素个数</span></span><br><span class="line">  dataqsiz <span class="type">uint</span>           <span class="comment">// 环形队列长度，即可以存放的元素个数</span></span><br><span class="line">  buf      unsafe.Pointer <span class="comment">// 环形队列指针</span></span><br><span class="line">  elemsize <span class="type">uint16</span>         <span class="comment">// 每个元素的大小</span></span><br><span class="line">  closed   <span class="type">uint32</span>            <span class="comment">// 标识关闭状态</span></span><br><span class="line">  elemtype *_type         <span class="comment">// 元素类型</span></span><br><span class="line">  sendx    <span class="type">uint</span>           <span class="comment">// 队列下标，指示元素写入时存放到队列中的位置</span></span><br><span class="line">  recvx    <span class="type">uint</span>           <span class="comment">// 队列下标，指示元素从队列的该位置读出</span></span><br><span class="line">  recvq    waitq          <span class="comment">// 等待读消息的goroutine队列</span></span><br><span class="line">  sendq    waitq          <span class="comment">// 等待写消息的goroutine队列</span></span><br><span class="line">  lock mutex              <span class="comment">// 互斥锁，chan不允许并发读写</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通道内部维护一个环形队列，队列的长度是在用户创建的时候指定的。</p>
<ul>
<li>sendx代表写入时的位置</li>
<li>recvx代表读数据时的位置</li>
<li>chan内部还维护了两个等待队列</li>
<li>一个等待读消息的groutine队列</li>
<li>一个等待写消息的groutine队列</li>
<li>一般情况下，recvq和sendq至少有一个为空；一个例外(同一个groutine使用select向channel一边写数据，一边读数据)</li>
</ul>
<p>注意：</p>
<ul>
<li> channel关闭之后任然可以读，如果channel中仍然有未读取的数据，则仍然可以读取到，没有数据会返回0。</li>
<li>关闭一个未初始化的channel会产生panic。</li>
<li>重复关闭同一个channel会产生painc。</li>
<li>从已经关闭的channel中读取消息不会产生painc，且能读出channel中还未被读取的消息，如果消息已经读出，则返回0值；(有缓冲无缓冲都是)。</li>
<li>关闭的channel中读取消息永远不会阻塞，并且会返回一个为false的ok-idiom。</li>
</ul>
<h2 id="map的底层实现"><a href="#map的底层实现" class="headerlink" title="map的底层实现"></a>map的底层实现</h2><p>golang的map是hasmap，使用数组+链表的形式 实现的，使用拉链法消除hash冲突。<br>map类型的变量默认初始值为nil，需要使用make()函数来分配内存。语法为：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">map</span>[keyType]ValueType</span><br><span class="line"><span class="built_in">make</span>(<span class="keyword">map</span>[KeyType]ValueType, [<span class="built_in">cap</span>])</span><br></pre></td></tr></table></figure>
<p>golang的map有两种重要的结构：hmap，bmap，主要就是hmap中包含bmap的一个指针。<br>存储时key不能重复，如果重复则覆盖value，通过key进行hash运算（可以简单的理解为把key转化为一个整数）然后对数组的长度取余,得到key存储在数组的哪个下标位置，咱以后将key和value组装成一个结构体，放入下标的位置。</p>
<h3 id="1-关于hash冲突"><a href="#1-关于hash冲突" class="headerlink" title="1. 关于hash冲突"></a>1. 关于hash冲突</h3><p>数组一个下标只能存储一个元素，也就是说一个数组下标只能存储一对key，value，hashkey（小明）&#x3D;4占用了下标0的位置，假设我们遇到了另一个key，它的hashkey(xiaowang)也是4，这就是hash冲突（不同的key经过hash之后得到的值一样）那么key&#x3D;xiaowang怎么存储？</p>
<ul>
<li><p>开放定址法：当我们存储一个key，value时，发现下标已经被占了，那么我们再这个数组中重新找一个没被占用的存储这个冲突的key，那么没有被占用的有很多，找哪个呢？常见的有线性探测法，线性补偿探测法、随机探测法。</p>
</li>
<li><p>线性探测：按照顺序来，从冲突的下标开始往后探测，到达数组末尾时，从数组开始探测，直到找到一个空位置存储这个key，当数组找不到的情况下会扩容（当数组快满的时候就会扩容了）；<br>如下图：首先存储key&#x3D;xiaoming在下标0处，当存储key&#x3D;xiaowang时，hash冲突了，按照线性探测，存储在下标1处，（红色的线是冲突或者下标已经被占用了） 再者key&#x3D;xiaozhao存储在下标4处，当存储key&#x3D;xiaoliu是，hash冲突了，按照线性探测，从头开始，存储在下标2处 （黄色的是冲突或者下标已经被占用了）</p>
<img data-src="/2021/02/01/technology/golang/go_basic/image_1.png" class="" title="图1">
</li>
<li><p>拉链法：拉链简单理解为链表，当key的hash冲突的时候，我们在冲突位置的元素上形成一个链表，通过指针相互连接，当查找时，发现key冲突，顺着链表一直往下找，直到链表的尾结点，找不到则返回空；<br>如下图描述：</p>
<img data-src="/2021/02/01/technology/golang/go_basic/image_2.png" class="" title="图2">
<p>开放定址和拉链的优缺点：</p>
<ul>
<li>拉链比线性探测处理简单</li>
<li>线性探测查找会比拉链更消耗时间</li>
<li>线性探测会比拉链更容易导致扩容，而拉链不会</li>
<li>拉链存储了指针，所以空间上会比线性探测占用多一点</li>
<li>拉链是动态申请存储空间的，所以更适合链长不确定的。</li>
</ul>
</li>
</ul>
<h3 id="2-HashMap怎么扩容"><a href="#2-HashMap怎么扩容" class="headerlink" title="2. HashMap怎么扩容"></a>2. HashMap怎么扩容</h3><p>首先需要知道哈希表的存储过程，当有新的数据进行存储的时候，需要根据key计算出它的哈希值h，假设哈希表的 容量是n，那么键值对就会放在h%n个位置中，如果该位置已经有了键值对，会分局开放寻址法或者拉链法解决冲突；<br>哈希表的扩容会创建原来的两倍容量，因此即使key的哈希值不变，求余结果也会改变，因此所有的键值对存放的位置都会发生改变，此时需要重新哈希。扩容的时候需要分配一个新的数组，新数组是老数组的2倍长，然后遍历旧的哈希，重新分配到新的结果中。</p>
<h2 id="Go中的interface关键字"><a href="#Go中的interface关键字" class="headerlink" title="Go中的interface关键字"></a>Go中的interface关键字</h2><ul>
<li>interface是方法声明的集合</li>
<li>任何类型的对象实现在interface接口中声明的全部方法，则表明这个类型实现了接口</li>
<li>interface可以作为一种数据类型，实现了该接口的任何对象，都可以给对应的接口类型变量赋值</li>
<li>interface可以被任意对象实现，一个类型&#x2F;对象也可以实现多个(interface)接口</li>
<li>继承和多态的特点，在golang的语法中对多态的特点体现从语法上不是很明显</li>
<li>父类是子类的私有内部类(组合)</li>
<li>发生多态的几个要素：（满足这三个条件，就可以产生多态的效果，父类可以调用子类的具体方法）</li>
<li>有interface接口，并且有接口定义的方法（可以看做一个类型，父类）</li>
<li>有子类去重写interface的接口</li>
<li>有父类指针指向子类的具体对象</li>
</ul>
<h2 id="GMP并发模型："><a href="#GMP并发模型：" class="headerlink" title="GMP并发模型："></a>GMP并发模型：</h2><ul>
<li>G代表goroutine,占用内存更小（几kb），能在有限的内存空间支持更多的并发,调度灵活度更高（runtime调度）</li>
<li>M代表操作系统线程，负责执行 Goroutine</li>
<li>P代表逻辑处理器，负责调度 Goroutine</li>
<li>包含了运行goroutine的资源processor处理</li>
<li>可以运行的G队列<br>在Go中线程是运行goroutine的实体，调度器（runtime）的功能是把可运行的    goroutine分配到工作线程上。<br>Goroutine调度器和OS调度器是通过M结合起来的，每个M都代表了1个内核线程，OS调度器负责把内核线程分配到CPU执行。<img data-src="/2021/02/01/technology/golang/go_basic/image_3.png" class="" title="图3"></li>
</ul>
<h3 id="1-GMP-模型的优势"><a href="#1-GMP-模型的优势" class="headerlink" title="1. GMP 模型的优势"></a>1. GMP 模型的优势</h3><ul>
<li><strong>高效利用 CPU</strong>：通过多 P 和多 M 的绑定，充分利用多核 CPU 的计算能力。</li>
<li><strong>低延迟</strong>：Goroutine 的调度由 Go 运行时负责，避免了操作系统线程切换的开销。</li>
<li><strong>高并发</strong>：Goroutine 的轻量级特性使得 Go 程序可以轻松创建成千上万的并发任务。<br>以下是一个简单的 Go 程序，展示了 Goroutine 的创建和调度：<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">worker</span><span class="params">(id <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;Worker %d: %d\n&quot;</span>, id, i)</span><br><span class="line">		time.Sleep(time.Second)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">		<span class="keyword">go</span> worker(i)</span><br><span class="line">	&#125;</span><br><span class="line">	time.Sleep(<span class="number">5</span> * time.Second) <span class="comment">// 等待所有 Goroutine 执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="GO的GC垃圾回收机制"><a href="#GO的GC垃圾回收机制" class="headerlink" title="GO的GC垃圾回收机制"></a>GO的GC垃圾回收机制</h2><p>三色标记清楚法：</p>
<ul>
<li>初始化所有的对象为白色；</li>
<li>从root根出发扫描所有的根对象，将他们引用的对象标记为灰色；</li>
<li>这里的根对象是程序运行到当前时刻的栈和全局数据区域；</li>
<li>分析灰色对象是否引用了其他的对象，如果没有引用其他的对象，则将该灰色标记为黑色，如果有引用，则将它变为黑色的同时将引用对象标记为灰色；</li>
<li>重复步骤三，直到灰色对象队列为空，此时白色的对象是垃圾，进行回收。</li>
</ul>
<h2 id="Context关键字"><a href="#Context关键字" class="headerlink" title="Context关键字"></a>Context关键字</h2><p>Go1.7加入了一个新的标准库context，它定义了Context类型，专门用来简化 对于处理单个请求的多个 goroutine 之间与请求域的数据、取消信号、截止时间等相关操作，这些操作可能涉及多个 API 调用。<br>对服务器传入的请求应该创建上下文，而对服务器的传出调用应该接受上下文。它们之间的函数调用链必须传递上下文，或者可以使用WithCancel(获得数据通知关闭)、(获得数据定时关闭)WithDeadline、(超时关闭)WithTimeout或(传递KV)WithValue创建的派生上下文。当一个上下文被取消时，它派生的所有上下文也被取消。<br>context.Background()返回的是全局的上下文根（我在文章中多次提到），context.TODO()返回的是空的上下文（表明应用的不确定性）</p>
<h2 id="GO内存分配与逃逸分析"><a href="#GO内存分配与逃逸分析" class="headerlink" title="GO内存分配与逃逸分析"></a>GO内存分配与逃逸分析</h2><ul>
<li>逃逸分析的好处是为了减少gc的压力,不逃逸的对象分配到栈上,当函数返回释放即可,不需要gc标记删除</li>
<li>逃逸分析完成之后可以确定哪些变量可以分配在栈上,栈的分配比堆快,性能好(逃逸变量分配到堆,不逃逸变量分配到栈)</li>
<li>同步消除,如果你定义的对象的方法上有同步锁,在运行时,却只有一个线程在访问,此时逃逸分析后的机器码会去掉同步锁运行<br>总结:</li>
<li>栈上分配内存比在堆中分配内存有更高的效率</li>
<li>栈上分配的内存不需要GC处理</li>
<li>堆上分配的内存使用完毕会交给GC处理</li>
<li>逃逸分析的目的是决定分配地址是栈还是堆</li>
<li>逃逸分析在编译阶段完成</li>
</ul>
<h3 id="1-函数传递指针真的比传值效率高吗"><a href="#1-函数传递指针真的比传值效率高吗" class="headerlink" title="1. 函数传递指针真的比传值效率高吗?"></a>1. 函数传递指针真的比传值效率高吗?</h3><ul>
<li>传递指针可以减少底层值拷贝,可以提高效率,但是如果拷贝数据量小,由于指针传递会产生逃逸;</li>
<li>可能会使用堆,也可能会增加GC的负担,所以传递指针不一定是高效的;<br><strong>栈</strong> :函数内存申请临时变量,并不会作为返回值返回,它就会被编译器申请到栈中<br>在函数中申请一个新对象,如果在栈中,函数执行结束会自动将内存回收;<br><strong>申请到栈内存好处</strong>:  函数返回直接释放,不会引起垃圾回收,对性能没有影响.<br><strong>堆</strong>:    函数申请内存之后,作为返回值返回了,编译器会默认变量之后还会被使用,<br>当函数返回之后并不会将内存归还,那么他就会被申请到堆中.<br>如果分配到堆中,则函数执行结束之后交给GC处理;<br><strong>申请到堆的内存</strong>  :  会引起垃圾回收,如果这个过程(特指垃圾回收不断被触发)过高频次就会导致gc压力过大,性能变低。<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">F</span><span class="params">()</span></span> []<span class="type">int</span>&#123;</span><br><span class="line">    a := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>, <span class="number">20</span>)</span><br><span class="line">    <span class="keyword">return</span> a</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">F</span><span class="params">()</span></span> &#123;</span><br><span class="line">    a := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>, <span class="number">20</span>)     <span class="comment">// 栈 空间小</span></span><br><span class="line">    b := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>, <span class="number">20000</span>) <span class="comment">// 堆 空间过大</span></span><br><span class="line"></span><br><span class="line">    l := <span class="number">20</span></span><br><span class="line">    c := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>, l) <span class="comment">// 堆 动态分配不定空间,也会在堆</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="2-什么是逃逸分析，有哪些场景"><a href="#2-什么是逃逸分析，有哪些场景" class="headerlink" title="2. 什么是逃逸分析，有哪些场景"></a>2. 什么是逃逸分析，有哪些场景</h3><p>逃逸分析指的是由编译器决定内存分配的位置,不需要开发者指定。</p>
<h3 id="1-逃逸场景-什么时候才会被分配到堆中"><a href="#1-逃逸场景-什么时候才会被分配到堆中" class="headerlink" title="1.逃逸场景(什么时候才会被分配到堆中)"></a>1.逃逸场景(什么时候才会被分配到堆中)</h3><ul>
<li>指针逃逸 : go可以返回局部变量指针,典型的变量逃逸案例</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="type">string</span></span><br><span class="line">    Age <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">StudentRegister</span><span class="params">(name <span class="type">string</span>,age <span class="type">int</span>)</span></span>*Student  &#123;</span><br><span class="line">    s :=<span class="built_in">new</span>(Student) <span class="comment">//局部变量s逃逸到堆</span></span><br><span class="line">    s.Name = name</span><br><span class="line">    s.Age = age</span><br><span class="line">    <span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    StudentRegister(<span class="string">&quot;Jin&quot;</span>,<span class="number">19</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>虽然在函数StudentRegister<strong>中内存s 为局部变量</strong>,它的值通过函数返回值返回,s本身为一个指针</p>
<p>它指向发内存地址不会是对,而是栈,这是典型的逃逸案例</p>
<p>终端执行: go build -gcflags &#x3D; - m</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">C:\Users\Administrator\<span class="keyword">go</span>\src\内存逃逸分析&gt;<span class="keyword">go</span> build -gcflags=-m</span><br><span class="line"># 内存逃逸分析</span><br><span class="line">.\<span class="number">1.</span>指针逃逸.<span class="keyword">go</span>:<span class="number">8</span>:<span class="number">6</span>: can inline StudentRegister</span><br><span class="line">.\<span class="number">1.</span>指针逃逸.<span class="keyword">go</span>:<span class="number">15</span>:<span class="number">6</span>: can inline main</span><br><span class="line">.\<span class="number">1.</span>指针逃逸.<span class="keyword">go</span>:<span class="number">16</span>:<span class="number">17</span>: inlining call to StudentRegister</span><br><span class="line">.\<span class="number">1.</span>指针逃逸.<span class="keyword">go</span>:<span class="number">8</span>:<span class="number">22</span>: leaking param: name</span><br><span class="line">.\<span class="number">1.</span>指针逃逸.<span class="keyword">go</span>:<span class="number">9</span>:<span class="number">9</span>: <span class="built_in">new</span>(Student) escapes to heap  <span class="comment">//显示指针逃逸</span></span><br><span class="line">.\<span class="number">1.</span>指针逃逸.<span class="keyword">go</span>:<span class="number">16</span>:<span class="number">17</span>: <span class="built_in">new</span>(Student) does not escape</span><br></pre></td></tr></table></figure>

<ul>
<li>栈空间不足逃逸(空间开辟过大)</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Slice</span><span class="params">()</span></span> &#123;</span><br><span class="line">    s := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">10000</span>, <span class="number">10000</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> index, _ := <span class="keyword">range</span> s &#123;</span><br><span class="line">        s[index] = index</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    Slice()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//当切片长度扩大到100000时会逃逸</span></span><br><span class="line"><span class="comment">//实际上当栈空间不足以存放当前对象或者无法判断当前切片长度时会将对象分配到堆中</span></span><br><span class="line"></span><br><span class="line">C:\Users\Administrator\<span class="keyword">go</span>\src\内存逃逸分析&gt;<span class="keyword">go</span> build -gcflags=-m</span><br><span class="line"># 内存逃逸分析</span><br><span class="line">.\<span class="number">1.</span>指针逃逸.<span class="keyword">go</span>:<span class="number">11</span>:<span class="number">6</span>: can inline main</span><br><span class="line">.\<span class="number">1.</span>指针逃逸.<span class="keyword">go</span>:<span class="number">4</span>:<span class="number">11</span>: <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">10000</span>, <span class="number">10000</span>) escapes to heap</span><br></pre></td></tr></table></figure>

<ul>
<li>动态类型逃逸(不确定长度大小)</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    s := <span class="string">&quot;Escape&quot;</span></span><br><span class="line">    fmt.Println(s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">C:\Users\Administrator\<span class="keyword">go</span>\src\内存逃逸分析&gt;<span class="keyword">go</span> build -gcflags=-m</span><br><span class="line"># 内存逃逸分析</span><br><span class="line">.\<span class="number">1.</span>指针逃逸.<span class="keyword">go</span>:<span class="number">7</span>:<span class="number">13</span>: inlining call to fmt.Println</span><br><span class="line">.\<span class="number">1.</span>指针逃逸.<span class="keyword">go</span>:<span class="number">7</span>:<span class="number">13</span>: s escapes to heap</span><br><span class="line">.\<span class="number">1.</span>指针逃逸.<span class="keyword">go</span>:<span class="number">7</span>:<span class="number">13</span>: []<span class="keyword">interface</span> &#123;&#125; literal does not escape</span><br><span class="line">&lt;autogenerated&gt;:<span class="number">1</span>: .this does not escape</span><br><span class="line">&lt;autogenerated&gt;:<span class="number">1</span>: .this does not escape</span><br></pre></td></tr></table></figure>

<ul>
<li>闭包引用对象逃逸</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Fibonacci</span><span class="params">()</span></span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    a, b := <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">int</span> &#123;</span><br><span class="line">        a, b = b, a+b</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    f := Fibonacci()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;Fibonacci: %d\n&quot;</span>, f())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">C:\Users\Administrator\<span class="keyword">go</span>\src\内存逃逸分析&gt;<span class="keyword">go</span> build -gcflags=-m</span><br><span class="line"># 内存逃逸分析</span><br><span class="line">.\<span class="number">1.</span>指针逃逸.<span class="keyword">go</span>:<span class="number">7</span>:<span class="number">9</span>: can inline Fibonacci.func1</span><br><span class="line">.\<span class="number">1.</span>指针逃逸.<span class="keyword">go</span>:<span class="number">17</span>:<span class="number">13</span>: inlining call to fmt.Printf</span><br><span class="line">.\<span class="number">1.</span>指针逃逸.<span class="keyword">go</span>:<span class="number">6</span>:<span class="number">2</span>: moved to heap: a</span><br><span class="line">.\<span class="number">1.</span>指针逃逸.<span class="keyword">go</span>:<span class="number">6</span>:<span class="number">5</span>: moved to heap: b</span><br><span class="line">.\<span class="number">1.</span>指针逃逸.<span class="keyword">go</span>:<span class="number">7</span>:<span class="number">9</span>: <span class="function"><span class="keyword">func</span> <span class="title">literal</span> <span class="title">escapes</span> <span class="title">to</span> <span class="title">heap</span></span></span><br><span class="line">.\<span class="number">1.</span>指针逃逸.<span class="keyword">go</span>:<span class="number">17</span>:<span class="number">34</span>: f() escapes to heap</span><br><span class="line">.\<span class="number">1.</span>指针逃逸.<span class="keyword">go</span>:<span class="number">17</span>:<span class="number">13</span>: []<span class="keyword">interface</span> &#123;&#125; literal does not escape</span><br><span class="line">&lt;autogenerated&gt;:<span class="number">1</span>: .this does not escape</span><br><span class="line">&lt;autogenerated&gt;:<span class="number">1</span>: .this does not escape</span><br></pre></td></tr></table></figure>

<h2 id="runtime机制是什么"><a href="#runtime机制是什么" class="headerlink" title="runtime机制是什么"></a>runtime机制是什么</h2><p>go 语言的可执行文件已经包含了 golang 的 runtime，它为用户的 go 程序提供协程调度、内存分配、垃圾回收等功能.此外还会与系统内核进行交互，从而真正的利用好 CPU 等资源。</p>
<ul>
<li><strong>Gosched</strong>：让当前线程让出 <code>cpu</code> 以让其它线程运行,它不会挂起当前线程，因此当前线程未来会继续执行</li>
<li><strong>NumCPU</strong>：返回当前系统的 <code>CPU</code> 核数量</li>
<li><strong>GOMAXPROCS</strong>：设置最大的可同时使用的 <code>CPU</code> 核数</li>
<li><strong>Goexit</strong>：退出当前 <code>goroutine</code>(但是<code>defer</code>语句会照常执行)</li>
<li><strong>NumGoroutine</strong>：返回正在执行和排队的任务总数</li>
<li><strong>GOOS</strong>：目标操作系统</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">fmt.Println(<span class="string">&quot;cpus:&quot;</span>, runtime.NumCPU())</span><br><span class="line">fmt.Println(<span class="string">&quot;goroot:&quot;</span>, runtime.GOROOT())</span><br><span class="line">fmt.Println(<span class="string">&quot;archive:&quot;</span>, runtime.GOOS)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>底层原理</tag>
        <tag>面试题</tag>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title>goroutine通信方式</title>
    <url>/2021/02/03/technology/golang/goroutine_method/</url>
    <content><![CDATA[<p>Goroutine 之间常用的通信方式有：</p>
<ul>
<li><p>全局变量</p>
</li>
<li><p>channel</p>
</li>
<li><p>context 上下文</p>
</li>
</ul>
<h3 id="sync-WaitGroup"><a href="#sync-WaitGroup" class="headerlink" title="sync.WaitGroup"></a>sync.WaitGroup</h3><p>如果只是单纯的等待所有任务完成，可以使用 <code>sync.WaitGroup</code>：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">   <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</span><br><span class="line">       wg.Add(<span class="number">1</span>)</span><br><span class="line">       <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">           fmt.Println(<span class="string">&quot;func run&quot;</span>)</span><br><span class="line">           time.Sleep(time.Second)</span><br><span class="line">           wg.Done()</span><br><span class="line">       &#125;()</span><br><span class="line">   &#125;</span><br><span class="line">   wg.Wait()</span><br><span class="line">   fmt.Println(<span class="string">&quot;main done&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h3><p>简单，但是传递的数据只能一写多读。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> stop <span class="type">bool</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">go</span> f()</span><br><span class="line">    time.Sleep(<span class="number">2</span> * time.Second)</span><br><span class="line">    stop = <span class="literal">false</span></span><br><span class="line">    time.Sleep(<span class="number">2</span> * time.Second)</span><br><span class="line">    fmt.Println(<span class="string">&quot;main done&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> stop &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;still run&quot;</span>)</span><br><span class="line">        time.Sleep(time.Second)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="channel"><a href="#channel" class="headerlink" title="channel"></a>channel</h3><p>CSP 并发编程模型（Communicating Sequential Process）。channel 在 Golang 中是核心类型。</p>
<p>Golang 的 select 机制在语言层面实现了类似 Linux 的 select 功能，可以监听多个文件描述符的读写事件，能够在事件发生时主动通知应用程序处理。 Golang 的 select 还可以设置 default，在监听的事件全部阻塞时执行。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    stop := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">bool</span>)</span><br><span class="line">    <span class="keyword">go</span> f(stop)</span><br><span class="line">    time.Sleep(<span class="number">2</span> * time.Second)</span><br><span class="line">    stop&lt;-<span class="literal">true</span></span><br><span class="line">    time.Sleep(<span class="number">2</span> * time.Second)</span><br><span class="line">    fmt.Println(<span class="string">&quot;main done&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">(stop <span class="keyword">chan</span> <span class="type">bool</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">            <span class="keyword">case</span> &lt;-stop:</span><br><span class="line">                fmt.Println(<span class="string">&quot;done&quot;</span>)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                fmt.Println(<span class="string">&quot;still run&quot;</span>)</span><br><span class="line">                time.Sleep(time.Second)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="context-上下文"><a href="#context-上下文" class="headerlink" title="context 上下文"></a>context 上下文</h3><p>Golang 的上下文是树状结构，通过 context.Background() 方法可以拿到上下文的根节点。常用方法有：</p>
<ul>
<li><p>func WithCancel(parent Context) (ctx Context, cancel CancelFunc)</p>
</li>
<li><p>func WithDeadline(parent Context, deadline time.Time) (Context, CancelFunc)</p>
</li>
<li><p>func WithTimeout(parent Context, timeout time.Duration) (Context, CancelFunc)</p>
</li>
<li><p>func WithValue(parent Context, key, val interface{}) Context</p>
</li>
</ul>
<h3 id="WithCancel"><a href="#WithCancel" class="headerlink" title="WithCancel"></a>WithCancel</h3><p>子上下文可以调用 Done 方法（返回 channel，可以通过 select 读取）检测是否有父节点调用 cancel。上层节点的 cancel 调用会沿着上下文树的边向下通知到每一个子节点。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ctx, myCancel := context.WithCancel(context.Background())</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> &#123;</span><br><span class="line">            <span class="keyword">select</span> &#123;</span><br><span class="line">                <span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">                    fmt.Println(<span class="string">&quot;ctx Done&quot;</span>)</span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    fmt.Println(<span class="string">&quot;goroutine continue&quot;</span>)</span><br><span class="line">                    time.Sleep(time.Second)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    time.Sleep(time.Second * <span class="number">2</span>)</span><br><span class="line">    myCancel()</span><br><span class="line">    time.Sleep(time.Second)</span><br><span class="line">    fmt.Println(<span class="string">&quot;main done&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="WithValue"><a href="#WithValue" class="headerlink" title="WithValue"></a>WithValue</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> favContextKey <span class="type">string</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ctx := context.WithValue(context.Background(), favContextKey(<span class="string">&quot;hello&quot;</span>), <span class="string">&quot;Go&quot;</span>)</span><br><span class="line">    f := <span class="function"><span class="keyword">func</span><span class="params">(ctx context.Context, k favContextKey)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> v := ctx.Value(k); v != <span class="literal">nil</span> &#123;</span><br><span class="line">            fmt.Println(<span class="string">&quot;found value:&quot;</span>, v)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        fmt.Println(<span class="string">&quot;value not found:&quot;</span>, k)</span><br><span class="line">    &#125;</span><br><span class="line">    f(ctx, favContextKey(<span class="string">&quot;hello&quot;</span>))</span><br><span class="line">    f(ctx, favContextKey(<span class="string">&quot;color&quot;</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>




]]></content>
      <categories>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>面试题</tag>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title>Go语言反射reflect</title>
    <url>/2021/02/03/technology/golang/go_reflect/</url>
    <content><![CDATA[<p><strong>反射指的是在程序运行期间对程序本身进行访问和修改的能力.</strong></p>
<p>不支持反射的语言:</p>
<blockquote>
<p>程序在编译时,变量转换为内存地址,变量名不会被编译器写入到可执行部分.在运行程序时,程序无法获取自身的信息.</p>
</blockquote>
<p>支持反射的语言:</p>
<blockquote>
<p>可以在程序编译期间将变量的反射信息,比如字段名称 , 类型信息 , 结构体信息等整合到可执行文件中,并给程序提供接口访问反射信息,这样就可以在程序运行期间获取类型的反射信息,并且有能力修改它们.</p>
</blockquote>
<p><strong>Go程序在运行期间使用reflect包访问程序的反射信息</strong></p>
<p>reflct包实现了运行时反射,允许程序操作任意类型的对象.典型的用法是静态类型interface{}保存一个值,通过TypeOf获取其动态类型信息,该函数返回一个Type类型值,调用ValueOf函数返回一个Value类型值,该值代表运行时的数据.Zero接受一个一个Type类型参数,并返回一个代表该类型零值的Value类型值.</p>
<p>Go程序的反射系统无法获取到一个可执行文件空间中或者是一个包中的所有类型信息,需要配合使用标准库中对应的词法,语法解析器和抽象语法树(AST)对源码进行扫描后获得这些信息.</p>
<h2 id="通过反射获取类型信息"><a href="#通过反射获取类型信息" class="headerlink" title="通过反射获取类型信息"></a>通过反射获取类型信息</h2><p>通过反射获取类型信息:(reflect.TypeOf()和reflect.Type)</p>
<p>使用reflect.TypeOf()函数可以获得任意值的类型对象eflect.Type,程序通过类型对象可以访问任意值的类型信息.</p>
<p><strong>例子:</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;reflect&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="type">string</span></span><br><span class="line">    Age  <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> stu Student</span><br><span class="line">    typeOfStu := reflect.TypeOf(stu)</span><br><span class="line">    fmt.Println(typeOfStu.Name(), typeOfStu.Kind())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>代码输出:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">Student <span class="keyword">struct</span></span><br></pre></td></tr></table></figure>


<p>理解反射的类型( Type )和种类( Kind )</p>
<p>在使用反射的时候,需要首先理解类型（Type）和种类（Kind）的区别。编程中，使用最多的是类型，但在反射中，当需要区分一个大品种的类型时，就会用到种类（Kind）。例如，需要统一判断类型中的指针时，使用种类（Kind）信息就较为方便。</p>
<h2 id="反射种类-kind-的定义"><a href="#反射种类-kind-的定义" class="headerlink" title="反射种类(kind)的定义"></a>反射种类(kind)的定义</h2><p>Go 程序中的类型（Type）指的是系统原生数据类型，如 int、string、bool、float32 等类型，以及使用 type 关键字定义的类型，这些类型的名称就是其类型本身的名称。例如使用 type A struct{} 定义结构体时，A 就是 struct{} 的类型。</p>
<p>种类（Kind）指的是对象归属的品种，在 reflect 包中有如下定义：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Kind <span class="type">uint</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    Invalid Kind = <span class="literal">iota</span>  <span class="comment">// 非法类型</span></span><br><span class="line">    Bool                                 <span class="comment">// 布尔型</span></span><br><span class="line">    Int                                <span class="comment">// 有符号整型</span></span><br><span class="line">    Int8                                 <span class="comment">// 有符号8位整型</span></span><br><span class="line">    Int16                                <span class="comment">// 有符号16位整型</span></span><br><span class="line">    Int32                                <span class="comment">// 有符号32位整型</span></span><br><span class="line">    Int64                                <span class="comment">// 有符号64位整型</span></span><br><span class="line">    Uint                                 <span class="comment">// 无符号整型</span></span><br><span class="line">    Uint8                                <span class="comment">// 无符号8位整型</span></span><br><span class="line">    Uint16                           <span class="comment">// 无符号16位整型</span></span><br><span class="line">    Uint32                           <span class="comment">// 无符号32位整型</span></span><br><span class="line">    Uint64                           <span class="comment">// 无符号64位整型</span></span><br><span class="line">    Uintptr                          <span class="comment">// 指针</span></span><br><span class="line">    Float32                          <span class="comment">// 单精度浮点数</span></span><br><span class="line">    Float64                          <span class="comment">// 双精度浮点数</span></span><br><span class="line">    Complex64                        <span class="comment">// 32位复数类型</span></span><br><span class="line">    Complex128                   <span class="comment">// 64位复数类型</span></span><br><span class="line">    Array                                <span class="comment">// 数组</span></span><br><span class="line">    Chan                                 <span class="comment">// 通道</span></span><br><span class="line">    Func                                 <span class="comment">// 函数</span></span><br><span class="line">    Interface                        <span class="comment">// 接口</span></span><br><span class="line">    Map                                <span class="comment">// 映射</span></span><br><span class="line">    Ptr                                <span class="comment">// 指针</span></span><br><span class="line">    Slice                                <span class="comment">// 切片</span></span><br><span class="line">    String                           <span class="comment">// 字符串</span></span><br><span class="line">    Struct                           <span class="comment">// 结构体</span></span><br><span class="line">    UnsafePointer                <span class="comment">// 底层指针</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>


<p>Map、Slice、Chan 属于引用类型，使用起来类似于指针，但是在种类常量定义中仍然属于独立的种类，不属于 Ptr。</p>
<p>type A struct{} 定义的结构体属于 Struct 种类，*A 属于 Ptr。</p>
<h2 id="从类型对象中获取类型名称和种类的例子"><a href="#从类型对象中获取类型名称和种类的例子" class="headerlink" title="从类型对象中获取类型名称和种类的例子:"></a>从类型对象中获取类型名称和种类的例子:</h2><p>Go 语言中的类型名称对应的反射获取方法是 reflect.Type 中的 Name() 方法，返回表示类型名称的字符串。</p>
<p>类型归属的种类（Kind）使用的是 reflect.Type 中的 Kind() 方法，返回 reflect.Kind 类型的常量。</p>
<p>例子:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;reflect&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="comment">//定义一个Enum类型</span></span><br><span class="line"><span class="keyword">type</span> Enum <span class="type">int</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    Zero Enum = <span class="number">0</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="type">string</span></span><br><span class="line">    Age  <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">//定义一个Student类型的变量</span></span><br><span class="line">    <span class="keyword">var</span> stu Student</span><br><span class="line">    <span class="comment">//获取结构体实例的反射类型对象</span></span><br><span class="line">    typeOfStu := reflect.TypeOf(stu)</span><br><span class="line">    <span class="comment">//显示反射类型对象的名称和种类</span></span><br><span class="line">    fmt.Println(typeOfStu.Name(), typeOfStu.Kind())</span><br><span class="line">    <span class="comment">//获取Zero常量的反射类型对象</span></span><br><span class="line">    typeOfZero := reflect.TypeOf(Zero)</span><br><span class="line">    <span class="comment">//显示反射类型对象的名称和种类</span></span><br><span class="line">    fmt.Println(typeOfZero.Name(), typeOfZero.Kind())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//代码输出如下:</span></span><br><span class="line"></span><br><span class="line">Student <span class="keyword">struct</span></span><br><span class="line">Enum <span class="type">int</span></span><br></pre></td></tr></table></figure>


<h3 id="reflect-Elem-通过反射获取指针指向的元素类型"><a href="#reflect-Elem-通过反射获取指针指向的元素类型" class="headerlink" title="reflect.Elem() - 通过反射获取指针指向的元素类型"></a>reflect.Elem() - 通过反射获取指针指向的元素类型</h3><p>通过反射获取指针指向的元素类型：reflect.Elem()</p>
<p>Go 程序中对指针获取反射对象时，可以通过 reflect.Elem() 方法获取这个指针指向的元素类型。这个获取过程被称为取元素，等效于对指针类型变量做了一个<code>*</code>操作，代码如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;reflect&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line"></span><br><span class="line">    Name <span class="type">string</span></span><br><span class="line">    Age  <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">//定义一个Student类型的指针变量</span></span><br><span class="line">    <span class="keyword">var</span> stu = &amp;Student&#123;Name:<span class="string">&quot;kitty&quot;</span>, Age: <span class="number">20</span>&#125;</span><br><span class="line">    <span class="comment">//获取结构体实例的反射类型对象</span></span><br><span class="line">    typeOfStu := reflect.TypeOf(stu)</span><br><span class="line">    <span class="comment">//显示反射类型对象的名称和种类</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;name: &#x27;%v&#x27;, kind: &#x27;%v&#x27;\n&quot;</span>, typeOfStu.Name(), typeOfStu.Kind())</span><br><span class="line">    <span class="comment">//取类型的元素</span></span><br><span class="line">    typeOfStu = typeOfStu.Elem()</span><br><span class="line">    <span class="comment">//显示反射类型对象的名称和种类</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;element name: &#x27;%v&#x27;, element kind: &#x27;%v&#x27;\n&quot;</span>, typeOfStu.Name(), typeOfStu.Kind())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//代码输出如下:</span></span><br><span class="line"><span class="comment">//name: &#x27;&#x27;, kind: &#x27;ptr&#x27;</span></span><br><span class="line"><span class="comment">//element name: &#x27;Student&#x27;, element kind: &#x27;struct&#x27;</span></span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>面试题</tag>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title>Go-GPM解析</title>
    <url>/2021/02/03/technology/golang/gpm_explain/</url>
    <content><![CDATA[<h1 id="GPM轻量理解"><a href="#GPM轻量理解" class="headerlink" title="GPM轻量理解"></a>GPM轻量理解</h1><p>GPM是Go语言运行时（runtime）层面的实现，是go语言自己实现的一套调度系统。区别于操作系统调度OS线程。</p>
<ul>
<li><p>1.G很好理解，就是个goroutine，里面除了存放本goroutine信息外 还有与所在P的绑定等信息。</p>
</li>
<li><p>2.P管理着一组goroutine队列，P里面会存储当前goroutine运行的上下文环境（函数指针，堆栈地址及地址边界），P会对自己管理的goroutine队列做一些调度（比如把占用CPU时间较长的goroutine暂停、运行后续的goroutine等等）当自己的队列消费完了就去全局队列里取，如果全局队列里也消费完了会去其他P的队列里抢任务。</p>
</li>
<li><p>3.M（machine）是Go运行时（runtime）对操作系统内核线程的虚拟， M与内核线程一般是一一映射的关系， 一个groutine最终是要放到M上执行的；</p>
</li>
</ul>
<p>P与M一般也是一一对应的。他们关系是： P管理着一组G挂载在M上运行。当一个G长久阻塞在一个M上时，runtime会新建一个M，阻塞G所在的P会把其他的G 挂载在新建的M上。当旧的G阻塞完成或者认为其已经死掉时 回收旧的M。</p>
<p>P的个数是通过runtime.GOMAXPROCS设定（最大256），Go1.5版本之后默认为物理线程数。 在并发量大的时候会增加一些P和M，但不会太多，切换太频繁的话得不偿失。</p>
<p>三者关系：</p>
<ul>
<li><p>每一个运行的M都必须绑定一个P,线程M创建后会去检查并执行G(goroutine)对象</p>
</li>
<li><p>每一个P保存着一个协程G的队列</p>
</li>
<li><p>除了每个P自身保存的G的队列外,调度器还拥有一个全局的G队列</p>
</li>
<li><p>M从队列中提取G,并执行</p>
</li>
<li><p>P的个数就是<code>GOMAXPROCS</code>(最大256),启动时固定的,一般不修改</p>
</li>
<li><p>M的个数和P的个数不一定一样多(会有休眠的M或P不绑定M) (最大10000)</p>
</li>
<li><p>P是用一个全局数组(255)来保存的,并且维护着一个全局的P空闲链表</p>
</li>
</ul>
<p>单从线程调度讲，Go语言相比起其他语言的优势在于OS线程是由OS内核来调度的，goroutine则是由Go运行时（runtime）自己的调度器调度的，这个调度器使用一个称为m:n调度的技术（复用&#x2F;调度m个goroutine到n个OS线程）。 其一大特点是goroutine的调度是在用户态下完成的， 不涉及内核态与用户态之间的频繁切换，包括内存的分配与释放，都是在用户态维护着一块大的内存池， 不直接调用系统的malloc函数（除非内存池需要改变），成本比调度OS线程低很多。 另一方面充分利用了多核的硬件资源，近似的把若干goroutine均分在物理线程上， 再加上本身goroutine的超轻量（默认为2kb），以上种种保证了go调度方面的性能。</p>
]]></content>
      <categories>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>底层原理</tag>
        <tag>面试题</tag>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title>Go高频面试题</title>
    <url>/2021/02/02/technology/golang/interview_issue/</url>
    <content><![CDATA[<h2 id="1-关于select"><a href="#1-关于select" class="headerlink" title="1.关于select"></a>1.关于select</h2><ul>
<li><p>select是Go语言中的一个控制语句，类似于switch，但是select主要用于通道操作（每一个case必须是一个通信操作，要么接收，要么发送）。 </p>
</li>
<li><p>select会随机选择一个可以运行的case；如果没有case可运行，那么将会阻塞，直到有一个case可以运行。</p>
</li>
</ul>
<h2 id="2-变量会怎么分配："><a href="#2-变量会怎么分配：" class="headerlink" title="2.变量会怎么分配："></a>2.变量会怎么分配：</h2><p>变量分配在栈还是堆是由go编译器自己控制的；编译时，会做逃逸分析，当变量作用域没有跑出函数的范围，就放在栈上；反之则必须放在堆上。<a href="/2021/02/03/technology/golang/memory_escape/">Go内存逃逸分析</a></p>
<h2 id="3-GC垃圾回收"><a href="#3-GC垃圾回收" class="headerlink" title="3.GC垃圾回收"></a>3.GC垃圾回收</h2><ul>
<li><p>v1.3：标记清除：整体过程需要启动STW，效率极低。</p>
</li>
<li><p>v1.5：三色标记法：堆空间启动写屏障，栈空间不启动，全部扫描之后，需要重新扫描一次栈(需要STW)，效率普通</p>
</li>
<li><p>v1.8：混合写屏障机制： 栈空间不启动，堆空间启动。整个过程几乎不需要STW，效率较高 <a href="/2021/02/03/technology/golang/gc_recycle/">Go垃圾回收</a></p>
</li>
</ul>
<h2 id="4-协程调度GPM"><a href="#4-协程调度GPM" class="headerlink" title="4.协程调度GPM"></a>4.协程调度GPM</h2><p>G：就是个goroutine（调度系统最基本的单位），里面除了存放本goroutine信息（执行stack信息；状态信息；所在的任务函数信息等）与所在P的绑定等信息。</p>
<p>P：就是process，管理着一组goroutine队列，存储当前goroutine运行的上下文环境。</p>
<p>M：machine，代表着真正的执行计算资源。</p>
<p>P管理着一组G在M上执行。<a href="/2021/02/03/technology/golang/gpm_explain/">GPM轻量理解</a></p>
<ul>
<li><p>每一个运行的M都必须绑定一个P，线程M创建后会检查并执行G对象</p>
</li>
<li><p>每一个P都保存着一个G队列</p>
</li>
<li><p>除了P保存的G队列外，还有一个全局G队列</p>
</li>
<li><p>M从队列中取出G并执行</p>
</li>
<li><p>P的个数就是 GOMAXPROCS(256)，一般不做修改</p>
</li>
<li><p>M的个数和P的个数不一定一样多</p>
</li>
<li><p>P是一个全局数组（255）来保存，并且维护者一个全局的P空闲链表</p>
</li>
</ul>
<h2 id="5-runtime机制"><a href="#5-runtime机制" class="headerlink" title="5.runtime机制"></a>5.runtime机制</h2><p><a href="https://blog.csdn.net/futurewu/article/details/104692651?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522162220408116780262566000%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=162220408116780262566000&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_v2~rank_v29-2-104692651.first_rank_v2_pc_rank_v29&utm_term=golang+%E7%9A%84+runtime+%E6%9C%BA%E5%88%B6&spm=1018.2226.3001.4187">runtime机制</a></p>
<p>runtime负责：管理调度，垃圾回收以及运行环境等。。Go语言的goroutine，channel这些高级功能都需要runtime的支持。</p>
<p>如何运行：用户编译代码后，runtime和编译后的代码会被静态链接起来，形成一个可执行文件。runtime通过接口函数调用来管理goroutine，channel这些高级功能；而且从用户代码调用操作系统的API调用会被runtime拦截处理。</p>
<p>组成：一个重要组成部分是goroutine scheduler ，它负责追踪调度goroutine运行，实际上是从应用程序的process所属的thread pool（线程池）中分配一个thread来执行这个goroutine。因此，每个goroutine只有分配到一个OS thread才能运行。</p>
<h2 id="6-make和new的区别"><a href="#6-make和new的区别" class="headerlink" title="6.make和new的区别"></a>6.make和new的区别</h2><p><a href="https://www.cnblogs.com/ghj1976/archive/2013/02/12/2910384.html">区别</a></p>
<p>make：返回初始化后的值。make是引用类型初始化的方法；常用于slice,map,channle。make(T…)</p>
<p>new：返回指针，即new(T)返回的是*T</p>
<h2 id="7-channel有缓冲和无缓冲"><a href="#7-channel有缓冲和无缓冲" class="headerlink" title="7.channel有缓冲和无缓冲"></a>7.channel有缓冲和无缓冲</h2><p><a href="https://blog.csdn.net/sgsgy5/article/details/82054902?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522162227719016780262526931%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=162227719016780262526931&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-82054902.first_rank_v2_pc_rank_v29&utm_term=%E6%9C%89%E7%BC%93%E5%86%B2channel&spm=1018.2226.3001.4187">有无缓冲</a></p>
<p>无缓冲：channel接收阻数据塞直到读取数据；channel发送阻塞直到数据被接收</p>
<p>有缓冲：当缓冲满时，channel接收数据阻塞；当缓冲空时，channel发送数据阻塞</p>
<p>无缓冲的  就是一个送信人去你家门口送信 ，你不在家 他不走，你一定要接下信，他才会走。</p>
<p>无缓冲保证信能到你手上（同步）</p>
<p>有缓冲的 就是一个送信人去你家仍到你家的信箱 转身就走 ，除非你的信箱满了 他必须等信箱空下来。</p>
<p>有缓冲的 保证 信能进你家的邮箱（非同步）</p>
<h2 id="8-并发方式和退出"><a href="#8-并发方式和退出" class="headerlink" title="8.并发方式和退出"></a>8.并发方式和退出</h2><p>并发：通常使用无缓冲chan来实现goroutine来是实现</p>
<p>退出：使用for-range来退出；使用，ok来退出；使用退出通道来退出</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// for-range是使用频率很高的结构，常用它来遍历数据，**range能够感知channel的关闭，当channel被发送数据的协程关闭时，range就会结束**，接着退出for循环。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    inCh := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(in &lt;-<span class="keyword">chan</span> <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">        <span class="comment">// Using for-range to exit goroutine</span></span><br><span class="line">        <span class="comment">// range has the ability to detect the close/end of a channel</span></span><br><span class="line">        <span class="keyword">for</span> x := <span class="keyword">range</span> in &#123;</span><br><span class="line">            fmt.Printf(<span class="string">&quot;Process %d\n&quot;</span>, x)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;(inCh)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用一个专门的通道，发送退出的信号</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">worker</span><span class="params">(stopCh &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">defer</span> fmt.Println(<span class="string">&quot;worker exit&quot;</span>)</span><br><span class="line">        <span class="comment">// Using stop channel explicit exit</span></span><br><span class="line">        <span class="keyword">for</span> &#123;</span><br><span class="line">            <span class="keyword">select</span> &#123;</span><br><span class="line">            <span class="keyword">case</span> &lt;-stopCh:</span><br><span class="line">                fmt.Println(<span class="string">&quot;Recv stop signal&quot;</span>)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">case</span> &lt;-t.C:</span><br><span class="line">                fmt.Println(<span class="string">&quot;Working .&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="9-interface-技巧"><a href="#9-interface-技巧" class="headerlink" title="9.interface()技巧"></a>9.interface()技巧</h2><ul>
<li>空接口    可以存放任意类型的数据</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    data := <span class="built_in">make</span>([]<span class="keyword">interface</span>&#123;&#125;, <span class="number">3</span>)</span><br><span class="line">    intData := <span class="number">1</span></span><br><span class="line">    stringData := <span class="string">&quot;abc&quot;</span></span><br><span class="line">    boolData := <span class="literal">true</span></span><br><span class="line">    data[<span class="number">0</span>] = intData</span><br><span class="line">    data[<span class="number">1</span>] = stringData</span><br><span class="line">    data[<span class="number">2</span>] = boolData</span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> data &#123;</span><br><span class="line">        fmt.Println(v)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<ul>
<li>接口嵌套</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> ReadWrite <span class="keyword">interface</span> &#123;</span><br><span class="line">    Read(b Buffer) <span class="type">bool</span></span><br><span class="line">    Write(b Buffer) <span class="type">bool</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Lock <span class="keyword">interface</span> &#123;</span><br><span class="line">    Lock()</span><br><span class="line">    Unlock()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> File <span class="keyword">interface</span> &#123;   <span class="comment">// 除了上面两个还有一个额外的close()接口</span></span><br><span class="line">    ReadWrite</span><br><span class="line">    Lock</span><br><span class="line">    Close()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<ul>
<li>类型选择和断言</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> v, ok := varI.(T); ok &#123;  <span class="comment">// 判断是否是自己想要的类型</span></span><br><span class="line">    assertion</span><br><span class="line">    Process(v)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h2 id="10-用信道实现主程等待协程2s-如果超过2s-主程直接结束-不用sleep"><a href="#10-用信道实现主程等待协程2s-如果超过2s-主程直接结束-不用sleep" class="headerlink" title="10.用信道实现主程等待协程2s,如果超过2s,主程直接结束(不用sleep)"></a>10.用信道实现主程等待协程2s,如果超过2s,主程直接结束(不用sleep)</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    start := time.Now()</span><br><span class="line">    wait := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;做点东西&quot;</span>)</span><br><span class="line">        time.Sleep(<span class="number">3</span>* time.Second)</span><br><span class="line">        wait &lt;- <span class="number">2</span></span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="string">&quot;这里是主程序&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> nums := &lt;-wait:    <span class="comment">// 当超过(阻塞)2s后，不会再执行这个条件，直接执行下面的</span></span><br><span class="line">        fmt.Println(nums)</span><br><span class="line">    <span class="keyword">case</span> &lt;-time.After(<span class="number">2</span> * time.Second): </span><br><span class="line">        fmt.Println(<span class="string">&quot;2秒后&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(time.Since(start))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>底层原理</tag>
        <tag>面试题</tag>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title>Go内存逃逸分析</title>
    <url>/2021/02/03/technology/golang/memory_escape/</url>
    <content><![CDATA[<h2 id="1-关于-堆和栈"><a href="#1-关于-堆和栈" class="headerlink" title="1. 关于 堆和栈"></a>1. 关于 堆和栈</h2><p>栈可以简单得理解成一次函数调用内部申请到的内存，它们会随着函数的返回把内存还给系统。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">F</span><span class="params">()</span></span> &#123;</span><br><span class="line">    temp := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>, <span class="number">20</span>)</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>类似于上面代码里面的temp变量，只是内函数内部申请的临时变量，并不会作为返回值返回，它就是被编译器申请到栈里面。 </p>
<p>申请到<strong>栈内存</strong>好处：函数返回直接释放，不会引起垃圾回收，对性能没有影响。</p>
<p>再来看看堆得情况之一如下代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">F</span><span class="params">()</span></span> []<span class="type">int</span>&#123;</span><br><span class="line">    a := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>, <span class="number">20</span>)</span><br><span class="line">    <span class="keyword">return</span> a</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而上面这段代码，申请的代码一模一样，但是申请后作为返回值返回了，编译器会认为变量之后还会被使用，当函数返回之后并不会将其内存归还，那么它就会被申请到 堆 上面了。</p>
<p><strong>申请到堆上面的内存才会引起垃圾回收，如果这个过程（特指垃圾回收不断被触发）过于高频就会导致 gc 压力过大，程序性能出问题。</strong></p>
<p>我们再看看如下几个例子：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">F</span><span class="params">()</span></span> &#123;</span><br><span class="line">    a := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>, <span class="number">20</span>)     <span class="comment">// 栈 空间小</span></span><br><span class="line">    b := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>, <span class="number">20000</span>) <span class="comment">// 堆 空间过大</span></span><br><span class="line"></span><br><span class="line">    l := <span class="number">20</span></span><br><span class="line">    c := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>, l) <span class="comment">// 堆 动态分配不定空间</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>像是 b 这种 即使是临时变量，申请过大也会在堆上面申请。对于 c 编译器对于这种不定长度的申请方式，也会在堆上面申请，即使申请的长度很短。</p>
<h2 id="2-逃逸分析（Escape-analysis）"><a href="#2-逃逸分析（Escape-analysis）" class="headerlink" title="2. 逃逸分析（Escape analysis）"></a>2. 逃逸分析（Escape analysis）</h2><p>逃逸分析指的是由编译器决定内存分配的位置,不需要由程序员指定.</p>
<p>在函数中申请一个新的对象</p>
<ul>
<li><p><strong>如果申请到栈中,则函数执行结束可以自动将内存回收.</strong></p>
</li>
<li><p><strong>如果分配到堆,则函数执行结束就可以交给GC处理.</strong></p>
</li>
</ul>
<h2 id="3-逃逸场景（什么情况才分配到堆中）"><a href="#3-逃逸场景（什么情况才分配到堆中）" class="headerlink" title="3. 逃逸场景（什么情况才分配到堆中）"></a>3. 逃逸场景（什么情况才分配到堆中）</h2><h3 id="3-1-指针逃逸"><a href="#3-1-指针逃逸" class="headerlink" title="3.1 指针逃逸"></a>3.1 指针逃逸</h3><p>Go可以返回局部变量指针，这其实是一个典型的变量逃逸案例，示例代码如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="type">string</span></span><br><span class="line">    Age  <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">StudentRegister</span><span class="params">(name <span class="type">string</span>, age <span class="type">int</span>)</span></span> *Student &#123;</span><br><span class="line">    s := <span class="built_in">new</span>(Student) <span class="comment">//局部变量s逃逸到堆</span></span><br><span class="line"></span><br><span class="line">    s.Name = name</span><br><span class="line">    s.Age = age</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    StudentRegister(<span class="string">&quot;Jim&quot;</span>, <span class="number">18</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>虽然 在函数 StudentRegister() 内部 s 为局部变量，其值通过函数返回值返回，s 本身为一指针，其指向的内存地址不会是栈而是堆，这就是典型的逃逸案例。</p>
<p>终端运行命令查看逃逸分析日志：</p>
<figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="code"><pre><span class="line">go build -gcflags=-m</span><br></pre></td></tr></table></figure>


<img data-src="/2021/02/03/technology/golang/memory_escape/img_1.png" class="" title="image.png">

<p>可见在StudentRegister()函数中，也即代码第9行显示”escapes to heap”，代表该行内存分配发生了逃逸现象。</p>
<h3 id="3-2-栈空间不足逃逸（空间开辟过大）"><a href="#3-2-栈空间不足逃逸（空间开辟过大）" class="headerlink" title="3.2 栈空间不足逃逸（空间开辟过大）"></a>3.2 栈空间不足逃逸（空间开辟过大）</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Slice</span><span class="params">()</span></span> &#123;</span><br><span class="line">    s := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">1000</span>, <span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> index, _ := <span class="keyword">range</span> s &#123;</span><br><span class="line">        s[index] = index</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    Slice()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>上面代码Slice()函数中分配了一个1000个长度的切片，是否逃逸取决于栈空间是否足够大。 直接查看编译提示，如下：</p>
<img data-src="/2021/02/03/technology/golang/memory_escape/img_2.png" class="" title="image.png">

<p>所以只是1000的长度还不足以发生逃逸现象。然后就x10倍吧</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Slice</span><span class="params">()</span></span> &#123;</span><br><span class="line">    s := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">10000</span>, <span class="number">10000</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> index, _ := <span class="keyword">range</span> s &#123;</span><br><span class="line">        s[index] = index</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    Slice()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>分析如下：当切片长度扩大到10000时就会逃逸。实际上当栈空间不足以存放当前对象时或无法判断当前切片长度时会将对象分配到堆中。</p>
<h3 id="3-3-动态类型逃逸（不确定长度大小）"><a href="#3-3-动态类型逃逸（不确定长度大小）" class="headerlink" title="3.3 动态类型逃逸（不确定长度大小）"></a>3.3 动态类型逃逸（不确定长度大小）</h3><p>很多函数参数为interface类型，比如fmt.Println(a …interface{})，编译期间很难确定其参数的具体类型，也能产生逃逸。</p>
<p>如下代码所示：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    s := <span class="string">&quot;Escape&quot;</span></span><br><span class="line">    fmt.Println(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>逃逸分下如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">D:\SourceCode\GoExpert\src&gt;go build -gcflags=-m</span><br><span class="line"># _/D_/SourceCode/GoExpert/src</span><br><span class="line">.\main.go:7: s escapes to heap</span><br><span class="line">.\main.go:7: main ... argument does not escape</span><br></pre></td></tr></table></figure>


<p>又或者像前面提到的例子：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">F</span><span class="params">()</span></span> &#123;</span><br><span class="line">    a := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>, <span class="number">20</span>)     <span class="comment">// 栈 空间小</span></span><br><span class="line">    b := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>, <span class="number">20000</span>) <span class="comment">// 堆 空间过大 逃逸</span></span><br><span class="line"></span><br><span class="line">    l := <span class="number">20</span></span><br><span class="line">    c := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>, l) <span class="comment">// 堆 动态分配不定空间 逃逸</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="3-4-闭包引用对象逃逸"><a href="#3-4-闭包引用对象逃逸" class="headerlink" title="3.4 闭包引用对象逃逸"></a>3.4 闭包引用对象逃逸</h3><p>Fibonacci数列的函数：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Fibonacci</span><span class="params">()</span></span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    a, b := <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">int</span> &#123;</span><br><span class="line">        a, b = b, a+b</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    f := Fibonacci()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;Fibonacci: %d\n&quot;</span>, f())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>输出如下：</p>
<figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="code"><pre><span class="line"> ~/go/src/gitHub/test/pool  go run main.go</span><br><span class="line">Fibonacci: 1</span><br><span class="line">Fibonacci: 1</span><br><span class="line">Fibonacci: 2</span><br><span class="line">Fibonacci: 3</span><br><span class="line">Fibonacci: 5</span><br><span class="line">Fibonacci: 8</span><br><span class="line">Fibonacci: 13</span><br><span class="line">Fibonacci: 21</span><br><span class="line">Fibonacci: 34</span><br><span class="line">Fibonacci: 55</span><br></pre></td></tr></table></figure>


<p>逃逸如下：</p>
<figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="code"><pre><span class="line"> ~/go/src/gitHub/test/pool  go build -gcflags=-m</span><br><span class="line"># gitHub/test/pool</span><br><span class="line">./main.go:7:9: can inline Fibonacci.func1</span><br><span class="line">./main.go:7:9: func literal escapes to heap</span><br><span class="line">./main.go:7:9: func literal escapes to heap</span><br><span class="line">./main.go:8:10: &amp;b escapes to heap</span><br><span class="line">./main.go:6:5: moved to heap: b</span><br><span class="line">./main.go:8:13: &amp;a escapes to heap</span><br><span class="line">./main.go:6:2: moved to heap: a</span><br><span class="line">./main.go:17:34: f() escapes to heap</span><br><span class="line">./main.go:17:13: main ... argument does not escape</span><br></pre></td></tr></table></figure>


<p>Fibonacci()函数中原本属于局部变量的a和b由于闭包的引用，不得不将二者放到堆上，以致产生逃逸。</p>
<h3 id="逃逸分析的作用是什么呢？"><a href="#逃逸分析的作用是什么呢？" class="headerlink" title="逃逸分析的作用是什么呢？"></a>逃逸分析的作用是什么呢？</h3><ol>
<li><p>逃逸分析的好处是为了减少gc的压力，不逃逸的对象分配在栈上，当函数返回时就回收了资源，不需要gc标记清除。</p>
</li>
<li><p>逃逸分析完后可以确定哪些变量可以分配在栈上，栈的分配比堆快，性能好(逃逸的局部变量会在堆上分配 ,而没有发生逃逸的则有编译器在栈上分配)。</p>
</li>
<li><p>同步消除，如果你定义的对象的方法上有同步锁，但在运行时，却只有一个线程在访问，此时逃逸分析后的机器码，会去掉同步锁运行。</p>
</li>
</ol>
<h3 id="逃逸总结："><a href="#逃逸总结：" class="headerlink" title="逃逸总结："></a>逃逸总结：</h3><ul>
<li><p>栈上分配内存比在堆中分配内存有更高的效率</p>
</li>
<li><p>栈上分配的内存不需要GC处理</p>
</li>
<li><p>堆上分配的内存使用完毕会交给GC处理</p>
</li>
<li><p>逃逸分析目的是决定内分配地址是栈还是堆</p>
</li>
<li><p>逃逸分析在编译阶段完成</p>
</li>
</ul>
<p>提问：函数传递指针真的比传值效率高吗？</p>
<blockquote>
<p>我们知道传递指针可以减少底层值的拷贝，可以提高效率，但是如果拷贝的数据量小，由于指针传递会产生逃逸，可能会使用堆，也可能会增加GC的负担，所以传递指针不一定是高效的。</p>
</blockquote>
<p>在官网 (golang.org) FAQ 上有一个关于变量分配的问题如下：</p>
<blockquote>
<p>From a correctness standpoint, you don’t need to know. Each variable in Go exists as long as there are references to it. The storage location chosen by the implementation is irrelevant to the semantics of the language.</p>
</blockquote>
<blockquote>
<p>The storage location does have an effect on writing efficient programs. When possible, the Go compilers will allocate variables that are local to a function in that function’s stack frame.</p>
</blockquote>
<blockquote>
<p>However, if the compiler cannot prove that the variable is not referenced after the function returns, then the compiler must allocate the variable on the garbage-collected heap to avoid dangling pointer errors. Also, if a local variable is very large, it might make more sense to store it on the heap rather than the stack.</p>
</blockquote>
<blockquote>
<p>In the current compilers, if a variable has its address taken, that variable is a candidate for allocation on the heap. However, a basic escape analysis recognizes some cases when such variables will not live past the return from the function and can reside on the stack.</p>
</blockquote>
<p>翻译如下：</p>
<p>如何得知变量是分配在栈（stack）上还是堆（heap）上？</p>
<p>准确地说，你并不需要知道。Golang 中的变量只要被引用就一直会存活，存储在堆上还是栈上由内部实现决定而和具体的语法没有关系。</p>
<p>知道变量的存储位置确实和效率编程有关系。如果可能，Golang 编译器会将函数的局部变量分配到函数栈帧（stack frame）上。 然而，如果编译器不能确保变量在函数 return之后不再被引用，编译器就会将变量分配到堆上。而且，如果一个局部变量非常大，那么它也应该被分配到堆上而不是栈上。</p>
<p>当前情况下，如果一个变量被取地址，那么它就有可能被分配到堆上。然而，还要对这些变量做逃逸分析，如果函数return之后，变量不再被引用，则将其分配到栈上。</p>
]]></content>
      <categories>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>底层原理</tag>
        <tag>面试题</tag>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title>Go内存泄漏</title>
    <url>/2021/02/03/technology/golang/memory_leak/</url>
    <content><![CDATA[<h2 id="1-字符串截取"><a href="#1-字符串截取" class="headerlink" title="1.字符串截取"></a>1.字符串截取</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> str0 = <span class="string">&quot;12345678901234567890&quot;</span></span><br><span class="line">    str1 := str0[:<span class="number">10</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>以上代码，会有10字节的内存泄漏，我们知道，str0和str1底层共享内存，只要str1一直活跃，str0 就不会被回收，10字节的内存被使用，剩下的10字节内存就造成了临时性的内存泄漏，直到str1不再活跃</p>
<p>如果str0足够大，str1截取足够小，或者在高并发场景中频繁使用，那么可想而知，会造成临时性内存泄漏，对性能产生极大影响。</p>
<p>解决方法：</p>
<p>将需要截取的部分先转换成[]byte，再转换成string，但是这种方式会产生两个10字节的临时变量，string转换[]byte时产生一个10字节临时变量，[]byte转换string时产生一个10字节的临时变量</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> str0 = <span class="string">&quot;12345678901234567890&quot;</span></span><br><span class="line">    str1 := <span class="type">string</span>([]<span class="type">byte</span>(str0[:<span class="number">10</span>]))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="2-切片截取（和第一个类似）"><a href="#2-切片截取（和第一个类似）" class="headerlink" title="2.切片截取（和第一个类似）"></a>2.切片截取（和第一个类似）</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> s0 = []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;</span><br><span class="line">    s1 := s0[:<span class="number">5</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>解决方法：append</p>
<p>append函数是向 <code>slice里面追加一个或多个元素，然后返回一个和slice一样类型的slice（复制一份）</code></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> s0 = []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;</span><br><span class="line">    s1 := <span class="built_in">append</span>(s0[<span class="number">0</span>:<span class="number">0</span>], s0[:<span class="number">5</span>]...)</span><br><span class="line">    fmt.Println(s1)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-没有重置丢失的子切片元素中的指针"><a href="#3-没有重置丢失的子切片元素中的指针" class="headerlink" title="3.没有重置丢失的子切片元素中的指针"></a>3.没有重置丢失的子切片元素中的指针</h2><p>原切片元素为指针类型，原切片被截取后，丢失的子切片元素中的指针元素未被置空，导致内存泄漏</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> s0 = []*<span class="type">int</span>&#123;<span class="built_in">new</span>(<span class="type">int</span>), <span class="built_in">new</span>(<span class="type">int</span>), <span class="built_in">new</span>(<span class="type">int</span>), <span class="built_in">new</span>(<span class="type">int</span>), <span class="built_in">new</span>(<span class="type">int</span>)&#125;</span><br><span class="line">    s1 := s0[<span class="number">1</span>:<span class="number">3</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>解决方案：元素置空</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> s0 = []*<span class="type">int</span>&#123;<span class="built_in">new</span>(<span class="type">int</span>), <span class="built_in">new</span>(<span class="type">int</span>), <span class="built_in">new</span>(<span class="type">int</span>), <span class="built_in">new</span>(<span class="type">int</span>), <span class="built_in">new</span>(<span class="type">int</span>)&#125;</span><br><span class="line">    s0[<span class="number">0</span>], s0[<span class="number">3</span>], s0[<span class="number">4</span>] = <span class="literal">nil</span>, <span class="literal">nil</span>, <span class="literal">nil</span></span><br><span class="line">    s1 := s0[<span class="number">1</span>:<span class="number">3</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="4-数组传参"><a href="#4-数组传参" class="headerlink" title="4.数组传参"></a>4.数组传参</h2><p>Go数组是值类型，赋值和函数传参都会复制整个数组</p>
<p>如果我们在函数传参的时候用到了数组传参，且这个数组够大（我们假设数组大小为100万，64位机上消耗的内存约为800w字节，即8MB内存），或者该函数短时间内被调用N次，那么可想而知，会消耗大量内存，对性能产生极大的影响，如果短时间内分配大量内存，而又来不及GC，那么就会产生临时性的内存泄漏，对于高并发场景相当可怕。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> arrayA = [<span class="number">3</span>]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">    <span class="keyword">var</span> arrayB = [<span class="number">3</span>]<span class="type">int</span>&#123;&#125;</span><br><span class="line">    arrayB = arrayA</span><br><span class="line">    fmt.Printf(<span class="string">&quot;arrayA address: %p, arrayA value: %+v\n&quot;</span>, &amp;arrayA, arrayA)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;arrayB address: %p, arrayB value: %+v\n&quot;</span>, &amp;arrayB, arrayB)</span><br><span class="line">    array(arrayA)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">array</span><span class="params">(array [3]<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;array address: %p, array value: %+v\n&quot;</span>, &amp;array, array)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>解决方案：指针传参或者利用切片</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> arrayA = [<span class="number">3</span>]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">    <span class="keyword">var</span> arrayB = &amp;arrayA</span><br><span class="line">    fmt.Printf(<span class="string">&quot;arrayA address: %p, arrayA value: %+v\n&quot;</span>, &amp;arrayA, arrayA)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;arrayB address: %p, arrayB value: %+v\n&quot;</span>, arrayB, *arrayB)</span><br><span class="line">    arrayP(&amp;arrayA)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">arrayP</span><span class="params">(array *[3]<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;array address: %p, array value: %+v\n&quot;</span>, array, *array)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="5-goroutine"><a href="#5-goroutine" class="headerlink" title="5.goroutine"></a>5.goroutine</h2><p>“Go里面10次内存泄漏有9次都是goroutine泄漏引起的”</p>
<p>有些编码不当的情况下，goroutine被长期挂住，导致该协程中的内存也无法被释放，就会造成永久性的内存泄漏。例如协程结束时协程中的channel没有关闭，导致一直阻塞；例如协程中有死循环；等等</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ticker := time.NewTicker(time.Second * <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        &lt;-ticker.C</span><br><span class="line">        ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">100</span>; i++ &#123;</span><br><span class="line">                ch &lt;- i</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> v := <span class="keyword">range</span> ch &#123;</span><br><span class="line">            <span class="keyword">if</span> v == <span class="number">50</span> &#123;</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>解决方案：（涉及到goroutine之间的通信）</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ticker := time.NewTicker(time.Second * <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        &lt;-ticker.C</span><br><span class="line">        cxt, cancel := context.WithCancel(context.Background())</span><br><span class="line">        ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(cxt context.Context)</span></span> &#123;</span><br><span class="line">            <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">100</span>; i++ &#123;</span><br><span class="line">                <span class="keyword">select</span> &#123;</span><br><span class="line">                <span class="keyword">case</span> &lt;-cxt.Done():</span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">                <span class="keyword">case</span> ch &lt;- i:</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;(cxt)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> v := <span class="keyword">range</span> ch &#123;</span><br><span class="line">            <span class="keyword">if</span> v == <span class="number">50</span> &#123;</span><br><span class="line">                cancel()</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>面试题</tag>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title>Go内存对齐</title>
    <url>/2021/02/03/technology/golang/memory_to_its/</url>
    <content><![CDATA[<h2 id="为什么要内存对齐？"><a href="#为什么要内存对齐？" class="headerlink" title="为什么要内存对齐？"></a>为什么要内存对齐？</h2><ul>
<li><p>平台（移植性）原因：不是所有的硬件平台都能够访问任意地址上的任意数据。例如：特定的硬件平台只允许在特定地址获取特定类型的数据，否则会导致异常情况</p>
</li>
<li><p>性能原因：若访问未对齐的内存，将会导致 CPU 进行两次内存访问，并且要花费额外的时钟周期来处理对齐及运算。而本身就对齐的内存仅需要一次访问就可以完成读取动作</p>
</li>
</ul>
<h2 id="成员对齐"><a href="#成员对齐" class="headerlink" title="成员对齐"></a>成员对齐</h2><figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">    fmt.Printf(&quot;bool align: %d\n&quot;, unsafe.Alignof(bool(true)))</span><br><span class="line">    fmt.Printf(&quot;int32 align: %d\n&quot;, unsafe.Alignof(int32(0)))</span><br><span class="line">    fmt.Printf(&quot;int8 align: %d\n&quot;, unsafe.Alignof(int8(0)))</span><br><span class="line">    fmt.Printf(&quot;int64 align: %d\n&quot;, unsafe.Alignof(int64(0)))</span><br><span class="line">    fmt.Printf(&quot;byte align: %d\n&quot;, unsafe.Alignof(byte(0)))</span><br><span class="line">    fmt.Printf(&quot;string align: %d\n&quot;, unsafe.Alignof(&quot;EDDYCJY&quot;))</span><br><span class="line">    fmt.Printf(&quot;map align: %d\n&quot;, unsafe.Alignof(map[string]string&#123;&#125;))</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>输出结果：</p>
<figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="code"><pre><span class="line">bool align: 1</span><br><span class="line">int32 align: 4</span><br><span class="line">int8 align: 1</span><br><span class="line">int64 align: 8</span><br><span class="line">byte align: 1</span><br><span class="line">string align: 8</span><br><span class="line">map align: 8</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>在 Go 中可以调用 <code>unsafe.Alignof</code> 来返回相应类型的对齐系数。通过观察输出结果，可得知基本都是 <code>2^n</code>，最大也不会超过 8。这是因为我手提（64 位）编译器默认对齐系数是 8，因此最大值不会超过这个数</p>
<h2 id=""><a href="#" class="headerlink" title=""></a></h2><h2 id="整体对齐"><a href="#整体对齐" class="headerlink" title="整体对齐"></a>整体对齐</h2><p>在上小节中，提到了结构体中的成员变量要做字节对齐。那么想当然身为最终结果的结构体，也是需要做字节对齐的</p>
<h2 id="对齐规则"><a href="#对齐规则" class="headerlink" title="对齐规则"></a>对齐规则</h2><ul>
<li><p>结构体的成员变量，第一个成员变量的偏移量为 0。往后的每个成员变量的对齐值必须为<strong>编译器默认对齐长度</strong>（<code>#pragma pack(n)</code>）或<strong>当前成员变量类型的长度</strong>（<code>unsafe.Sizeof</code>），取<strong>最小值作为当前类型的对齐值</strong>。其偏移量必须为对齐值的整数倍</p>
</li>
<li><p>结构体本身，对齐值必须为<strong>编译器默认对齐长度</strong>（<code>#pragma pack(n)</code>）或<strong>结构体的所有成员变量类型中的最大长度</strong>，取<strong>最大数的最小整数倍</strong>作为对齐值</p>
</li>
</ul>
<p>结合以上两点，可得知若<strong>编译器默认对齐长度</strong>（<code>#pragma pack(n)</code>）超过结构体内成员变量的类型最大长度时，默认对齐长度是没有任何意义的</p>
]]></content>
      <categories>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>面试题</tag>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title>Java GC垃圾回收</title>
    <url>/2022/10/02/technology/java/java_gc_recycle/</url>
    <content><![CDATA[<p>Java垃圾收集（GC）是一种内存管理机制，自动回收不再使用的对象占用的内存空间。选择合适的垃圾收集器能够优化应用程序的性能。监控和分析垃圾收集可以帮助识别和解决性能问题。</p>
<span id="more"></span>

<h2 id="什么是垃圾回收"><a href="#什么是垃圾回收" class="headerlink" title="什么是垃圾回收?"></a>什么是垃圾回收?</h2><p>垃圾回收（Garbage Collection，GC），顾名思义就是释放垃圾占用的空间，防止内存泄露。有效的使用可以使用的内存，对内存堆中已经死亡的或者长时间没有使用的对象进行清除和回收。</p>
<blockquote>
<p>简述:使用GC回收无用垃圾,释放有效内存.</p>
</blockquote>
<p>GC的历史(了解):</p>
<blockquote>
<p>Java 语言出来之前，大家都在拼命的写 C 或者 C++ 的程序，而此时存在一个很大的矛盾，C++ 等语言创建对象要不断的去开辟空间，不用的时候又需要不断的去释放空间，既要写构造函数，又要写析构函数（删除对象释放空间），很多时候都在重复不停的析构。于是，有人就提出，能不能写一段程序实现这块功能，每次创建，释放空间的时候复用这段代码，而无需重复的书写呢？所以从C到Java最大的提升就是自动垃圾回收。</p>
</blockquote>
<blockquote>
<p>另外，1960年，基于 MIT 的 Lisp语言首先提出了垃圾回收的概念，而这时 Java 还没有出世呢，所以实际上 GC 并不是Java的专利，GC 的历史远远大于 Java 的历史。</p>
</blockquote>
<p>总结思考:(C语言的特点是面向过程,需要自己手动定义内存空间,释放内存空间,不然就会一直占用着这个内存空间,导致内存泄漏,Java的特点是面向对象,有了自动垃圾回收,就不需要考虑释放这个内存空间,后台GC会帮我们处理内存的释放)</p>
<h2 id="怎么自定义垃圾"><a href="#怎么自定义垃圾" class="headerlink" title="怎么自定义垃圾?"></a>怎么自定义垃圾?</h2><p>既然我们要做垃圾回收，首先我们得搞清楚垃圾的定义是什么，哪些内存是需要回收的?<br>定义垃圾要先了解:</p>
<ul>
<li>引用计数算法（Python）</li>
<li>可达性分析算法（根搜索算法，追踪性垃圾收集）</li>
</ul>
<h3 id="引用计数算法（Python）"><a href="#引用计数算法（Python）" class="headerlink" title="引用计数算法（Python）"></a>引用计数算法（Python）</h3><p>引用计数算法（Reachability Counting）是通过在对象头中分配一个空间来保存该 对象被引用的次数（Reference Count）。如果该对象被引用，则它的引用计数加 1，如果删除对该对象的引用，那么它的引用计数就减1，当该对象的引用计数为0 时，那么该对象就会被回收。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">String m = new String(&quot;jack&quot;);</span><br></pre></td></tr></table></figure>
<img data-src="/2022/10/02/technology/java/java_gc_recycle/image.png" class="" title="image.png">

<p>先创建一个字符串，这时候”jack”有一个引用，就是 m。<br>然后将 m 设置为 null，这时候”jack”的引用次数就等于0了，在引用计数算法中，意 味着这块内容就需要被回收了。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">m = null;</span><br></pre></td></tr></table></figure>
<img data-src="/2022/10/02/technology/java/java_gc_recycle/image_1.png" class="" title="image.png">

<p>(这个方法的弊端):看似很美好，最终 还是需要放弃 引用计数算法 ，看下面的例子。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class User&#123;</span><br><span class="line">private String name;</span><br><span class="line">public Object obj;</span><br><span class="line"></span><br><span class="line">     public User(String name)&#123;&#125;</span><br><span class="line">     &#125;</span><br><span class="line"> </span><br><span class="line">     public static void testGC()&#123;</span><br><span class="line"> </span><br><span class="line">         User a = new User(&quot;objA&quot;);</span><br><span class="line">     User b = new User(&quot;objB&quot;);</span><br><span class="line"> </span><br><span class="line">         a.obj= b;</span><br><span class="line">         b.obj= a;</span><br><span class="line">         a = null;</span><br><span class="line">         b = null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>定义2个对象</li>
<li>相互引用</li>
<li>置空各自的声明引用<img data-src="/2022/10/02/technology/java/java_gc_recycle/image_2.png" class="" title="image.png">
<blockquote>
<p><strong>总结</strong>:我们看图可以看到，最后这2个对象已经不可能再被访问了，但由于他们相互引用着对方，导致它们的引用计数永远都不会为0，通过引用计数算法，也就永远无法通知GC收集器回收它们。（循环引用的问题）</p>
</blockquote>
</li>
</ol>
<h3 id="可达性分析算法（根搜索算法，追踪性垃圾收集）"><a href="#可达性分析算法（根搜索算法，追踪性垃圾收集）" class="headerlink" title="可达性分析算法（根搜索算法，追踪性垃圾收集）"></a>可达性分析算法（根搜索算法，追踪性垃圾收集）</h3><p>可达性分析算法 的基本思路是，通过一些被称为<strong>引用链</strong>（<strong>GC Roots</strong>）的对象作为起 点，从这些节点开始向上搜索，当一个对象到 GC Roots 没有任何引用链相连时（即 从 GC Roots 节点到该节点不可达），则证明该对象是不可用的。<br>在 Java 语言中，可作为 引用链（GC Roots） 的对象包括以下4种：</p>
<ol>
<li>虚拟机栈(栈帧中的本地变 量表)中引用的对象</li>
<li>方法区中静态属性引用的对象</li>
<li>方法区中常量引用的对象</li>
<li>本地方法栈中(Native修饰的方法)引用的对象<img data-src="/2022/10/02/technology/java/java_gc_recycle/image_3.png" class="" title="image.png">
<blockquote>
<p>总结:由图可以看到,通过可达性算法，成功解决了引用计数所无法解决的问题-“循环依赖”，只要你无 法与 GC Root 建立直接或间接的连接，系统就会判定你为可回收对象。</p>
</blockquote>
</li>
</ol>
<h2 id="怎么回收垃圾"><a href="#怎么回收垃圾" class="headerlink" title="怎么回收垃圾?"></a>怎么回收垃圾?</h2><p>在确定了哪些垃圾可以被回收后，垃圾收集器要做的事情就是开始进行垃圾回收，但是这里面涉及到一个问题是：如何高效地进行垃圾回收。由于Java虚拟机规范并没有 对如何实现垃圾收集器做出明确的规定，因此各个厂商的虚拟机可以采用不同的方式 来实现垃圾收集器， 以下几种 常见的垃圾收集算法：</p>
<h3 id="标记清除算法"><a href="#标记清除算法" class="headerlink" title="标记清除算法:"></a>标记清除算法:</h3><img data-src="/2022/10/02/technology/java/java_gc_recycle/image_4.png" class="" title="image.png">
<p>标记清除算法（Mark-Sweep）是最基础的一种垃圾回收算法，它分为2部分,先把内存区域中的这些对象进行标记，哪些属于可回收标记出来（标记的是存活 对象，因为对象只有两个状态所以也可以理解为标记处垃圾对象），然后把这些 垃圾拎出来清理掉。就像上图一样，清理掉的垃圾就变成未使用的内存区域，等待被再次使用。<br>这逻辑再清晰不过了，并且也很好操作，但它 存在一个很大的问题，那就是内存碎片：<br>上图中的方块的假设是 2M，小一些的是 1M，大一些的是 4M。等我们回收 完,内存就会切成了很多段。我们知道开辟内存空间时，需要的是连续的内存区 域,这时候我们需要一个 2M的内存区域其中有2个 1M 是没法用的。这样就 导致 本身还有这么多的内存的，但却用不了。</p>
<h3 id="复制回收算法"><a href="#复制回收算法" class="headerlink" title="复制回收算法:"></a>复制回收算法:</h3><img data-src="/2022/10/02/technology/java/java_gc_recycle/image_5.png" class="" title="image.png">
<p>复制算法（Copying）是在标记清除算法上演化而来，解决标记清除算法的内存碎片 问题。它将用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一 块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内 存空间一次清理掉。保证了内存的连续可用，内存分配时也就不用考虑内存碎片等复 杂情况，逻辑清晰，运行高效。<br>由图可以很清楚，也很明显的看到暴露了另一个问题，举个例子来说就是140平的大房，只能当70平米 的小房来使？代价实在太高,有点大材小用了。</p>
<h3 id="标记整理算法"><a href="#标记整理算法" class="headerlink" title="标记整理算法 :"></a>标记整理算法 :</h3><img data-src="/2022/10/02/technology/java/java_gc_recycle/image_6.png" class="" title="image.png">
<p>标记整理算法（Mark-Compact）标记过程仍然与标记清除算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，再清理掉该端边界以外的内存区域。<br>标记整理算法一方面在标记-清除算法上做了升级，解决了内存碎片的问题，也规避了复制算法只能利用一半内存区域的弊端。看起来很美好，但从上图可以看到，它对内存变动更频繁，需要整理几乎所有存活对象的引用地址，在效率上比复制算法要差很多。 </p>
<h3 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法:"></a>分代收集算法:</h3><p>严格来说并不是一种具体算法，而是融合上述3种基础的算法思想，而产生的针对不同情况所采用不同算法的一套组合拳。 对象存活周期的不同将内存划分为几块。<br>一般是把 Java 堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，因为只需要付出少量存活对象的复制成本就可以完成收集。而老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用标记清理或者标记整理算法来进行回收。 </p>
<p><strong>堆内存模型 与 回收策略（分代收集）</strong>:</p>
<img data-src="/2022/10/02/technology/java/java_gc_recycle/image_7.png" class="" title="image.png">
<p>Java 堆（Java Heap）是JVM所管理的内存中最大的一块，堆又是垃圾收集器管理的 主要区域，这里我们主要分析一下 Java 堆的结构： Java 堆主要分为2个区域-新生代与老年代(java1.8之后)，其中新生代又分 Eden 区和 Survivor 区，其中 Survivor 区又分 From 和 To 2个区。<br><strong>Minor GC 、 Major GC 、 Full GC ？</strong><br>新生代内存不够用时候发生Minor GC 也叫 Yong GC ，老年代内存不够的时候发生 Major GC， Minor GC 相比 Major GC 更频繁，回收速度也更快。 还有一种GC 负责整个新生代 + 老年代的回收称为 Full GC.</p>
<ol>
<li>Eden 区:</li>
</ol>
<ul>
<li>业务处理中，绝大多数对象是朝生夕死，这种对象会在新生代 Eden 区中进行内存分 配，当 Eden 区没有足够空间进行分配时，虚拟机会发起一次 Minor GC。</li>
<li>通过 Minor GC 之后，Eden 会被清空，Eden 区中绝大部分对象会被回收，而那些 无需回收的存活对象，将会进到 Survivor 的 From 区（若 From 区不够，则直接进入 Old 区）。</li>
</ul>
<ol start="2">
<li>Survivor 区:</li>
</ol>
<ul>
<li>Survivor 区相当于是 Eden 区和 Old 区的一个缓冲，类似于我们交通灯中的黄灯。 Survivor 又分为2个区，一个是 From 区，一个是 To 区。每次执行 Minor GC，会 将 Eden 区和 From 存活的对象放到 Survivor 的 To 区（如果 To 区不够，则直接进 入 Old 区）。</li>
</ul>
<ol start="3">
<li>Old 区:</li>
</ol>
<ul>
<li>老年代占据着2&#x2F;3的堆内存空间，只有在Major GC（full gc） 的时候才会进行清理， 每次 GC 都会触发“ Stop-The-World ”。内存越大，STW 的时间也越长，所以内存 也不仅仅是越大就越好由于复制算法在对象存活率较高的老年代会进行很多次的复 制操作，效率很低，所以老年代这里采用的是 标记-整理 算法。 </li>
<li><strong>Stop the World</strong>机制，简称STW，即在执行垃圾收集算法时,Java应用程序的 其他所有除了垃圾收集收集器线程之外的线程都被挂起。此时，系统只能允许 GC线程进行运行，其他线程则会全部暂停，等待GC线程执行完毕后才能再次运 行。</li>
</ul>
<ol start="4">
<li>为什么需要两个Survivor区？</li>
</ol>
<ul>
<li>设置两个 Survivor 区最大的好处就是解决<strong>内存碎片化</strong>，可以累计对象的年龄<strong>迟一点进入老年代</strong>。</li>
<li>我们先假设一下，Survivor 如果只有一个区域会怎样。Minor GC 执行后，Eden 区 被清空了，存活的对象放到了 Survivor 区，而之前 Survivor 区中的对象，可能也有 一些是需要被清除的。问题来了，这时候我们怎么清除它们？在这种场景下，我们只 能标记清除，而我们知道标记清除最大的问题就是内存碎片，在新生代这种经常会消 亡的区域，采用标记清除必然会让内存产生严重的碎片化。因为 Survivor 有2个区 域，所以每次 Minor GC，会将之前 Eden 区和 From 区中的存活对象复制到 To 区 域。第二次 Minor GC 时，From 与 To 职责兑换，这时候会将 Eden 区和 To 区中 的存活对象再复制到 From 区域，以此反复。</li>
<li>在from和to之间经历15次 Minor GC 之后，就会被送到老年代。</li>
<li>这种机制最大的好处就是，整个过程中，永远有一个 Survivor space 是空的，另一 个非空的 Survivor space 是无碎片的。那么，Survivor 为什么不分更多块呢？比方 说分成三个、四个、五个?显然，如果 Survivor 区再细分下去，每一块的空间就会比 较小，容易导致 Survivor 区满，两块 Survivor 区是经过权衡之后的最佳方案。</li>
</ul>
<p>针对以下几种情况也会进入老年代：    </p>
<ol>
<li>大对象:</li>
</ol>
<ul>
<li>大对象指需要大量连续内存空间的对象，这部分对象不管是不是“朝生夕死”，都会直接进 到老年代。这样做主要是为了避免在 Eden 区及2个 Survivor 区之间发生大量的内存复制。</li>
<li>当你的系统有非常多“朝生夕死”的大对象时，得注意了。</li>
</ul>
<ol start="2">
<li>长期存活对象:</li>
</ol>
<ul>
<li>虚拟机给每个对象定义了一个对象年龄（Age）计数器。正常情况下对象会不断的在 Survivor 的 From 区与 To 区之间移动，对象在 Survivor 区中每经历一次 Minor GC，年 龄就增加1岁。当年龄增加到15岁时，这时候就会被转移到老年代。当然，这里的15，JVM 也支持进行特殊设置。</li>
</ul>
<ol start="3">
<li>内存碎片：</li>
</ol>
<ul>
<li>一旦实例从堆内存中被删除，其位置就会变空并且可用于未来实例的分配。这些 空出的空间将会使整个内存区域碎片化。为了实例的快速分配，需要进行碎片整理。基于垃 圾回收器的不同选择，回收的内存区域要么被不停地被整理，要么在一个单独的GC进程中 完成。</li>
</ul>
<ol start="4">
<li>回收器选择:</li>
</ol>
<ul>
<li>JVM 给了三种选择： 串行收集器、并行收集器、并发收集器 ，但是串行收集器只适用于小 数据量的情况，所以这里的选择主要针对并行收集器和并发收集器。默认情况下， JDK1.5 以前都是使用串行收集器，如果想使用其他收集器需要在启动时加入相应参数。 JDK1.5 以 后， JVM 会根据当前系统配置进行判断。</li>
<li>吞吐量优先的并行收集器 ： 并行收集器主要以到达一定的吞吐量为目标。</li>
<li>响应时间优先的并发收集器： 并发收集器主要是保证系统的响应时间，减少垃圾收集时的停 顿时间。</li>
</ul>
<p><strong>7种收集器:</strong></p>
<img data-src="/2022/10/02/technology/java/java_gc_recycle/image_8.png" class="" title="image.png">


<ol>
<li>Serial收集器（单线程）</li>
</ol>
<p>是新生代,一个单线程的收集器，采用的是复制算法；<br>现在依然是虚拟机运行在Client模式下的默认新生代收集器，主要就是因为它简单而高效<br>2. ParNew收集器（多线程）</p>
<p>其实就是Serial收集器的多线程版本，采用的也是复制算法,他也是新生代；<br>ParNew收集器在单CPU环境中绝对不会有比Serial收集器更好的效果；<br>是许多运行在Server模式下虚拟机首选的新生代收集器，重要原因就是除了Serial收集器 外，只有它能与CMS收集器配合工作；<br>3. Parallel Scavenge（多线程）8</p>
<p>收集器是一个新生代的多线程收集器（并行收集器），它在回收期间不需要暂停其他用户线<br>程，其采用的是复制算法，该收集器与前两个收集器有所不同，它主要是为了达到一个可控 的吞吐量。<br>4. Serial Old（单线程）</p>
<p>收集器是针对老年代的收集器，采用的是标记整理算法。它的优点是实现简单高效，但是缺<br>点是会给用户带来停顿。<br>5. Parallel Old（多线程）8</p>
<p>Parallel Scavenge收集器的老年代版本（并行收集器），使用多线程和标记整理算法。<br>6. CMS收集器（多线程）</p>
<p>是一个老年代收集器,基于标记清除算法,设计目标是尽量减少停顿时间,存在着内存碎片化问<br>题,所以难以避免长时间运行情况下发生full GC,导致恶劣的停顿另外，既然强调了并发， CMS 会占用更多 CPU 资源，并和用户线程争抢。<br>7. G1收集器</p>
<p>G1(Garbage-First)是一款面向服务器的垃圾收集器,主要针对配备多台处理器及大量内存的<br>机器以及高概率满足gc定顿时间同时,还具备吞吐量高性能特征:<br>查看jdk默认垃圾收集器 java -XX:+PrintCommandLineFlags -version<br>查看堆内存中各个区的使用率 java -XX:+PrintGCDetails -version</p>
<hr>
<hr>
<p>原文链接：<a href="https://blog.csdn.net/LJWfbj666/article/details/139120947">https://blog.csdn.net/LJWfbj666/article/details/139120947</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>面试题</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java基础知识</title>
    <url>/2022/10/01/technology/java/java_basic/</url>
    <content><![CDATA[<p>Java基础知识汇总，包含基础语法，面试常见问题，底层原理等…</p>
<span id="more"></span>

<h2 id="Java基础知识"><a href="#Java基础知识" class="headerlink" title="Java基础知识"></a>Java基础知识</h2><h3 id="何为编程"><a href="#何为编程" class="headerlink" title="何为编程"></a>何为编程</h3><p>编程就是让计算机为解决某个问题而使用某种程序设计语言编写程序代码，并最终得到结果的过程。</p>
<p>为了使计算机能够理解人的意图，人类就必须要将需解决的问题的思路、方法、和手段通过计算机能够理解的形式告诉计算机，使得计算机能够根据人的指令一步一步去工作，完成某种特定的任务。这种人和计算机之间交流的过程就是编程。</p>
<h3 id="什么是Java"><a href="#什么是Java" class="headerlink" title="什么是Java"></a>什么是Java</h3><p>Java是一门面向对象编程语言，不仅吸收了C++语言的各种优点，还摒弃了C++里难以理解的多继承、指针等概念，因此Java语言具有功能强大和简单易用两个特征。Java语言作为静态面向对象编程语言的代表，极好地实现了面向对象理论，允许程序员以优雅的思维方式进行复杂的编程 。</p>
<h3 id="jdk1-5之后的三大版本"><a href="#jdk1-5之后的三大版本" class="headerlink" title="jdk1.5之后的三大版本"></a>jdk1.5之后的三大版本</h3><ul>
<li>Java SE（J2SE，Java 2 Platform Standard Edition，标准版）<br>Java SE 以前称为 J2SE。它允许开发和部署在桌面、服务器、嵌入式环境和实时环境中使用的 Java 应用程序。Java SE 包含了支持 Java Web 服务开发的类，并为Java EE和Java ME提供基础。* Java EE（J2EE，Java 2 Platform Enterprise Edition，企业版）<br>Java EE 以前称为 J2EE。企业版本帮助开发和部署可移植、健壮、可伸缩且安全的服务器端Java 应用程序。Java EE 是在 Java SE 的基础上构建的，它提供 Web 服务、组件模型、管理和通信 API，可以用来实现企业级的面向服务体系结构（service-oriented architecture，SOA）和 Web2.0应用程序。2018年2月，Eclipse 宣布正式将 JavaEE 更名为 JakartaEE* Java ME（J2ME，Java 2 Platform Micro Edition，微型版）<br>Java ME 以前称为 J2ME。Java ME 为在移动设备和嵌入式设备（比如手机、PDA、电视机顶盒和打印机）上运行的应用程序提供一个健壮且灵活的环境。Java ME 包括灵活的用户界面、健壮的安全模型、许多内置的网络协议以及对可以动态下载的连网和离线应用程序的丰富支持。基于 Java ME 规范的应用程序只需编写一次，就可以用于许多设备，而且可以利用每个设备的本机功能。</li>
</ul>
<h3 id="JVM、JRE和JDK的关系"><a href="#JVM、JRE和JDK的关系" class="headerlink" title="JVM、JRE和JDK的关系"></a>JVM、JRE和JDK的关系</h3><p>JVM<br>Java Virtual Machine是Java虚拟机，Java程序需要运行在虚拟机上，不同的平台有自己的虚拟机，因此Java语言可以实现跨平台。</p>
<p>JRE<br>Java Runtime Environment包括Java虚拟机和Java程序所需的核心类库等。核心类库主要是java.lang包：包含了运行Java程序必不可少的系统类，如基本数据类型、基本数学函数、字符串处理、线程、异常处理类等，系统缺省加载这个包</p>
<p>如果想要运行一个开发好的Java程序，计算机中只需要安装JRE即可。</p>
<p>JDK<br>Java Development Kit是提供给Java开发人员使用的，其中包含了Java的开发工具，也包括了JRE。所以安装了JDK，就无需再单独安装JRE了。其中的开发工具：编译工具(javac.exe)，打包工具(jar.exe)等</p>
<p>JVM&amp;JRE&amp;JDK关系图</p>
<img data-src="/2022/10/01/technology/java/java_basic/image.png" class="" title="image.png">

<h3 id="什么是跨平台性？原理是什么"><a href="#什么是跨平台性？原理是什么" class="headerlink" title="什么是跨平台性？原理是什么"></a>什么是跨平台性？原理是什么</h3><p>所谓跨平台性，是指java语言编写的程序，一次编译后，可以在多个系统平台上运行。</p>
<p>实现原理：Java程序是通过java虚拟机在系统平台上运行的，只要该系统可以安装相应的java虚拟机，该系统就可以运行java程序。</p>
<h3 id="Java语言有哪些特点"><a href="#Java语言有哪些特点" class="headerlink" title="Java语言有哪些特点"></a>Java语言有哪些特点</h3><p>简单易学（Java语言的语法与C语言和C++语言很接近）</p>
<p>面向对象（封装，继承，多态）</p>
<p>平台无关性（Java虚拟机实现平台无关性）</p>
<p>支持网络编程并且很方便（Java语言诞生本身就是为简化网络编程设计的）</p>
<p>支持多线程（多线程机制使应用程序在同一时间并行执行多项任）</p>
<p>健壮性（Java语言的强类型机制、异常处理、垃圾的自动收集等）</p>
<p>安全性</p>
<h3 id="什么是字节码？采用字节码的最大好处是什么"><a href="#什么是字节码？采用字节码的最大好处是什么" class="headerlink" title="什么是字节码？采用字节码的最大好处是什么"></a>什么是字节码？采用字节码的最大好处是什么</h3><p><strong>字节码</strong>：Java源代码经过虚拟机编译器编译后产生的文件（即扩展为.class的文件），它不面向任何特定的处理器，只面向虚拟机。</p>
<p><strong>采用字节码的好处</strong>：</p>
<p>Java语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点。所以Java程序运行时比较高效，而且，由于字节码并不专对一种特定的机器，因此，Java程序无须重新编译便可在多种不同的计算机上运行。</p>
<p><strong>先看下java中的编译器和解释器</strong>：</p>
<p>Java中引入了虚拟机的概念，即在机器和编译程序之间加入了一层抽象的虚拟机器。这台虚拟的机器在任何平台上都提供给编译程序一个的共同的接口。编译程序只需要面向虚拟机，生成虚拟机能够理解的代码，然后由解释器来将虚拟机代码转换为特定系统的机器码执行。在Java中，这种供虚拟机理解的代码叫做字节码（即扩展为.class的文件），它不面向任何特定的处理器，只面向虚拟机。每一种平台的解释器是不同的，但是实现的虚拟机是相同的。Java源程序经过编译器编译后变成字节码，字节码由虚拟机解释执行，虚拟机将每一条要执行的字节码送给解释器，解释器将其翻译成特定机器上的机器码，然后在特定的机器上运行，这就是上面提到的Java的特点的编译与解释并存的解释。</p>
<blockquote>
<p>Java源代码—-&gt;编译器—-&gt;jvm可执行的Java字节码(即虚拟指令)—-&gt;jvm—-&gt;jvm中解释器—–&gt;机器可执行的二进制机器码—-&gt;程序运行。</p>
</blockquote>
<h3 id="什么是Java程序的主类？应用程序和小程序的主类有何不同？"><a href="#什么是Java程序的主类？应用程序和小程序的主类有何不同？" class="headerlink" title="什么是Java程序的主类？应用程序和小程序的主类有何不同？"></a>什么是Java程序的主类？应用程序和小程序的主类有何不同？</h3><p>一个程序中可以有多个类，但只能有一个类是主类。在Java应用程序中，这个主类是指包含main()方法的类。而在Java小程序中，这个主类是一个继承自系统类JApplet或Applet的子类。应用程序的主类不一定要求是public类，但小程序的主类要求必须是public类。主类是Java程序执行的入口点。</p>
<h3 id="Java应用程序与小程序之间有那些差别？"><a href="#Java应用程序与小程序之间有那些差别？" class="headerlink" title="Java应用程序与小程序之间有那些差别？"></a>Java应用程序与小程序之间有那些差别？</h3><p>简单说应用程序是从主线程启动(也就是main()方法)。applet小程序没有main方法，主要是嵌在浏览器页面上运行(调用init()线程或者run()来启动)，嵌入浏览器这点跟flash的小游戏类似。</p>
<h3 id="Java和C-的区别"><a href="#Java和C-的区别" class="headerlink" title="Java和C++的区别"></a>Java和C++的区别</h3><p>我知道很多人没学过C++，但是面试官就是没事喜欢拿咱们Java和C++比呀！没办法！！！就算没学过C++，也要记下来！</p>
<ul>
<li><p>都是面向对象的语言，都支持封装、继承和多态</p>
</li>
<li><p>Java不提供指针来直接访问内存，程序内存更加安全</p>
</li>
<li><p>Java的类是单继承的，C++支持多重继承；虽然Java的类不可以多继承，但是接口可以多继承。</p>
</li>
<li><p>Java有自动内存管理机制，不需要程序员手动释放无用内存</p>
</li>
</ul>
<h3 id="Oracle-JDK-和-OpenJDK-的对比"><a href="#Oracle-JDK-和-OpenJDK-的对比" class="headerlink" title="Oracle JDK 和 OpenJDK 的对比"></a>Oracle JDK 和 OpenJDK 的对比</h3><ol>
<li><p>Oracle JDK版本将每三年发布一次，而OpenJDK版本每三个月发布一次；</p>
</li>
<li><p>OpenJDK 是一个参考模型并且是完全开源的，而Oracle JDK是OpenJDK的一个实现，并不是完全开源的；</p>
</li>
<li><p>Oracle JDK 比 OpenJDK 更稳定。OpenJDK和Oracle JDK的代码几乎相同，但Oracle JDK有更多的类和一些错误修复。因此，如果您想开发企业&#x2F;商业软件，我建议您选择Oracle JDK，因为它经过了彻底的测试和稳定。某些情况下，有些人提到在使用OpenJDK 可能会遇到了许多应用程序崩溃的问题，但是，只需切换到Oracle JDK就可以解决问题；</p>
</li>
<li><p>在响应性和JVM性能方面，Oracle JDK与OpenJDK相比提供了更好的性能；</p>
</li>
<li><p>Oracle JDK不会为即将发布的版本提供长期支持，用户每次都必须通过更新到最新版本获得支持来获取最新版本；</p>
</li>
<li><p>Oracle JDK根据二进制代码许可协议获得许可，而OpenJDK根据GPL v2许可获得许可。</p>
</li>
</ol>
<h2 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h2><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><h4 id="Java有哪些数据类型"><a href="#Java有哪些数据类型" class="headerlink" title="Java有哪些数据类型"></a>Java有哪些数据类型</h4><p><strong>定义</strong>：Java语言是强类型语言，对于每一种数据都定义了明确的具体的数据类型，在内存中分配了不同大小的内存空间。</p>
<p><strong>分类</strong></p>
<ul>
<li><p>基本数据类型</p>
</li>
<li><p>数值型</p>
</li>
<li><p>整数类型(byte,short,int,long)</p>
</li>
<li><p>浮点类型(float,double)* 字符型(char)</p>
</li>
<li><p>布尔型(boolean)* 引用数据类型</p>
</li>
<li><p>类(class)</p>
</li>
<li><p>接口(interface)</p>
</li>
<li><p>数组([])</p>
</li>
</ul>
<p><strong>Java基本数据类型图</strong></p>
<img data-src="/2022/10/01/technology/java/java_basic/image_1.png" class="" title="image.png">

<h4 id="switch-是否能作用在-byte-上，是否能作用在-long-上，是否能作用在-String-上"><a href="#switch-是否能作用在-byte-上，是否能作用在-long-上，是否能作用在-String-上" class="headerlink" title="switch 是否能作用在 byte 上，是否能作用在 long 上，是否能作用在 String 上"></a>switch 是否能作用在 byte 上，是否能作用在 long 上，是否能作用在 String 上</h4><p>在 Java 5 以前，switch(expr)中，expr 只能是 byte、short、char、int。从 Java5 开始，Java 中引入了枚举类型，expr 也可以是 enum 类型，从 Java 7 开始，expr 还可以是字符串（String），但是长整型（long）在目前所有的版本中都是不可以的。</p>
<h4 id="用最有效率的方法计算-2-乘以-8"><a href="#用最有效率的方法计算-2-乘以-8" class="headerlink" title="用最有效率的方法计算 2 乘以 8"></a>用最有效率的方法计算 2 乘以 8</h4><p>2 &lt;&lt; 3（左移 3 位相当于乘以 2 的 3 次方，右移 3 位相当于除以 2 的 3 次方）。</p>
<h4 id="Math-round-11-5-等于多少？Math-round-11-5-等于多少"><a href="#Math-round-11-5-等于多少？Math-round-11-5-等于多少" class="headerlink" title="Math.round(11.5) 等于多少？Math.round(-11.5)等于多少"></a>Math.round(11.5) 等于多少？Math.round(-11.5)等于多少</h4><p>Math.round(11.5)的返回值是 12，Math.round(-11.5)的返回值是-11。四舍五入的原理是在参数上加 0.5 然后进行下取整。</p>
<h4 id="float-f-3-4-是否正确"><a href="#float-f-3-4-是否正确" class="headerlink" title="float f&#x3D;3.4;是否正确"></a>float f&#x3D;3.4;是否正确</h4><p>不正确。3.4 是双精度数，将双精度型（double）赋值给浮点型（float）属于下转型（down-casting，也称为窄化）会造成精度损失，因此需要强制类型转换float f &#x3D;(float)3.4; 或者写成 float f &#x3D;3.4F;。</p>
<h4 id="short-s1-1-s1-s1-1-有错吗-short-s1-1-s1-1-有错吗"><a href="#short-s1-1-s1-s1-1-有错吗-short-s1-1-s1-1-有错吗" class="headerlink" title="short s1 &#x3D; 1; s1 &#x3D; s1 + 1;有错吗?short s1 &#x3D; 1; s1 +&#x3D; 1;有错吗"></a>short s1 &#x3D; 1; s1 &#x3D; s1 + 1;有错吗?short s1 &#x3D; 1; s1 +&#x3D; 1;有错吗</h4><p>对于 short s1 &#x3D; 1; s1 &#x3D; s1 + 1;由于 1 是 int 类型，因此 s1+1 运算结果也是 int型，需要强制转换类型才能赋值给 short 型。</p>
<p>而 short s1 &#x3D; 1; s1 +&#x3D; 1;可以正确编译，因为 s1+&#x3D; 1;相当于 s1 &#x3D; (short(s1 + 1);其中有隐含的强制类型转换。</p>
<h3 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h3><h4 id="Java语言采用何种编码方案？有何特点？"><a href="#Java语言采用何种编码方案？有何特点？" class="headerlink" title="Java语言采用何种编码方案？有何特点？"></a>Java语言采用何种编码方案？有何特点？</h4><p>Java语言采用Unicode编码标准，Unicode（标准码），它为每个字符制订了一个唯一的数值，因此在任何的语言，平台，程序都可以放心的使用。</p>
<h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><h4 id="什么Java注释"><a href="#什么Java注释" class="headerlink" title="什么Java注释"></a>什么Java注释</h4><p><strong>定义</strong>：用于解释说明程序的文字</p>
<p><strong>分类</strong></p>
<ul>
<li>单行注释<br>格式： &#x2F;&#x2F; 注释文字* 多行注释<br>格式： &#x2F;* 注释文字 <em>&#x2F;</em> 文档注释<br>格式：&#x2F;** 注释文字 *&#x2F;</li>
</ul>
<p><strong>作用</strong></p>
<p>在程序中，尤其是复杂的程序中，适当地加入注释可以增加程序的可读性，有利于程序的修改、调试和交流。注释的内容在程序编译的时候会被忽视，不会产生目标代码，注释的部分不会对程序的执行结果产生任何影响。</p>
<p>注意事项：多行和文档注释都不能嵌套使用。</p>
<h3 id="访问修饰符"><a href="#访问修饰符" class="headerlink" title="访问修饰符"></a>访问修饰符</h3><h4 id="访问修饰符-public-private-protected-以及不写（默认）时的区别"><a href="#访问修饰符-public-private-protected-以及不写（默认）时的区别" class="headerlink" title="访问修饰符 public,private,protected,以及不写（默认）时的区别"></a>访问修饰符 public,private,protected,以及不写（默认）时的区别</h4><p><strong>定义</strong>：Java中，可以使用访问修饰符来保护对类、变量、方法和构造方法的访问。Java 支持 4 种不同的访问权限。</p>
<p><strong>分类</strong></p>
<p>private : 在同一类内可见。使用对象：变量、方法。 注意：不能修饰类（外部类）<br>default (即缺省，什么也不写，不使用任何关键字）: 在同一包内可见，不使用任何修饰符。使用对象：类、接口、变量、方法。<br>protected : 对同一包内的类和所有子类可见。使用对象：变量、方法。 注意：不能修饰类（外部类）。<br>public : 对所有类可见。使用对象：类、接口、变量、方法</p>
<p><strong>访问修饰符图</strong></p>
<img data-src="/2022/10/01/technology/java/java_basic/image_2.png" class="" title="image.png">

<h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><h4 id="和-的区别"><a href="#和-的区别" class="headerlink" title="&amp;和&amp;&amp;的区别"></a>&amp;和&amp;&amp;的区别</h4><p>&amp;运算符有两种用法：(1)按位与；(2)逻辑与。</p>
<p>&amp;&amp;运算符是短路与运算。逻辑与跟短路与的差别是非常巨大的，虽然二者都要求运算符左右两端的布尔值都是true 整个表达式的值才是 true。&amp;&amp;之所以称为短路运算，是因为如果&amp;&amp;左边的表达式的值是 false，右边的表达式会被直接短路掉，不会进行运算。</p>
<p>注意：逻辑或运算符（|）和短路或运算符（||）的差别也是如此。</p>
<h3 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h3><h4 id="Java-有没有-goto"><a href="#Java-有没有-goto" class="headerlink" title="Java 有没有 goto"></a>Java 有没有 goto</h4><p>goto 是 Java 中的保留字，在目前版本的 Java 中没有使用。</p>
<h4 id="final-有什么用？"><a href="#final-有什么用？" class="headerlink" title="final 有什么用？"></a>final 有什么用？</h4><p>用于修饰类、属性和方法；</p>
<ul>
<li><p>被final修饰的类不可以被继承</p>
</li>
<li><p>被final修饰的方法不可以被重写</p>
</li>
<li><p>被final修饰的变量不可以被改变，被final修饰不可变的是变量的引用，而不是引用指向的内容，引用指向的内容是可以改变的</p>
</li>
</ul>
<h4 id="final-finally-finalize区别"><a href="#final-finally-finalize区别" class="headerlink" title="final finally finalize区别"></a>final finally finalize区别</h4><ul>
<li>final可以修饰类、变量、方法，修饰类表示该类不能被继承、修饰方法表示该方法不能被重写、修饰变量表<br>示该变量是一个常量不能被重新赋值。* finally一般作用在try-catch代码块中，在处理异常的时候，通常我们将一定要执行的代码方法finally代码块<br>中，表示不管是否出现异常，该代码块都会执行，一般用来存放一些关闭资源的代码。* finalize是一个方法，属于Object类的一个方法，而Object类是所有类的父类，该方法一般由垃圾回收器来调<br>用，当我们调用System.gc() 方法的时候，由垃圾回收器调用finalize()，回收垃圾，一个对象是否可回收的<br>最后判断。</li>
</ul>
<h4 id="this关键字的用法"><a href="#this关键字的用法" class="headerlink" title="this关键字的用法"></a>this关键字的用法</h4><p>this是自身的一个对象，代表对象本身，可以理解为：指向对象本身的一个指针。</p>
<p>this的用法在java中大体可以分为3种：</p>
<p>1.普通的直接引用，this相当于是指向当前对象本身。</p>
<p>2.形参与成员名字重名，用this来区分：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">    <span class="built_in">this</span>.age = age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>3.引用本类的构造函数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(name);</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="super关键字的用法"><a href="#super关键字的用法" class="headerlink" title="super关键字的用法"></a>super关键字的用法</h4><p>super可以理解为是指向自己超（父）类对象的一个指针，而这个超类指的是离自己最近的一个父类。</p>
<p>super也有三种用法：</p>
<p>1.普通的直接引用</p>
<p>与this类似，super相当于是指向当前对象的父类的引用，这样就可以用super.xxx来引用父类的成员。</p>
<p>2.子类中的成员变量或方法与父类中的成员变量或方法同名时，用super进行区分</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name, String name1)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name);</span><br><span class="line">        <span class="built_in">this</span>.name = name1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getInfo</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="built_in">this</span>.name);      <span class="comment">//Child</span></span><br><span class="line">        System.out.println(<span class="built_in">super</span>.name);     <span class="comment">//Father</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">       <span class="type">Student</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;Father&quot;</span>,<span class="string">&quot;Child&quot;</span>);</span><br><span class="line">       s1.getInfo();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>3.引用父类构造函数</p>
<p>3、引用父类构造函数</p>
<ul>
<li><p>super（参数）：调用父类中的某一个构造函数（应该为构造函数中的第一条语句）。</p>
</li>
<li><p>this（参数）：调用本类中另一种形式的构造函数（应该为构造函数中的第一条语句）。</p>
</li>
</ul>
<h4 id="this与super的区别"><a href="#this与super的区别" class="headerlink" title="this与super的区别"></a>this与super的区别</h4><ul>
<li><p>super:　它引用当前对象的直接父类中的成员（用来访问直接父类中被隐藏的父类中成员数据或函数，基类与派生类中有相同成员定义时如：super.变量名 super.成员函数据名（实参）</p>
</li>
<li><p>this：它代表当前对象名（在程序中易产生二义性之处，应使用this来指明当前对象；如果函数的形参与类中的成员数据同名，这时需用this来指明成员变量名）</p>
</li>
<li><p>super()和this()类似,区别是，super()在子类中调用父类的构造方法，this()在本类内调用本类的其它构造方法。</p>
</li>
<li><p>super()和this()均需放在构造方法内第一行。</p>
</li>
<li><p>尽管可以用this调用一个构造器，但却不能调用两个。</p>
</li>
<li><p>this和super不能同时出现在一个构造函数里面，因为this必然会调用其它的构造函数，其它的构造函数必然也会有super语句的存在，所以在同一个构造函数里面有相同的语句，就失去了语句的意义，编译器也不会通过。</p>
</li>
<li><p>this()和super()都指的是对象，所以，均不可以在static环境中使用。包括：static变量,static方法，static语句块。</p>
</li>
<li><p>从本质上讲，this是一个指向本对象的指针, 然而super是一个Java关键字。</p>
</li>
</ul>
<h4 id="static存在的主要意义"><a href="#static存在的主要意义" class="headerlink" title="static存在的主要意义"></a>static存在的主要意义</h4><p>static的主要意义是在于创建独立于具体对象的域变量或者方法。<strong>以致于即使没有创建对象，也能使用属性和调用方法</strong>！</p>
<p>static关键字还有一个比较关键的作用就是 <strong>用来形成静态代码块以优化程序性能</strong>。static块可以置于类中的任何地方，类中可以有多个static块。在类初次被加载的时候，会按照static块的顺序来执行每个static块，并且只会执行一次。</p>
<p>为什么说static块可以用来优化程序性能，是因为它的特性:只会在类加载的时候执行一次。因此，很多时候会将一些只需要进行一次的初始化操作都放在static代码块中进行。</p>
<h4 id="static的独特之处"><a href="#static的独特之处" class="headerlink" title="static的独特之处"></a>static的独特之处</h4><p>1、被static修饰的变量或者方法是独立于该类的任何对象，也就是说，这些变量和方法<strong>不属于任何一个实例对象，而是被类的实例对象所共享</strong>。</p>
<blockquote>
<p>怎么理解 “被类的实例对象所共享” 这句话呢？就是说，一个类的静态成员，它是属于大伙的【大伙指的是这个类的多个对象实例，我们都知道一个类可以创建多个实例！】，所有的类对象共享的，不像成员变量是自个的【自个指的是这个类的单个实例对象】…我觉得我已经讲的很通俗了，你明白了咩？</p>
</blockquote>
<p>2、在该类被第一次加载的时候，就会去加载被static修饰的部分，而且只在类第一次使用时加载并进行初始化，注意这是第一次用就要初始化，后面根据需要是可以再次赋值的。</p>
<p>3、static变量值在类加载的时候分配空间，以后创建类对象的时候不会重新分配。赋值的话，是可以任意赋值的！</p>
<p>4、被static修饰的变量或者方法是优先于对象存在的，也就是说当一个类加载完毕之后，即便没有创建对象，也可以去访问。</p>
<h4 id="static应用场景"><a href="#static应用场景" class="headerlink" title="static应用场景"></a>static应用场景</h4><p>因为static是被类的实例对象所共享，因此如果<strong>某个成员变量是被所有对象所共享的，那么这个成员变量就应该定义为静态变量</strong>。</p>
<p>因此比较常见的static应用场景有：</p>
<blockquote>
<p>1、修饰成员变量 2、修饰成员方法 3、静态代码块 4、修饰类【只能修饰内部类也就是静态内部类】 5、静态导包</p>
</blockquote>
<h4 id="static注意事项"><a href="#static注意事项" class="headerlink" title="static注意事项"></a>static注意事项</h4><p>1、静态只能访问静态。 2、非静态既可以访问非静态的，也可以访问静态的。</p>
<h3 id="流程控制语句"><a href="#流程控制语句" class="headerlink" title="流程控制语句"></a>流程控制语句</h3><h4 id="break-continue-return-的区别及作用"><a href="#break-continue-return-的区别及作用" class="headerlink" title="break ,continue ,return 的区别及作用"></a>break ,continue ,return 的区别及作用</h4><p>break 跳出总上一层循环，不再执行循环(结束当前的循环体)</p>
<p>continue 跳出本次循环，继续执行下次循环(结束正在执行的循环 进入下一个循环条件)</p>
<p>return 程序返回，不再执行下面的代码(结束当前的方法 直接返回)</p>
<h4 id="在-Java-中，如何跳出当前的多重嵌套循环"><a href="#在-Java-中，如何跳出当前的多重嵌套循环" class="headerlink" title="在 Java 中，如何跳出当前的多重嵌套循环"></a>在 Java 中，如何跳出当前的多重嵌套循环</h4><p>在Java中，要想跳出多重循环，可以在外面的循环语句前定义一个标号，然后在里层循环体的代码中使用带有标号的break 语句，即可跳出外层循环。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    ok:</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">10</span>; j++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;i=&quot;</span> + i + <span class="string">&quot;,j=&quot;</span> + j);</span><br><span class="line">            <span class="keyword">if</span> (j == <span class="number">5</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span> ok;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><h3 id="面向对象概述"><a href="#面向对象概述" class="headerlink" title="面向对象概述"></a>面向对象概述</h3><h4 id="面向对象和面向过程的区别"><a href="#面向对象和面向过程的区别" class="headerlink" title="面向对象和面向过程的区别"></a>面向对象和面向过程的区别</h4><p><strong>面向过程</strong>：</p>
<p>优点：性能比面向对象高，因为类调用时需要实例化，开销比较大，比较消耗资源;比如单片机、嵌入式开发、Linux&#x2F;Unix等一般采用面向过程开发，性能是最重要的因素。</p>
<p>缺点：没有面向对象易维护、易复用、易扩展</p>
<p><strong>面向对象</strong>：</p>
<p>优点：易维护、易复用、易扩展，由于面向对象有封装、继承、多态性的特性，可以设计出低耦合的系统，使系统更加灵活、更加易于维护</p>
<p>缺点：性能比面向过程低</p>
<p><strong>面向过程是具体化的，流程化的，解决一个问题，你需要一步一步的分析，一步一步的实现。</strong></p>
<p><strong>面向对象是模型化的，你只需抽象出一个类，这是一个封闭的盒子，在这里你拥有数据也拥有解决问题的方法。需要什么功能直接使用就可以了，不必去一步一步的实现，至于这个功能是如何实现的，管我们什么事？我们会用就可以了。</strong></p>
<p>面向对象的底层其实还是面向过程，把面向过程抽象成类，然后封装，方便我们使用的就是面向对象了。</p>
<h3 id="面向对象三大特性"><a href="#面向对象三大特性" class="headerlink" title="面向对象三大特性"></a>面向对象三大特性</h3><h4 id="面向对象的特征有哪些方面"><a href="#面向对象的特征有哪些方面" class="headerlink" title="面向对象的特征有哪些方面"></a>面向对象的特征有哪些方面</h4><p><strong>面向对象的特征主要有以下几个方面</strong>：</p>
<p><strong>抽象</strong>：抽象是将一类对象的共同特征总结出来构造类的过程，包括数据抽象和行为抽象两方面。抽象只关注对象有哪些属性和行为，并不关注这些行为的细节是什么。</p>
<p>封装</p>
<p>封装把一个对象的属性私有化，同时提供一些可以被外界访问的属性的方法，如果属性不想被外界访问，我们大可不必提供方法给外界访问。但是如果一个类没有提供给外界访问的方法，那么这个类也没有什么意义了。</p>
<p>继承</p>
<p>继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。通过使用继承我们能够非常方便地复用以前的代码。</p>
<p>关于继承如下 3 点请记住：</p>
<ol>
<li><p>子类拥有父类非 private 的属性和方法。</p>
</li>
<li><p>子类可以拥有自己属性和方法，即子类可以对父类进行扩展。</p>
</li>
<li><p>子类可以用自己的方式实现父类的方法。（以后介绍）。</p>
</li>
</ol>
<p>多态</p>
<p>所谓多态就是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定，即一个引用变量到底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。</p>
<p>在Java中有两种形式可以实现多态：继承（多个子类对同一方法的重写）和接口（实现接口并覆盖接口中同一方法）。</p>
<p>其中Java 面向对象编程三大特性：封装 继承 多态</p>
<p><strong>封装</strong>：隐藏对象的属性和实现细节，仅对外提供公共访问方式，将变化隔离，便于使用，提高复用性和安全性。</p>
<p><strong>继承</strong>：继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。通过使用继承可以提高代码复用性。继承是多态的前提。</p>
<p><strong>关于继承如下 3 点请记住</strong>：</p>
<ol start="4">
<li><p>子类拥有父类非 private 的属性和方法。</p>
</li>
<li><p>子类可以拥有自己属性和方法，即子类可以对父类进行扩展。</p>
</li>
<li><p>子类可以用自己的方式实现父类的方法。</p>
</li>
</ol>
<p><strong>多态性</strong>：父类或接口定义的引用变量可以指向子类或具体实现类的实例对象。提高了程序的拓展性。</p>
<p>在Java中有两种形式可以实现多态：继承（多个子类对同一方法的重写）和接口（实现接口并覆盖接口中同一方法）。</p>
<p>方法重载（overload）实现的是编译时的多态性（也称为前绑定），而方法重写（override）实现的是运行时的多态性（也称为后绑定）。</p>
<p>一个引用变量到底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。运行时的多态是面向对象最精髓的东西，要实现多态需要做两件事：</p>
<ul>
<li><p>方法重写（子类继承父类并重写父类中已有的或抽象的方法）；</p>
</li>
<li><p>对象造型（用父类型引用子类型对象，这样同样的引用调用同样的方法就会根据子类对象的不同而表现出不同的行为）。</p>
</li>
</ul>
<h4 id="什么是多态机制？Java语言是如何实现多态的？"><a href="#什么是多态机制？Java语言是如何实现多态的？" class="headerlink" title="什么是多态机制？Java语言是如何实现多态的？"></a>什么是多态机制？Java语言是如何实现多态的？</h4><p>所谓多态就是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定，即一个引用变量倒底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。因为在程序运行时才确定具体的类，这样，不用修改源程序代码，就可以让引用变量绑定到各种不同的类实现上，从而导致该引用调用的具体方法随之改变，即不修改程序代码就可以改变程序运行时所绑定的具体代码，让程序可以选择多个运行状态，这就是多态性。</p>
<p>多态分为编译时多态和运行时多态。其中编辑时多态是静态的，主要是指方法的重载，它是根据参数列表的不同来区分不同的函数，通过编辑之后会变成两个不同的函数，在运行时谈不上多态。而运行时多态是动态的，它是通过动态绑定来实现的，也就是我们所说的多态性。</p>
<p><strong>多态的实现</strong></p>
<p>Java实现多态有三个必要条件：继承、重写、向上转型。</p>
<p>继承：在多态中必须存在有继承关系的子类和父类。</p>
<p>重写：子类对父类中某些方法进行重新定义，在调用这些方法时就会调用子类的方法。</p>
<p>向上转型：在多态中需要将子类的引用赋给父类对象，只有这样该引用才能够具备技能调用父类的方法和子类的方法。</p>
<p>只有满足了上述三个条件，我们才能够在同一个继承结构中使用统一的逻辑实现代码处理不同的对象，从而达到执行不同的行为。</p>
<p>对于Java而言，它多态的实现机制遵循一个原则：当超类对象引用变量引用子类对象时，被引用对象的类型而不是引用变量的类型决定了调用谁的成员方法，但是这个被调用的方法必须是在超类中定义过的，也就是说被子类覆盖的方法。</p>
<h4 id="面向对象五大基本原则是什么（可选）"><a href="#面向对象五大基本原则是什么（可选）" class="headerlink" title="面向对象五大基本原则是什么（可选）"></a>面向对象五大基本原则是什么（可选）</h4><ul>
<li>单一职责原则SRP(Single Responsibility Principle)<br>类的功能要单一，不能包罗万象，跟杂货铺似的。* 开放封闭原则OCP(Open－Close Principle)<br>一个模块对于拓展是开放的，对于修改是封闭的，想要增加功能热烈欢迎，想要修改，哼，一万个不乐意。* 里式替换原则LSP(the Liskov Substitution Principle LSP)<br>子类可以替换父类出现在父类能够出现的任何地方。比如你能代表你爸去你姥姥家干活。哈哈~~* 依赖倒置原则DIP(the Dependency Inversion Principle DIP)<br>高层次的模块不应该依赖于低层次的模块，他们都应该依赖于抽象。抽象不应该依赖于具体实现，具体实现应该依赖于抽象。就是你出国要说你是中国人，而不能说你是哪个村子的。比如说中国人是抽象的，下面有具体的xx省，xx市，xx县。你要依赖的抽象是中国人，而不是你是xx村的。* 接口分离原则ISP(the Interface Segregation Principle ISP)<br>设计时采用多个与特定客户类有关的接口比采用一个通用的接口要好。就比如一个手机拥有打电话，看视频，玩游戏等功能，把这几个功能拆分成不同的接口，比在一个接口里要好的多。</li>
</ul>
<h3 id="类与接口"><a href="#类与接口" class="headerlink" title="类与接口"></a>类与接口</h3><h4 id="抽象类和接口的对比"><a href="#抽象类和接口的对比" class="headerlink" title="抽象类和接口的对比"></a>抽象类和接口的对比</h4><p>抽象类是用来捕捉子类的通用特性的。接口是抽象方法的集合。</p>
<p>从设计层面来说，抽象类是对类的抽象，是一种模板设计，接口是行为的抽象，是一种行为的规范。</p>
<p><strong>相同点</strong></p>
<ul>
<li><p>接口和抽象类都不能实例化</p>
</li>
<li><p>都位于继承的顶端，用于被其他实现或继承</p>
</li>
<li><p>都包含抽象方法，其子类都必须覆写这些抽象方法</p>
</li>
</ul>
<p><strong>不同点</strong></p>
<table>
<thead>
<tr>
<th>参数</th>
<th>抽象类</th>
<th>接口</th>
</tr>
</thead>
<tbody><tr>
<td>声明</td>
<td>抽象类使用abstract关键字声明</td>
<td>接口使用interface关键字声明</td>
</tr>
<tr>
<td>实现</td>
<td>子类使用extends关键字来继承抽象类。如果子类不是抽象类的话，它需要提供抽象类中所有声明的方法的实现</td>
<td>子类使用implements关键字来实现接口。它需要提供接口中所有声明的方法的实现</td>
</tr>
<tr>
<td>构造器</td>
<td>抽象类可以有构造器</td>
<td>接口不能有构造器</td>
</tr>
<tr>
<td>访问修饰符</td>
<td>抽象类中的方法可以是任意访问修饰符</td>
<td>接口方法默认修饰符是public。并且不允许定义为 private 或者 protected</td>
</tr>
<tr>
<td>多继承</td>
<td>一个类最多只能继承一个抽象类</td>
<td>一个类可以实现多个接口</td>
</tr>
<tr>
<td>字段声明</td>
<td>抽象类的字段声明可以是任意的</td>
<td>接口的字段默认都是 static 和 final 的</td>
</tr>
</tbody></table>
<p><strong>备注</strong>：Java8中接口中引入默认方法和静态方法，以此来减少抽象类和接口之间的差异。</p>
<p>现在，我们可以为接口提供默认实现的方法了，并且不用强制子类来实现它。</p>
<p>接口和抽象类各有优缺点，在接口和抽象类的选择上，必须遵守这样一个原则：</p>
<ul>
<li><p>行为模型应该总是通过接口而不是抽象类定义，所以通常是优先选用接口，尽量少用抽象类。</p>
</li>
<li><p>选择抽象类的时候通常是如下情况：需要定义子类的行为，又要为子类提供通用的功能。</p>
</li>
</ul>
<h4 id="普通类和抽象类有哪些区别？"><a href="#普通类和抽象类有哪些区别？" class="headerlink" title="普通类和抽象类有哪些区别？"></a>普通类和抽象类有哪些区别？</h4><ul>
<li><p>普通类不能包含抽象方法，抽象类可以包含抽象方法。</p>
</li>
<li><p>抽象类不能直接实例化，普通类可以直接实例化。</p>
</li>
</ul>
<h4 id="抽象类能使用-final-修饰吗？"><a href="#抽象类能使用-final-修饰吗？" class="headerlink" title="抽象类能使用 final 修饰吗？"></a>抽象类能使用 final 修饰吗？</h4><p>不能，定义抽象类就是让其他类继承的，如果定义为 final 该类就不能被继承，这样彼此就会产生矛盾，所以 final 不能修饰抽象类</p>
<h4 id="创建一个对象用什么关键字？对象实例与对象引用有何不同？"><a href="#创建一个对象用什么关键字？对象实例与对象引用有何不同？" class="headerlink" title="创建一个对象用什么关键字？对象实例与对象引用有何不同？"></a>创建一个对象用什么关键字？对象实例与对象引用有何不同？</h4><p>new关键字，new创建对象实例（对象实例在堆内存中），对象引用指向对象实例（对象引用存放在栈内存中）。一个对象引用可以指向0个或1个对象（一根绳子可以不系气球，也可以系一个气球）;一个对象可以有n个引用指向它（可以用n条绳子系住一个气球）</p>
<h3 id="变量与方法"><a href="#变量与方法" class="headerlink" title="变量与方法"></a>变量与方法</h3><h4 id="成员变量与局部变量的区别有哪些"><a href="#成员变量与局部变量的区别有哪些" class="headerlink" title="成员变量与局部变量的区别有哪些"></a>成员变量与局部变量的区别有哪些</h4><p>变量：在程序执行的过程中，在某个范围内其值可以发生改变的量。从本质上讲，变量其实是内存中的一小块区域</p>
<p>成员变量：方法外部，类内部定义的变量</p>
<p>局部变量：类的方法中的变量。</p>
<p>成员变量和局部变量的区别</p>
<p><strong>作用域</strong></p>
<p>成员变量：针对整个类有效。<br>局部变量：只在某个范围内有效。(一般指的就是方法,语句体内)</p>
<p><strong>存储位置</strong></p>
<p>成员变量：随着对象的创建而存在，随着对象的消失而消失，存储在堆内存中。<br>局部变量：在方法被调用，或者语句被执行的时候存在，存储在栈内存中。当方法调用完，或者语句结束后，就自动释放。</p>
<p><strong>生命周期</strong></p>
<p>成员变量：随着对象的创建而存在，随着对象的消失而消失<br>局部变量：当方法调用完，或者语句结束后，就自动释放。</p>
<p><strong>初始值</strong></p>
<p>成员变量：有默认初始值。</p>
<p>局部变量：没有默认初始值，使用前必须赋值。</p>
<p>使用原则</p>
<p>在使用变量时需要遵循的原则为：就近原则<br>首先在局部范围找，有就使用；接着在成员位置找。</p>
<h4 id="在Java中定义一个不做事且没有参数的构造方法的作用"><a href="#在Java中定义一个不做事且没有参数的构造方法的作用" class="headerlink" title="在Java中定义一个不做事且没有参数的构造方法的作用"></a>在Java中定义一个不做事且没有参数的构造方法的作用</h4><p>Java程序在执行子类的构造方法之前，如果没有用super()来调用父类特定的构造方法，则会调用父类中“没有参数的构造方法”。因此，如果父类中只定义了有参数的构造方法，而在子类的构造方法中又没有用super()来调用父类中特定的构造方法，则编译时将发生错误，因为Java程序在父类中找不到没有参数的构造方法可供执行。解决办法是在父类里加上一个不做事且没有参数的构造方法。</p>
<h4 id="在调用子类构造方法之前会先调用父类没有参数的构造方法，其目的是？"><a href="#在调用子类构造方法之前会先调用父类没有参数的构造方法，其目的是？" class="headerlink" title="在调用子类构造方法之前会先调用父类没有参数的构造方法，其目的是？"></a>在调用子类构造方法之前会先调用父类没有参数的构造方法，其目的是？</h4><p>帮助子类做初始化工作。</p>
<h4 id="一个类的构造方法的作用是什么？若一个类没有声明构造方法，改程序能正确执行吗？为什么？"><a href="#一个类的构造方法的作用是什么？若一个类没有声明构造方法，改程序能正确执行吗？为什么？" class="headerlink" title="一个类的构造方法的作用是什么？若一个类没有声明构造方法，改程序能正确执行吗？为什么？"></a>一个类的构造方法的作用是什么？若一个类没有声明构造方法，改程序能正确执行吗？为什么？</h4><p>主要作用是完成对类对象的初始化工作。可以执行。因为一个类即使没有声明构造方法也会有默认的不带参数的构造方法。</p>
<h4 id="构造方法有哪些特性？"><a href="#构造方法有哪些特性？" class="headerlink" title="构造方法有哪些特性？"></a>构造方法有哪些特性？</h4><p>名字与类名相同；</p>
<p>没有返回值，但不能用void声明构造函数；</p>
<p>生成类的对象时自动执行，无需调用。</p>
<h4 id="静态变量和实例变量区别"><a href="#静态变量和实例变量区别" class="headerlink" title="静态变量和实例变量区别"></a>静态变量和实例变量区别</h4><p>静态变量： 静态变量由于不属于任何实例对象，属于类的，所以在内存中只会有一份，在类的加载过程中，JVM只为静态变量分配一次内存空间。</p>
<p>实例变量： 每次创建对象，都会为每个对象分配成员变量内存空间，实例变量是属于实例对象的，在内存中，创建几次对象，就有几份成员变量。</p>
<h4 id="静态变量与普通变量区别"><a href="#静态变量与普通变量区别" class="headerlink" title="静态变量与普通变量区别"></a>静态变量与普通变量区别</h4><p>static变量也称作静态变量，静态变量和非静态变量的区别是：静态变量被所有的对象所共享，在内存中只有一个副本，它当且仅当在类初次加载时会被初始化。而非静态变量是对象所拥有的，在创建对象的时候被初始化，存在多个副本，各个对象拥有的副本互不影响。</p>
<p>还有一点就是static成员变量的初始化顺序按照定义的顺序进行初始化。</p>
<h4 id="静态方法和实例方法有何不同？"><a href="#静态方法和实例方法有何不同？" class="headerlink" title="静态方法和实例方法有何不同？"></a>静态方法和实例方法有何不同？</h4><p>静态方法和实例方法的区别主要体现在两个方面：</p>
<ol>
<li><p>在外部调用静态方法时，可以使用”类名.方法名”的方式，也可以使用”对象名.方法名”的方式。而实例方法只有后面这种方式。也就是说，调用静态方法可以无需创建对象。</p>
</li>
<li><p>静态方法在访问本类的成员时，只允许访问静态成员（即静态成员变量和静态方法），而不允许访问实例成员变量和实例方法；实例方法则无此限制</p>
</li>
</ol>
<h4 id="在一个静态方法内调用一个非静态成员为什么是非法的？"><a href="#在一个静态方法内调用一个非静态成员为什么是非法的？" class="headerlink" title="在一个静态方法内调用一个非静态成员为什么是非法的？"></a>在一个静态方法内调用一个非静态成员为什么是非法的？</h4><p>由于静态方法可以不通过对象进行调用，因此在静态方法里，不能调用其他非静态变量，也不可以访问非静态变量成员。</p>
<h4 id="什么是方法的返回值？返回值的作用是什么？"><a href="#什么是方法的返回值？返回值的作用是什么？" class="headerlink" title="什么是方法的返回值？返回值的作用是什么？"></a>什么是方法的返回值？返回值的作用是什么？</h4><p>方法的返回值是指我们获取到的某个方法体中的代码执行后产生的结果！（前提是该方法可能产生结果）。返回值的作用:接收出结果，使得它可以用于其他的操作！</p>
<h3 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h3><h4 id="什么是内部类？"><a href="#什么是内部类？" class="headerlink" title="什么是内部类？"></a>什么是内部类？</h4><p>在Java中，可以将一个类的定义放在另外一个类的定义内部，这就是<strong>内部类</strong>。内部类本身就是类的一个属性，与其他属性定义方式一致。</p>
<h4 id="内部类的分类有哪些"><a href="#内部类的分类有哪些" class="headerlink" title="内部类的分类有哪些"></a>内部类的分类有哪些</h4><p>内部类可以分为四种：<strong>成员内部类、局部内部类、匿名内部类和静态内部类</strong>。</p>
<h4 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h4><p>定义在类内部的静态类，就是静态内部类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Outer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">radius</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">StaticInner</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">visit</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;visit outer static  variable:&quot;</span> + radius);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>静态内部类可以访问外部类所有的静态变量，而不可访问外部类的非静态变量；静态内部类的创建方式，<code>new 外部类.静态内部类()</code>，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Outer.<span class="type">StaticInner</span> <span class="variable">inner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer</span>.StaticInner();</span><br><span class="line">inner.visit();</span><br></pre></td></tr></table></figure>


<h4 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h4><p>定义在类内部，成员位置上的非静态类，就是成员内部类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Outer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span>  <span class="type">int</span> <span class="variable">radius</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span><span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">class</span> <span class="title class_">Inner</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">visit</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;visit outer static  variable:&quot;</span> + radius);</span><br><span class="line">            System.out.println(<span class="string">&quot;visit outer   variable:&quot;</span> + count);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>成员内部类可以访问外部类所有的变量和方法，包括静态和非静态，私有和公有。成员内部类依赖于外部类的实例，它的创建方式<code>外部类实例.new 内部类()</code>，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Outer</span> <span class="variable">outer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer</span>();</span><br><span class="line">Outer.<span class="type">Inner</span> <span class="variable">inner</span> <span class="operator">=</span> outer.<span class="keyword">new</span> <span class="title class_">Inner</span>();</span><br><span class="line">inner.visit();</span><br></pre></td></tr></table></figure>


<h4 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h4><p>定义在方法中的内部类，就是局部内部类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Outer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>  <span class="type">int</span> <span class="variable">out_a</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">STATIC_b</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testFunctionClass</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">inner_c</span> <span class="operator">=</span><span class="number">3</span>;</span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">Inner</span> &#123;</span><br><span class="line">            <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">fun</span><span class="params">()</span>&#123;</span><br><span class="line">                System.out.println(out_a);</span><br><span class="line">                System.out.println(STATIC_b);</span><br><span class="line">                System.out.println(inner_c);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Inner</span>  <span class="variable">inner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Inner</span>();</span><br><span class="line">        inner.fun();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testStaticFunctionClass</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">d</span> <span class="operator">=</span><span class="number">3</span>;</span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">Inner</span> &#123;</span><br><span class="line">            <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">fun</span><span class="params">()</span>&#123;</span><br><span class="line">                <span class="comment">// System.out.println(out_a); 编译错误，定义在静态方法中的局部类不可以访问外部类的实例变量</span></span><br><span class="line">                System.out.println(STATIC_b);</span><br><span class="line">                System.out.println(d);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Inner</span>  <span class="variable">inner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Inner</span>();</span><br><span class="line">        inner.fun();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>定义在实例方法中的局部类可以访问外部类的所有变量和方法，定义在静态方法中的局部类只能访问外部类的静态变量和方法。局部内部类的创建方式，在对应方法内，<code>new 内部类()</code>，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testStaticFunctionClass</span><span class="params">()</span>&#123;</span><br><span class="line">   <span class="keyword">class</span> <span class="title class_">Inner</span> &#123;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="type">Inner</span>  <span class="variable">inner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Inner</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h4><p>匿名内部类就是没有名字的内部类，日常开发中使用的比较多。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Outer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(<span class="keyword">final</span> <span class="type">int</span> i)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Service</span>() &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;匿名内部类&quot;</span> );</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.method();</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">//匿名内部类必须继承或实现一个已有的接口 </span></span><br><span class="line"> <span class="keyword">interface</span> <span class="title class_">Service</span>&#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>除了没有名字，匿名内部类还有以下特点：</p>
<ul>
<li><p>匿名内部类必须继承一个抽象类或者实现一个接口。</p>
</li>
<li><p>匿名内部类不能定义任何静态成员和静态方法。</p>
</li>
<li><p>当所在的方法的形参需要被匿名内部类使用时，必须声明为 final。</p>
</li>
<li><p>匿名内部类不能是抽象的，它必须要实现继承的类或者实现的接口的所有抽象方法。</p>
</li>
</ul>
<p>匿名内部类创建方式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> 类/接口&#123; </span><br><span class="line">  <span class="comment">//匿名内部类实现部分</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="内部类的优点"><a href="#内部类的优点" class="headerlink" title="内部类的优点"></a>内部类的优点</h4><p>我们为什么要使用内部类呢？因为它有以下优点：</p>
<ul>
<li><p>一个内部类对象可以访问创建它的外部类对象的内容，包括私有数据！</p>
</li>
<li><p>内部类不为同一包的其他类所见，具有很好的封装性；</p>
</li>
<li><p>内部类有效实现了“多重继承”，优化 java 单继承的缺陷。</p>
</li>
<li><p>匿名内部类可以很方便的定义回调。</p>
</li>
</ul>
<h4 id="内部类有哪些应用场景"><a href="#内部类有哪些应用场景" class="headerlink" title="内部类有哪些应用场景"></a>内部类有哪些应用场景</h4><ol start="3">
<li><p>一些多算法场合</p>
</li>
<li><p>解决一些非面向对象的语句块。</p>
</li>
<li><p>适当使用内部类，使得代码更加灵活和富有扩展性。</p>
</li>
<li><p>当某个类除了它的外部类，不再被其他的类使用时。</p>
</li>
</ol>
<h4 id="局部内部类和匿名内部类访问局部变量的时候，为什么变量必须要加上final？"><a href="#局部内部类和匿名内部类访问局部变量的时候，为什么变量必须要加上final？" class="headerlink" title="局部内部类和匿名内部类访问局部变量的时候，为什么变量必须要加上final？"></a>局部内部类和匿名内部类访问局部变量的时候，为什么变量必须要加上final？</h4><p>局部内部类和匿名内部类访问局部变量的时候，为什么变量必须要加上final呢？它内部原理是什么呢？</p>
<p>先看这段代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Outer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">outMethod</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span><span class="number">10</span>;</span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">Inner</span> &#123;</span><br><span class="line">            <span class="keyword">void</span> <span class="title function_">innerMethod</span><span class="params">()</span>&#123;</span><br><span class="line">                System.out.println(a);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>以上例子，为什么要加final呢？是因为<strong>生命周期不一致</strong>， 局部变量直接存储在栈中，当方法执行结束后，非final的局部变量就被销毁。而局部内部类对局部变量的引用依然存在，如果局部内部类要调用局部变量时，就会出错。加了final，可以确保局部内部类使用的变量与外层的局部变量区分开，解决了这个问题。</p>
<h4 id="内部类相关，看程序说出运行结果"><a href="#内部类相关，看程序说出运行结果" class="headerlink" title="内部类相关，看程序说出运行结果"></a>内部类相关，看程序说出运行结果</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Outer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> <span class="number">12</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Inner</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> <span class="number">13</span>;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> <span class="number">14</span>;</span><br><span class="line">            System.out.println(<span class="string">&quot;局部变量：&quot;</span> + age);</span><br><span class="line">            System.out.println(<span class="string">&quot;内部类变量：&quot;</span> + <span class="built_in">this</span>.age);</span><br><span class="line">            System.out.println(<span class="string">&quot;外部类变量：&quot;</span> + Outer.<span class="built_in">this</span>.age);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Outer.<span class="type">Inner</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer</span>().<span class="keyword">new</span> <span class="title class_">Inner</span>();</span><br><span class="line">        in.print();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>运行结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">局部变量：<span class="number">14</span></span><br><span class="line">内部类变量：<span class="number">13</span></span><br><span class="line">外部类变量：<span class="number">12</span></span><br></pre></td></tr></table></figure>


<h3 id="重写与重载"><a href="#重写与重载" class="headerlink" title="重写与重载"></a>重写与重载</h3><h4 id="构造器（constructor）是否可被重写（override）"><a href="#构造器（constructor）是否可被重写（override）" class="headerlink" title="构造器（constructor）是否可被重写（override）"></a>构造器（constructor）是否可被重写（override）</h4><p>构造器不能被继承，因此不能被重写，但可以被重载。</p>
<h4 id="重载（Overload）和重写（Override）的区别。重载的方法能否根据返回类型进行区分？"><a href="#重载（Overload）和重写（Override）的区别。重载的方法能否根据返回类型进行区分？" class="headerlink" title="重载（Overload）和重写（Override）的区别。重载的方法能否根据返回类型进行区分？"></a>重载（Overload）和重写（Override）的区别。重载的方法能否根据返回类型进行区分？</h4><p>方法的重载和重写都是实现多态的方式，区别在于前者实现的是编译时的多态性，而后者实现的是运行时的多态性。</p>
<p>重载：发生在同一个类中，方法名相同参数列表不同（参数类型不同、个数不同、顺序不同），与方法返回值和访问修饰符无关，即重载的方法不能根据返回类型进行区分</p>
<p>重写：发生在父子类中，方法名、参数列表必须相同，返回值小于等于父类，抛出的异常小于等于父类，访问修饰符大于等于父类（里氏代换原则）；如果父类方法访问修饰符为private则子类中就不是重写。</p>
<h3 id="对象相等判断"><a href="#对象相等判断" class="headerlink" title="对象相等判断"></a>对象相等判断</h3><h4 id="和-equals-的区别是什么"><a href="#和-equals-的区别是什么" class="headerlink" title="&#x3D;&#x3D; 和 equals 的区别是什么"></a>&#x3D;&#x3D; 和 equals 的区别是什么</h4><p><strong>&#x3D;&#x3D;</strong> : 它的作用是判断两个对象的地址是不是相等。即，判断两个对象是不是同一个对象。(基本数据类型 &#x3D;&#x3D; 比较的是值，引用数据类型 &#x3D;&#x3D; 比较的是内存地址)</p>
<p><strong>equals()</strong> : 它的作用也是判断两个对象是否相等。但它一般有两种使用情况：</p>
<p>情况1：类没有覆盖 equals() 方法。则通过 equals() 比较该类的两个对象时，等价于通过“&#x3D;&#x3D;”比较这两个对象。</p>
<p>情况2：类覆盖了 equals() 方法。一般，我们都覆盖 equals() 方法来两个对象的内容相等；若它们的内容相等，则返回 true (即，认为这两个对象相等)。</p>
<p><strong>举个例子：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;ab&quot;</span>); <span class="comment">// a 为一个引用</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;ab&quot;</span>); <span class="comment">// b为另一个引用,对象的内容一样</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">aa</span> <span class="operator">=</span> <span class="string">&quot;ab&quot;</span>; <span class="comment">// 放在常量池中</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">bb</span> <span class="operator">=</span> <span class="string">&quot;ab&quot;</span>; <span class="comment">// 从常量池中查找</span></span><br><span class="line">        <span class="keyword">if</span> (aa == bb) <span class="comment">// true</span></span><br><span class="line">            System.out.println(<span class="string">&quot;aa==bb&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (a == b) <span class="comment">// false，非同一对象</span></span><br><span class="line">            System.out.println(<span class="string">&quot;a==b&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (a.equals(b)) <span class="comment">// true</span></span><br><span class="line">            System.out.println(<span class="string">&quot;aEQb&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">42</span> == <span class="number">42.0</span>) &#123; <span class="comment">// true</span></span><br><span class="line">            System.out.println(<span class="string">&quot;true&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><strong>说明：</strong></p>
<ul>
<li><p>String中的equals方法是被重写过的，因为object的equals方法是比较的对象的内存地址，而String的equals方法比较的是对象的值。</p>
</li>
<li><p>当创建String类型的对象时，虚拟机会在常量池中查找有没有已经存在的值和要创建的值相同的对象，如果有就把它赋给当前引用。如果没有就在常量池中重新创建一个String对象。</p>
</li>
</ul>
<h4 id="hashCode-与-equals-重要"><a href="#hashCode-与-equals-重要" class="headerlink" title="hashCode 与 equals (重要)"></a>hashCode 与 equals (重要)</h4><p>HashSet如何检查重复</p>
<p>两个对象的 hashCode() 相同，则 equals() 也一定为 true，对吗？</p>
<p>hashCode和equals方法的关系</p>
<p>面试官可能会问你：“你重写过 hashcode 和 equals 么，为什么重写equals时必须重写hashCode方法？”</p>
<p><strong>hashCode()介绍</strong></p>
<p>hashCode() 的作用是获取哈希码，也称为散列码；它实际上是返回一个int整数。这个哈希码的作用是确定该对象在哈希表中的索引位置。hashCode() 定义在JDK的Object.java中，这就意味着Java中的任何类都包含有hashCode()函数。</p>
<p>散列表存储的是键值对(key-value)，它的特点是：能根据“键”快速的检索出对应的“值”。这其中就利用到了散列码！（可以快速找到所需要的对象）</p>
<p><strong>为什么要有 hashCode</strong></p>
<p><strong>我们以“HashSet 如何检查重复”为例子来说明为什么要有 hashCode</strong>：</p>
<p>当你把对象加入 HashSet 时，HashSet 会先计算对象的 hashcode 值来判断对象加入的位置，同时也会与其他已经加入的对象的 hashcode 值作比较，如果没有相符的hashcode，HashSet会假设对象没有重复出现。但是如果发现有相同 hashcode 值的对象，这时会调用 equals()方法来检查 hashcode 相等的对象是否真的相同。如果两者相同，HashSet 就不会让其加入操作成功。如果不同的话，就会重新散列到其他位置。（摘自我的Java启蒙书《Head first java》第二版）。这样我们就大大减少了 equals 的次数，相应就大大提高了执行速度。</p>
<p><strong>hashCode()与equals()的相关规定</strong></p>
<p>如果两个对象相等，则hashcode一定也是相同的</p>
<p>两个对象相等，对两个对象分别调用equals方法都返回true</p>
<p>两个对象有相同的hashcode值，它们也不一定是相等的</p>
<p><strong>因此，equals 方法被覆盖过，则 hashCode 方法也必须被覆盖</strong></p>
<p>hashCode() 的默认行为是对堆上的对象产生独特值。如果没有重写 hashCode()，则该 class 的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）</p>
<h4 id="对象的相等与指向他们的引用相等，两者有什么不同？"><a href="#对象的相等与指向他们的引用相等，两者有什么不同？" class="headerlink" title="对象的相等与指向他们的引用相等，两者有什么不同？"></a>对象的相等与指向他们的引用相等，两者有什么不同？</h4><p>对象的相等 比的是内存中存放的内容是否相等而 引用相等 比较的是他们指向的内存地址是否相等。</p>
<h3 id="值传递"><a href="#值传递" class="headerlink" title="值传递"></a>值传递</h3><h4 id="当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递"><a href="#当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递" class="headerlink" title="当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递"></a>当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递</h4><p>是值传递。Java 语言的方法调用只支持参数的值传递。当一个对象实例作为一个参数被传递到方法中时，参数的值就是对该对象的引用。对象的属性可以在被调用过程中被改变，但对对象引用的改变是不会影响到调用者的</p>
<h4 id="为什么-Java-中只有值传递"><a href="#为什么-Java-中只有值传递" class="headerlink" title="为什么 Java 中只有值传递"></a>为什么 Java 中只有值传递</h4><p>首先回顾一下在程序设计语言中有关将参数传递给方法（或函数）的一些专业术语。<strong>按值调用(call by value)表示方法接收的是调用者提供的值，而按引用调用（call by reference)表示方法接收的是调用者提供的变量地址。一个方法可以修改传递引用所对应的变量值，而不能修改传递值调用所对应的变量值。</strong> 它用来描述各种程序设计语言（不只是Java)中方法参数传递方式。</p>
<p><strong>Java程序设计语言总是采用按值调用。也就是说，方法得到的是所有参数值的一个拷贝，也就是说，方法不能修改传递给它的任何参数变量的内容。</strong></p>
<p><strong>下面通过 3 个例子来给大家说明</strong></p>
<p>example 1</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">num1</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">num2</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    swap(num1, num2);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;num1 = &quot;</span> + num1);</span><br><span class="line">    System.out.println(<span class="string">&quot;num2 = &quot;</span> + num2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;a = &quot;</span> + a);</span><br><span class="line">    System.out.println(<span class="string">&quot;b = &quot;</span> + b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><strong>结果</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">a = <span class="number">20</span></span><br><span class="line">b = <span class="number">10</span></span><br><span class="line">num1 = <span class="number">10</span></span><br><span class="line">num2 = <span class="number">20</span></span><br></pre></td></tr></table></figure>


<p><strong>解析</strong>：</p>
<img data-src="/2022/10/01/technology/java/java_basic/image_3.png" class="" title="image.png">

<p>在swap方法中，a、b的值进行交换，并不会影响到 num1、num2。因为，a、b中的值，只是从 num1、num2 的复制过来的。也就是说，a、b相当于num1、num2 的副本，副本的内容无论怎么修改，都不会影响到原件本身。</p>
<p><strong>通过上面例子，我们已经知道了一个方法不能修改一个基本数据类型的参数，而对象引用作为参数就不一样，请看 example2.</strong></p>
<p>example 2</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] arr = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br><span class="line">    System.out.println(arr[<span class="number">0</span>]);</span><br><span class="line">    change(arr);</span><br><span class="line">    System.out.println(arr[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">change</span><span class="params">(<span class="type">int</span>[] array)</span> &#123;</span><br><span class="line">    <span class="comment">// 将数组的第一个元素变为0</span></span><br><span class="line">    array[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><strong>结果</strong>：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">0</span></span><br></pre></td></tr></table></figure>


<p><strong>解析</strong>：</p>
<img data-src="/2022/10/01/technology/java/java_basic/image_4.png" class="" title="image.png">

<p>array 被初始化 arr 的拷贝也就是一个对象的引用，也就是说 array 和 arr 指向的时同一个数组对象。 因此，外部对引用对象的改变会反映到所对应的对象上。</p>
<p><strong>通过 example2 我们已经看到，实现一个改变对象参数状态的方法并不是一件难事。理由很简单，方法得到的是对象引用的拷贝，对象引用及其他的拷贝同时引用同一个对象。</strong></p>
<p><strong>很多程序设计语言（特别是，C++和Pascal)提供了两种参数传递的方式：值调用和引用调用。有些程序员（甚至本书的作者）认为Java程序设计语言对对象采用的是引用调用，实际上，这种理解是不对的。由于这种误解具有一定的普遍性，所以下面给出一个反例来详细地阐述一下这个问题。</strong></p>
<p>example 3</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        <span class="type">Student</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;小张&quot;</span>);</span><br><span class="line">        <span class="type">Student</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;小李&quot;</span>);</span><br><span class="line">        Test.swap(s1, s2);</span><br><span class="line">        System.out.println(<span class="string">&quot;s1:&quot;</span> + s1.getName());</span><br><span class="line">        System.out.println(<span class="string">&quot;s2:&quot;</span> + s2.getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(Student x, Student y)</span> &#123;</span><br><span class="line">        <span class="type">Student</span> <span class="variable">temp</span> <span class="operator">=</span> x;</span><br><span class="line">        x = y;</span><br><span class="line">        y = temp;</span><br><span class="line">        System.out.println(<span class="string">&quot;x:&quot;</span> + x.getName());</span><br><span class="line">        System.out.println(<span class="string">&quot;y:&quot;</span> + y.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>结果</strong>：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="attr">x</span>:小李</span><br><span class="line"><span class="attr">y</span>:小张</span><br><span class="line"><span class="attr">s1</span>:小张</span><br><span class="line"><span class="attr">s2</span>:小李</span><br></pre></td></tr></table></figure>


<p><strong>解析</strong>：</p>
<p>交换之前：</p>
<img data-src="/2022/10/01/technology/java/java_basic/image_5.png" class="" title="image.png">

<p>交换之后：</p>
<img data-src="/2022/10/01/technology/java/java_basic/image_6.png" class="" title="image.png">

<p>通过上面两张图可以很清晰的看出： <strong>方法并没有改变存储在变量 s1 和 s2 中的对象引用。swap方法的参数x和y被初始化为两个对象引用的拷贝，这个方法交换的是这两个拷贝</strong></p>
<p><strong>总结</strong></p>
<p>Java程序设计语言对对象采用的不是引用调用，实际上，对象引用是按值传递的。</p>
<p>下面再总结一下Java中方法参数的使用情况：</p>
<ul>
<li><p>一个方法不能修改一个基本数据类型的参数（即数值型或布尔型》</p>
</li>
<li><p>一个方法可以改变一个对象参数的状态。</p>
</li>
<li><p>一个方法不能让对象参数引用一个新的对象。</p>
</li>
</ul>
<h4 id="值传递和引用传递有什么区别"><a href="#值传递和引用传递有什么区别" class="headerlink" title="值传递和引用传递有什么区别"></a>值传递和引用传递有什么区别</h4><p>值传递：指的是在方法调用时，传递的参数是按值的拷贝传递，传递的是值的拷贝，也就是说传递后就互不相关了。</p>
<p>引用传递：指的是在方法调用时，传递的参数是按引用进行传递，其实传递的引用的地址，也就是变量所对应的内存空间的地址。传递的是值的引用，也就是说传递前和传递后都指向同一个引用（也就是同一个内存空间）。</p>
<h3 id="Java包"><a href="#Java包" class="headerlink" title="Java包"></a>Java包</h3><h4 id="JDK-中常用的包有哪些"><a href="#JDK-中常用的包有哪些" class="headerlink" title="JDK 中常用的包有哪些"></a>JDK 中常用的包有哪些</h4><ul>
<li><p>java.lang：这个是系统的基础类；</p>
</li>
<li><p>java.io：这里面是所有输入输出有关的类，比如文件操作等；</p>
</li>
<li><p>java.nio：为了完善 io 包中的功能，提高 io 包中性能而写的一个新包；</p>
</li>
<li><p>java.net：这里面是与网络有关的类；</p>
</li>
<li><p>java.util：这个是系统辅助类，特别是集合类；</p>
</li>
<li><p>java.sql：这个是数据库操作的类。</p>
</li>
</ul>
<h4 id="import-java和javax有什么区别"><a href="#import-java和javax有什么区别" class="headerlink" title="import java和javax有什么区别"></a>import java和javax有什么区别</h4><p>刚开始的时候 JavaAPI 所必需的包是 java 开头的包，javax 当时只是扩展 API 包来说使用。然而随着时间的推移，javax 逐渐的扩展成为 Java API 的组成部分。但是，将扩展从 javax 包移动到 java 包将是太麻烦了，最终会破坏一堆现有的代码。因此，最终决定 javax 包将成为标准API的一部分。</p>
<p>所以，实际上java和javax没有区别。这都是一个名字。</p>
<h2 id="IO流"><a href="#IO流" class="headerlink" title="IO流"></a>IO流</h2><h3 id="java-中-IO-流分为几种"><a href="#java-中-IO-流分为几种" class="headerlink" title="java 中 IO 流分为几种?"></a>java 中 IO 流分为几种?</h3><ul>
<li><p>按照流的流向分，可以分为输入流和输出流；</p>
</li>
<li><p>按照操作单元划分，可以划分为字节流和字符流；</p>
</li>
<li><p>按照流的角色划分为节点流和处理流。</p>
</li>
</ul>
<p>Java Io流共涉及40多个类，这些类看上去很杂乱，但实际上很有规则，而且彼此之间存在非常紧密的联系， Java I0流的40多个类都是从如下4个抽象类基类中派生出来的。</p>
<ul>
<li><p>InputStream&#x2F;Reader: 所有的输入流的基类，前者是字节输入流，后者是字符输入流。</p>
</li>
<li><p>OutputStream&#x2F;Writer: 所有输出流的基类，前者是字节输出流，后者是字符输出流。</p>
</li>
</ul>
<p>按操作方式分类结构图：</p>
<img data-src="/2022/10/01/technology/java/java_basic/image_7.png" class="" title="image.png">

<p>按操作对象分类结构图：</p>
<img data-src="/2022/10/01/technology/java/java_basic/image_8.png" class="" title="image.png">

<h3 id="BIO-NIO-AIO-有什么区别"><a href="#BIO-NIO-AIO-有什么区别" class="headerlink" title="BIO,NIO,AIO 有什么区别?"></a>BIO,NIO,AIO 有什么区别?</h3><p>简答</p>
<ul>
<li><p>BIO：Block IO 同步阻塞式 IO，就是我们平常使用的传统 IO，它的特点是模式简单使用方便，并发处理能力低。</p>
</li>
<li><p>NIO：Non IO 同步非阻塞 IO，是传统 IO 的升级，客户端和服务器端通过 Channel（通道）通讯，实现了多路复用。</p>
</li>
<li><p>AIO：Asynchronous IO 是 NIO 的升级，也叫 NIO2，实现了异步非堵塞 IO ，异步 IO 的操作基于事件和回调机制。</p>
</li>
</ul>
<p>详细回答</p>
<ul>
<li><p><strong>BIO (Blocking I&#x2F;O):</strong> 同步阻塞I&#x2F;O模式，数据的读取写入必须阻塞在一个线程内等待其完成。在活动连接数不是特别高（小于单机1000）的情况下，这种模型是比较不错的，可以让每一个连接专注于自己的 I&#x2F;O 并且编程模型简单，也不用过多考虑系统的过载、限流等问题。线程池本身就是一个天然的漏斗，可以缓冲一些系统处理不了的连接或请求。但是，当面对十万甚至百万级连接的时候，传统的 BIO 模型是无能为力的。因此，我们需要一种更高效的 I&#x2F;O 处理模型来应对更高的并发量。</p>
</li>
<li><p><strong>NIO (New I&#x2F;O):</strong> NIO是一种同步非阻塞的I&#x2F;O模型，在Java 1.4 中引入了NIO框架，对应 java.nio 包，提供了 Channel , Selector，Buffer等抽象。NIO中的N可以理解为Non-blocking，不单纯是New。它支持面向缓冲的，基于通道的I&#x2F;O操作方法。 NIO提供了与传统BIO模型中的 <code>Socket</code> 和 <code>ServerSocket</code> 相对应的 <code>SocketChannel</code> 和 <code>ServerSocketChannel</code> 两种不同的套接字通道实现,两种通道都支持阻塞和非阻塞两种模式。阻塞模式使用就像传统中的支持一样，比较简单，但是性能和可靠性都不好；非阻塞模式正好与之相反。对于低负载、低并发的应用程序，可以使用同步阻塞I&#x2F;O来提升开发速率和更好的维护性；对于高负载、高并发的（网络）应用，应使用 NIO 的非阻塞模式来开发</p>
</li>
<li><p><strong>AIO (Asynchronous I&#x2F;O):</strong> AIO 也就是 NIO 2。在 Java 7 中引入了 NIO 的改进版 NIO 2,它是异步非阻塞的IO模型。异步 IO 是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。AIO 是异步IO的缩写，虽然 NIO 在网络操作中，提供了非阻塞的方法，但是 NIO 的 IO 行为还是同步的。对于 NIO 来说，我们的业务线程是在 IO 操作准备好时，得到通知，接着就由这个线程自行进行 IO 操作，IO操作本身是同步的。查阅网上相关资料，我发现就目前来说 AIO 的应用还不是很广泛，Netty 之前也尝试使用过 AIO，不过又放弃了。</p>
</li>
</ul>
<h3 id="Files的常用方法都有哪些？"><a href="#Files的常用方法都有哪些？" class="headerlink" title="Files的常用方法都有哪些？"></a>Files的常用方法都有哪些？</h3><ul>
<li><p>Files. exists()：检测文件路径是否存在。</p>
</li>
<li><p>Files. createFile()：创建文件。</p>
</li>
<li><p>Files. createDirectory()：创建文件夹。</p>
</li>
<li><p>Files. delete()：删除一个文件或目录。</p>
</li>
<li><p>Files. copy()：复制文件。</p>
</li>
<li><p>Files. move()：移动文件。</p>
</li>
<li><p>Files. size()：查看文件个数。</p>
</li>
<li><p>Files. read()：读取文件。</p>
</li>
<li><p>Files. write()：写入文件。</p>
</li>
</ul>
<h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><h3 id="什么是反射机制？"><a href="#什么是反射机制？" class="headerlink" title="什么是反射机制？"></a>什么是反射机制？</h3><p>JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。</p>
<p>静态编译和动态编译</p>
<ul>
<li><p><strong>静态编译：</strong>在编译时确定类型，绑定对象</p>
</li>
<li><p><strong>动态编译：</strong>运行时确定类型，绑定对象</p>
</li>
</ul>
<h3 id="反射机制优缺点"><a href="#反射机制优缺点" class="headerlink" title="反射机制优缺点"></a>反射机制优缺点</h3><ul>
<li><p><strong>优点：</strong> 运行期类型的判断，动态加载类，提高代码灵活度。</p>
</li>
<li><p><strong>缺点：</strong> 性能瓶颈：反射相当于一系列解释操作，通知 JVM 要做的事情，性能比直接的java代码要慢很多。</p>
</li>
</ul>
<h3 id="反射机制的应用场景有哪些？"><a href="#反射机制的应用场景有哪些？" class="headerlink" title="反射机制的应用场景有哪些？"></a>反射机制的应用场景有哪些？</h3><p>反射是框架设计的灵魂。</p>
<p>在我们平时的项目开发过程中，基本上很少会直接使用到反射机制，但这不能说明反射机制没有用，实际上有很多设计、开发都与反射机制有关，例如模块化的开发，通过反射去调用对应的字节码；动态代理设计模式也采用了反射机制，还有我们日常使用的 Spring／Hibernate 等框架也大量使用到了反射机制。</p>
<p>举例：①我们在使用JDBC连接数据库时使用Class.forName()通过反射加载数据库的驱动程序；②Spring框架也用到很多反射机制，最经典的就是xml的配置模式。Spring 通过 XML 配置模式装载 Bean 的过程：1) 将程序内所有 XML 或 Properties 配置文件加载入内存中; 2)Java类里面解析xml或properties里面的内容，得到对应实体类的字节码字符串以及相关的属性信息; 3)使用反射机制，根据这个字符串获得某个类的Class实例; 4)动态配置实例的属性</p>
<h3 id="Java获取反射的三种方法"><a href="#Java获取反射的三种方法" class="headerlink" title="Java获取反射的三种方法"></a>Java获取反射的三种方法</h3><p>1.通过new对象实现反射机制 2.通过路径实现反射机制 3.通过类名实现反射机制</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">protected</span> <span class="type">boolean</span> sex;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">float</span> score;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Get</span> &#123;</span><br><span class="line">    <span class="comment">//获取反射机制三种方式</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="comment">//方式一(通过建立对象)</span></span><br><span class="line">        <span class="type">Student</span> <span class="variable">stu</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">        <span class="type">Class</span> <span class="variable">classobj1</span> <span class="operator">=</span> stu.getClass();</span><br><span class="line">        System.out.println(classobj1.getName());</span><br><span class="line">        <span class="comment">//方式二（所在通过路径-相对路径）</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">classobj2</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;fanshe.Student&quot;</span>);</span><br><span class="line">        System.out.println(classobj2.getName());</span><br><span class="line">        <span class="comment">//方式三（通过类名）</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">classobj3</span> <span class="operator">=</span> Student.class;</span><br><span class="line">        System.out.println(classobj3.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h2><p>网络编程的面试题可以查看我的这篇文章<a href="https://blog.csdn.net/ThinkWon/article/details/104903925">重学TCP&#x2F;IP协议和三次握手四次挥手</a>，内容不仅包括TCP&#x2F;IP协议和三次握手四次挥手的知识，还包括计算机网络体系结构，HTTP协议，get请求和post请求区别，session和cookie的区别等，欢迎大家阅读。</p>
<h2 id="常用API"><a href="#常用API" class="headerlink" title="常用API"></a>常用API</h2><h3 id="String相关"><a href="#String相关" class="headerlink" title="String相关"></a>String相关</h3><h4 id="字符型常量和字符串常量的区别"><a href="#字符型常量和字符串常量的区别" class="headerlink" title="字符型常量和字符串常量的区别"></a>字符型常量和字符串常量的区别</h4><ol>
<li><p>形式上: 字符常量是单引号引起的一个字符 字符串常量是双引号引起的若干个字符</p>
</li>
<li><p>含义上: 字符常量相当于一个整形值(ASCII值),可以参加表达式运算 字符串常量代表一个地址值(该字符串在内存中存放位置)</p>
</li>
<li><p>占内存大小 字符常量只占两个字节 字符串常量占若干个字节(至少一个字符结束标志)</p>
</li>
</ol>
<h4 id="什么是字符串常量池？"><a href="#什么是字符串常量池？" class="headerlink" title="什么是字符串常量池？"></a>什么是字符串常量池？</h4><p>字符串常量池位于堆内存中，专门用来存储字符串常量，可以提高内存的使用率，避免开辟多块空间存储相同的字符串，在创建字符串时 JVM 会首先检查字符串常量池，如果该字符串已经存在池中，则返回它的引用，如果不存在，则实例化一个字符串放到池中，并返回其引用。</p>
<h4 id="String-是最基本的数据类型吗"><a href="#String-是最基本的数据类型吗" class="headerlink" title="String 是最基本的数据类型吗"></a>String 是最基本的数据类型吗</h4><p>不是。Java 中的基本数据类型只有 8 个 ：byte、short、int、long、float、double、char、boolean；除了基本类型（primitive type），剩下的都是引用类型（referencetype），Java 5 以后引入的枚举类型也算是一种比较特殊的引用类型。</p>
<p>这是很基础的东西，但是很多初学者却容易忽视，Java 的 8 种基本数据类型中不包括 String，基本数据类型中用来描述文本数据的是 char，但是它只能表示单个字符，比如 ‘a’,‘好’ 之类的，如果要描述一段文本，就需要用多个 char 类型的变量，也就是一个 char 类型数组，比如“你好” 就是长度为2的数组 char[] chars &#x3D; {‘你’,‘好’};</p>
<p>但是使用数组过于麻烦，所以就有了 String，String 底层就是一个 char 类型的数组，只是使用的时候开发者不需要直接操作底层数组，用更加简便的方式即可完成对字符串的使用。</p>
<h4 id="String有哪些特性"><a href="#String有哪些特性" class="headerlink" title="String有哪些特性"></a>String有哪些特性</h4><ul>
<li><p>不变性：String 是只读字符串，是一个典型的 immutable 对象，对它进行任何操作，其实都是创建一个新的对象，再把引用指向该对象。不变模式的主要作用在于当一个对象需要被多线程共享并频繁访问时，可以保证数据的一致性。</p>
</li>
<li><p>常量池优化：String 对象创建之后，会在字符串常量池中进行缓存，如果下次创建同样的对象时，会直接返回缓存的引用。</p>
</li>
<li><p>final：使用 final 来定义 String 类，表示 String 类不能被继承，提高了系统的安全性。</p>
</li>
</ul>
<h4 id="String为什么是不可变的吗？"><a href="#String为什么是不可变的吗？" class="headerlink" title="String为什么是不可变的吗？"></a>String为什么是不可变的吗？</h4><p>简单来说就是String类利用了final修饰的char类型数组存储字符，源码如下图所以：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** The value is used for character storage. */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">char</span> value[];</span><br><span class="line"></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure>


<h4 id="String真的是不可变的吗？"><a href="#String真的是不可变的吗？" class="headerlink" title="String真的是不可变的吗？"></a>String真的是不可变的吗？</h4><p>我觉得如果别人问这个问题的话，回答不可变就可以了。 下面只是给大家看两个有代表性的例子：</p>
<p><strong>1) String不可变但不代表引用不可以变</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">str = str + <span class="string">&quot; World&quot;</span>;</span><br><span class="line">System.out.println(<span class="string">&quot;str=&quot;</span> + str);</span><br></pre></td></tr></table></figure>


<p>结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">str=Hello World</span><br></pre></td></tr></table></figure>


<p>解析：</p>
<p>实际上，原来String的内容是不变的，只是str由原来指向”Hello”的内存地址转为指向”Hello World”的内存地址而已，也就是说多开辟了一块内存区域给”Hello World”字符串。</p>
<p><strong>2) 通过反射是可以修改所谓的“不可变”对象</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建字符串&quot;Hello World&quot;， 并赋给引用s</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;Hello World&quot;</span>;</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;s = &quot;</span> + s); <span class="comment">// Hello World</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取String类中的value字段</span></span><br><span class="line"><span class="type">Field</span> <span class="variable">valueFieldOfString</span> <span class="operator">=</span> String.class.getDeclaredField(<span class="string">&quot;value&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 改变value属性的访问权限</span></span><br><span class="line">valueFieldOfString.setAccessible(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取s对象上的value属性的值</span></span><br><span class="line"><span class="type">char</span>[] value = (<span class="type">char</span>[]) valueFieldOfString.get(s);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 改变value所引用的数组中的第5个字符</span></span><br><span class="line">value[<span class="number">5</span>] = <span class="string">&#x27;_&#x27;</span>;</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;s = &quot;</span> + s); <span class="comment">// Hello_World</span></span><br></pre></td></tr></table></figure>


<p>结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">s = Hello <span class="type">World</span></span><br><span class="line"><span class="variable">s</span> <span class="operator">=</span> Hello_World</span><br></pre></td></tr></table></figure>


<p>解析：</p>
<p>用反射可以访问私有成员， 然后反射出String对象中的value属性， 进而改变通过获得的value引用改变数组的结构。但是一般我们不会这么做，这里只是简单提一下有这个东西。</p>
<h4 id="是否可以继承-String-类"><a href="#是否可以继承-String-类" class="headerlink" title="是否可以继承 String 类"></a>是否可以继承 String 类</h4><p>String 类是 final 类，不可以被继承。</p>
<h4 id="String-str-”i”与-String-str-new-String-“i”-一样吗？"><a href="#String-str-”i”与-String-str-new-String-“i”-一样吗？" class="headerlink" title="String str&#x3D;”i”与 String str&#x3D;new String(“i”)一样吗？"></a>String str&#x3D;”i”与 String str&#x3D;new String(“i”)一样吗？</h4><p>不一样，因为内存的分配方式不一样。String str&#x3D;”i”的方式，java 虚拟机会将其分配到常量池中；而 String str&#x3D;new String(“i”) 则会被分到堆内存中。</p>
<h4 id="String-s-new-String-“xyz”-创建了几个字符串对象"><a href="#String-s-new-String-“xyz”-创建了几个字符串对象" class="headerlink" title="String s &#x3D; new String(“xyz”);创建了几个字符串对象"></a>String s &#x3D; new String(“xyz”);创建了几个字符串对象</h4><p>两个对象，一个是静态区的”xyz”，一个是用new创建在堆上的对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>; <span class="comment">//str1指向静态区</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;hello&quot;</span>);  <span class="comment">//str2指向堆上的对象</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str3</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">str4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">System.out.println(str1.equals(str2)); <span class="comment">//true</span></span><br><span class="line">System.out.println(str2.equals(str4)); <span class="comment">//true</span></span><br><span class="line">System.out.println(str1 == str3); <span class="comment">//true</span></span><br><span class="line">System.out.println(str1 == str2); <span class="comment">//false</span></span><br><span class="line">System.out.println(str2 == str4); <span class="comment">//false</span></span><br><span class="line">System.out.println(str2 == <span class="string">&quot;hello&quot;</span>); <span class="comment">//false</span></span><br><span class="line">str2 = str1;</span><br><span class="line">System.out.println(str2 == <span class="string">&quot;hello&quot;</span>); <span class="comment">//true</span></span><br></pre></td></tr></table></figure>


<h4 id="如何将字符串反转？"><a href="#如何将字符串反转？" class="headerlink" title="如何将字符串反转？"></a>如何将字符串反转？</h4><p>使用 StringBuilder 或者 stringBuffer 的 reverse() 方法。</p>
<p>示例代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// StringBuffer reverse</span></span><br><span class="line"><span class="type">StringBuffer</span> <span class="variable">stringBuffer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">stringBuffer. append(<span class="string">&quot;abcdefg&quot;</span>);</span><br><span class="line">System. out. println(stringBuffer. reverse()); <span class="comment">// gfedcba</span></span><br><span class="line"><span class="comment">// StringBuilder reverse</span></span><br><span class="line"><span class="type">StringBuilder</span> <span class="variable">stringBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">stringBuilder. append(<span class="string">&quot;abcdefg&quot;</span>);</span><br><span class="line">System. out. println(stringBuilder. reverse()); <span class="comment">// gfedcba</span></span><br></pre></td></tr></table></figure>


<h4 id="数组有没有-length-方法？String-有没有-length-方法"><a href="#数组有没有-length-方法？String-有没有-length-方法" class="headerlink" title="数组有没有 length()方法？String 有没有 length()方法"></a>数组有没有 length()方法？String 有没有 length()方法</h4><p>数组没有 length()方法 ，有 length 的属性。String 有 length()方法。JavaScript中，获得字符串的长度是通过 length 属性得到的，这一点容易和 Java 混淆。</p>
<h4 id="String-类的常用方法都有那些？"><a href="#String-类的常用方法都有那些？" class="headerlink" title="String 类的常用方法都有那些？"></a>String 类的常用方法都有那些？</h4><ul>
<li><p>indexOf()：返回指定字符的索引。</p>
</li>
<li><p>charAt()：返回指定索引处的字符。</p>
</li>
<li><p>replace()：字符串替换。</p>
</li>
<li><p>trim()：去除字符串两端空白。</p>
</li>
<li><p>split()：分割字符串，返回一个分割后的字符串数组。</p>
</li>
<li><p>getBytes()：返回字符串的 byte 类型数组。</p>
</li>
<li><p>length()：返回字符串长度。</p>
</li>
<li><p>toLowerCase()：将字符串转成小写字母。</p>
</li>
<li><p>toUpperCase()：将字符串转成大写字符。</p>
</li>
<li><p>substring()：截取字符串。</p>
</li>
<li><p>equals()：字符串比较。</p>
</li>
</ul>
<h4 id="在使用-HashMap-的时候，用-String-做-key-有什么好处？"><a href="#在使用-HashMap-的时候，用-String-做-key-有什么好处？" class="headerlink" title="在使用 HashMap 的时候，用 String 做 key 有什么好处？"></a>在使用 HashMap 的时候，用 String 做 key 有什么好处？</h4><p>HashMap 内部实现是通过 key 的 hashcode 来确定 value 的存储位置，因为字符串是不可变的，所以当创建字符串时，它的 hashcode 被缓存下来，不需要再次计算，所以相比于其他对象更快。</p>
<h4 id="String和StringBuffer、StringBuilder的区别是什么？String为什么是不可变的"><a href="#String和StringBuffer、StringBuilder的区别是什么？String为什么是不可变的" class="headerlink" title="String和StringBuffer、StringBuilder的区别是什么？String为什么是不可变的"></a>String和StringBuffer、StringBuilder的区别是什么？String为什么是不可变的</h4><p><strong>可变性</strong></p>
<p>String类中使用字符数组保存字符串，private　final　char　value[]，所以string对象是不可变的。StringBuilder与StringBuffer都继承自AbstractStringBuilder类，在AbstractStringBuilder中也是使用字符数组保存字符串，char[] value，这两种对象都是可变的。</p>
<p><strong>线程安全性</strong></p>
<p>String中的对象是不可变的，也就可以理解为常量，线程安全。AbstractStringBuilder是StringBuilder与StringBuffer的公共父类，定义了一些字符串的基本操作，如expandCapacity、append、insert、indexOf等公共方法。StringBuffer对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。StringBuilder并没有对方法进行加同步锁，所以是非线程安全的。</p>
<p><strong>性能</strong></p>
<p>每次对String 类型进行改变的时候，都会生成一个新的String对象，然后将指针指向新的String 对象。StringBuffer每次都会对StringBuffer对象本身进行操作，而不是生成新的对象并改变对象引用。相同情况下使用StirngBuilder 相比使用StringBuffer 仅能获得10%~15% 左右的性能提升，但却要冒多线程不安全的风险。</p>
<p><strong>对于三者使用的总结</strong></p>
<p>如果要操作少量的数据用 &#x3D; String</p>
<p>单线程操作字符串缓冲区 下操作大量数据 &#x3D; StringBuilder</p>
<p>多线程操作字符串缓冲区 下操作大量数据 &#x3D; StringBuffer</p>
<h3 id="Date相关"><a href="#Date相关" class="headerlink" title="Date相关"></a>Date相关</h3><h3 id="包装类相关"><a href="#包装类相关" class="headerlink" title="包装类相关"></a>包装类相关</h3><h4 id="自动装箱与拆箱"><a href="#自动装箱与拆箱" class="headerlink" title="自动装箱与拆箱"></a>自动装箱与拆箱</h4><p><strong>装箱</strong>：将基本类型用它们对应的引用类型包装起来；</p>
<p><strong>拆箱</strong>：将包装类型转换为基本数据类型；</p>
<h4 id="int-和-Integer-有什么区别"><a href="#int-和-Integer-有什么区别" class="headerlink" title="int 和 Integer 有什么区别"></a>int 和 Integer 有什么区别</h4><p>Java 是一个近乎纯洁的面向对象编程语言，但是为了编程的方便还是引入了基本数据类型，但是为了能够将这些基本数据类型当成对象操作，Java 为每一个基本数据类型都引入了对应的包装类型（wrapper class），int 的包装类就是 Integer，从 Java 5 开始引入了自动装箱&#x2F;拆箱机制，使得二者可以相互转换。</p>
<p>Java 为每个原始类型提供了包装类型：</p>
<p>原始类型: boolean，char，byte，short，int，long，float，double</p>
<p>包装类型：Boolean，Character，Byte，Short，Integer，Long，Float，Double</p>
<h4 id="Integer-a-127-与-Integer-b-127相等吗"><a href="#Integer-a-127-与-Integer-b-127相等吗" class="headerlink" title="Integer a&#x3D; 127 与 Integer b &#x3D; 127相等吗"></a>Integer a&#x3D; 127 与 Integer b &#x3D; 127相等吗</h4><p>对于对象引用类型：&#x3D;&#x3D;比较的是对象的内存地址。<br>对于基本数据类型：&#x3D;&#x3D;比较的是值。</p>
<p>如果整型字面量的值在-128到127之间，那么自动装箱时不会new新的Integer对象，而是直接引用常量池中的Integer对象，超过范围 a1&#x3D;&#x3D;b1的结果是false</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">3</span>);</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">3</span>;  <span class="comment">// 将3自动装箱成Integer类型</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line">    System.out.println(a == b); <span class="comment">// false 两个引用没有引用同一对象</span></span><br><span class="line">    System.out.println(a == c); <span class="comment">// true a自动拆箱成int类型再和c比较</span></span><br><span class="line">    System.out.println(b == c); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">    <span class="type">Integer</span> <span class="variable">a1</span> <span class="operator">=</span> <span class="number">128</span>;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">b1</span> <span class="operator">=</span> <span class="number">128</span>;</span><br><span class="line">    System.out.println(a1 == b1); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">    <span class="type">Integer</span> <span class="variable">a2</span> <span class="operator">=</span> <span class="number">127</span>;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">b2</span> <span class="operator">=</span> <span class="number">127</span>;</span><br><span class="line">    System.out.println(a2 == b2); <span class="comment">// true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>底层原理</tag>
        <tag>面试题</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>常用限流策略</title>
    <url>/2022/06/03/technology/network/flow_limit/</url>
    <content><![CDATA[<h2 id="限流"><a href="#限流" class="headerlink" title="限流"></a>限流</h2><p>限流又称为流量控制（流控），通常是指限制到达系统的并发请求数。</p>
<p>我们生活中也会经常遇到限流的场景，比如：某景区限制每日进入景区的游客数量为8万人；沙河地铁站早高峰通过站外排队逐一放行的方式限制同一时间进入车站的旅客数量等。</p>
<p>限流虽然会影响部分用户的使用体验，但是却能在一定程度上报障系统的稳定性，不至于崩溃（大家都没了用户体验）。</p>
<p>而互联网上类似需要限流的业务场景也有很多，比如电商系统的秒杀、微博上突发热点新闻、双十一购物节、12306抢票等等。这些场景下的用户请求量通常会激增，远远超过平时正常的请求量，此时如果不加任何限制很容易就会将后端服务打垮，影响服务的稳定性。</p>
<p>此外，一些厂商公开的API服务通常也会限制用户的请求次数，比如百度地图开放平台等会根据用户的付费情况来限制用户的请求数等。</p>
<img data-src="/2022/06/03/technology/network/flow_limit/image.png" class="" title="image.png">

<h2 id="常用的限流策略"><a href="#常用的限流策略" class="headerlink" title="常用的限流策略"></a>常用的限流策略</h2><h3 id="漏桶"><a href="#漏桶" class="headerlink" title="漏桶"></a>漏桶</h3><p>漏桶法限流很好理解，假设我们有一个水桶按固定的速率向下方滴落一滴水，无论有多少请求，请求的速率有多大，都按照固定的速率流出，对应到系统中就是按照固定的速率处理请求。</p>
<img data-src="/2022/06/03/technology/network/flow_limit/image_1.png" class="" title="image.png">
<p>漏桶法的关键点在于漏桶始终按照固定的速率运行，但是它并不能很好的处理有大量突发请求的场景，毕竟在某些场景下我们可能需要提高系统的处理效率，而不是一味的按照固定速率处理请求。</p>
<p>关于漏桶的实现，uber团队有一个开源的<a href="https://github.com/uber-go/ratelimit">github.com&#x2F;uber-go&#x2F;ratelimit</a>库。 这个库的使用方法比较简单，<code>Take()</code> 方法会返回漏桶下一次滴水的时间。</p>
<figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="code"><pre><span class="line">import (</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">    &quot;time&quot;</span><br><span class="line"></span><br><span class="line">    &quot;go.uber.org/ratelimit&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    rl := ratelimit.New(100) // per second</span><br><span class="line"></span><br><span class="line">    prev := time.Now()</span><br><span class="line">    for i := 0; i &lt; 10; i++ &#123;</span><br><span class="line">        now := rl.Take()</span><br><span class="line">        fmt.Println(i, now.Sub(prev))</span><br><span class="line">        prev = now</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Output:</span><br><span class="line">    // 0 0</span><br><span class="line">    // 1 10ms</span><br><span class="line">    // 2 10ms</span><br><span class="line">    // 3 10ms</span><br><span class="line">    // 4 10ms</span><br><span class="line">    // 5 10ms</span><br><span class="line">    // 6 10ms</span><br><span class="line">    // 7 10ms</span><br><span class="line">    // 8 10ms</span><br><span class="line">    // 9 10ms</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>它的源码实现也比较简单，这里大致说一下关键的地方，有兴趣的同学可以自己去看一下完整的源码。</p>
<p>限制器是一个接口类型，其要求实现一个<code>Take()</code>方法：</p>
<figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="code"><pre><span class="line">type Limiter interface &#123;</span><br><span class="line">    // Take方法应该阻塞已确保满足 RPS</span><br><span class="line">    Take() time.Time</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>实现限制器接口的结构体定义如下，这里可以重点留意下<code>maxSlack</code>字段，它在后面的<code>Take()</code>方法中的处理。</p>
<figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="code"><pre><span class="line">type limiter struct &#123;</span><br><span class="line">    sync.Mutex                // 锁</span><br><span class="line">    last       time.Time      // 上一次的时刻</span><br><span class="line">    sleepFor   time.Duration  // 需要等待的时间</span><br><span class="line">    perRequest time.Duration  // 每次的时间间隔</span><br><span class="line">    maxSlack   time.Duration  // 最大的富余量</span><br><span class="line">    clock      Clock          // 时钟</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p><code>limiter</code>结构体实现<code>Limiter</code>接口的<code>Take()</code>方法内容如下：</p>
<figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="code"><pre><span class="line">// Take 会阻塞确保两次请求之间的时间走完</span><br><span class="line">// Take 调用平均数为 time.Second/rate.</span><br><span class="line">func (t *limiter) Take() time.Time &#123;</span><br><span class="line">    t.Lock()</span><br><span class="line">    defer t.Unlock()</span><br><span class="line"></span><br><span class="line">    now := t.clock.Now()</span><br><span class="line"></span><br><span class="line">    // 如果是第一次请求就直接放行</span><br><span class="line">    if t.last.IsZero() &#123;</span><br><span class="line">        t.last = now</span><br><span class="line">        return t.last</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // sleepFor 根据 perRequest 和上一次请求的时刻计算应该sleep的时间</span><br><span class="line">    // 由于每次请求间隔的时间可能会超过perRequest, 所以这个数字可能为负数，并在多个请求之间累加</span><br><span class="line">    t.sleepFor += t.perRequest - now.Sub(t.last)</span><br><span class="line"></span><br><span class="line">    // 我们不应该让sleepFor负的太多，因为这意味着一个服务在短时间内慢了很多随后会得到更高的RPS。</span><br><span class="line">    if t.sleepFor &lt; t.maxSlack &#123;</span><br><span class="line">        t.sleepFor = t.maxSlack</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 如果 sleepFor 是正值那么就 sleep</span><br><span class="line">    if t.sleepFor &gt; 0 &#123;</span><br><span class="line">        t.clock.Sleep(t.sleepFor)</span><br><span class="line">        t.last = now.Add(t.sleepFor)</span><br><span class="line">        t.sleepFor = 0</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        t.last = now</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return t.last</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>上面的代码根据记录每次请求的间隔时间和上一次请求的时刻来计算当次请求需要阻塞的时间——<code>sleepFor</code>，这里需要留意的是<code>sleepFor</code>的值可能为负，在经过间隔时间长的两次访问之后会导致随后大量的请求被放行，所以代码中针对这个场景有专门的优化处理。创建限制器的<code>New()</code>函数中会为<code>maxSlack</code>设置初始值，也可以通过<code>WithoutSlack</code>这个Option取消这个默认值。</p>
<figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="code"><pre><span class="line">func New(rate int, opts ...Option) Limiter &#123;</span><br><span class="line">    l := &amp;limiter&#123;</span><br><span class="line">        perRequest: time.Second / time.Duration(rate),</span><br><span class="line">        maxSlack:   -10 * time.Second / time.Duration(rate),</span><br><span class="line">    &#125;</span><br><span class="line">    for _, opt := range opts &#123;</span><br><span class="line">        opt(l)</span><br><span class="line">    &#125;</span><br><span class="line">    if l.clock == nil &#123;</span><br><span class="line">        l.clock = clock.New()</span><br><span class="line">    &#125;</span><br><span class="line">    return l</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h3 id="令牌桶"><a href="#令牌桶" class="headerlink" title="令牌桶"></a>令牌桶</h3><p>令牌桶其实和漏桶的原理类似，令牌桶按固定的速率往桶里放入令牌，并且只要能从桶里取出令牌就能通过，令牌桶支持突发流量的快速处理。</p>
<img data-src="/2022/06/03/technology/network/flow_limit/image_2.png" class="" title="image.png">

<p>对于从桶里取不到令牌的场景，我们可以选择等待也可以直接拒绝并返回。</p>
<p>对于令牌桶的Go语言实现，大家可以参照<a href="https://github.com/juju/ratelimit">github.com&#x2F;juju&#x2F;ratelimit</a>库。这个库支持多种令牌桶模式，并且使用起来也比较简单。</p>
<p>创建令牌桶的方法：</p>
<figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="code"><pre><span class="line">// 创建指定填充速率和容量大小的令牌桶</span><br><span class="line">func NewBucket(fillInterval time.Duration, capacity int64) *Bucket</span><br><span class="line">// 创建指定填充速率、容量大小和每次填充的令牌数的令牌桶</span><br><span class="line">func NewBucketWithQuantum(fillInterval time.Duration, capacity, quantum int64) *Bucket</span><br><span class="line">// 创建填充速度为指定速率和容量大小的令牌桶</span><br><span class="line">// NewBucketWithRate(0.1, 200) 表示每秒填充20个令牌</span><br><span class="line">func NewBucketWithRate(rate float64, capacity int64) *Bucket</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>取出令牌的方法如下：</p>
<figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="code"><pre><span class="line">// 取token（非阻塞）</span><br><span class="line">func (tb *Bucket) Take(count int64) time.Duration</span><br><span class="line">func (tb *Bucket) TakeAvailable(count int64) int64</span><br><span class="line"></span><br><span class="line">// 最多等maxWait时间取token</span><br><span class="line">func (tb *Bucket) TakeMaxDuration(count int64, maxWait time.Duration) (time.Duration, bool)</span><br><span class="line"></span><br><span class="line">// 取token（阻塞）</span><br><span class="line">func (tb *Bucket) Wait(count int64)</span><br><span class="line">func (tb *Bucket) WaitMaxDuration(count int64, maxWait time.Duration) bool</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>虽说是令牌桶，但是我们没有必要真的去生成令牌放到桶里，我们只需要每次来取令牌的时候计算一下，当前是否有足够的令牌就可以了，具体的计算方式可以总结为下面的公式：</p>
<figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="code"><pre><span class="line">当前令牌数 = 上一次剩余的令牌数 + (本次取令牌的时刻-上一次取令牌的时刻)/放置令牌的时间间隔 * 每次放置的令牌数</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p><a href="https://github.com/juju/ratelimit">github.com&#x2F;juju&#x2F;ratelimit</a>这个库中关于令牌数计算的源代码如下：</p>
<figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="code"><pre><span class="line">func (tb *Bucket) currentTick(now time.Time) int64 &#123;</span><br><span class="line">    return int64(now.Sub(tb.startTime) / tb.fillInterval)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="code"><pre><span class="line">func (tb *Bucket) adjustavailableTokens(tick int64) &#123;</span><br><span class="line">    if tb.availableTokens &gt;= tb.capacity &#123;</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line">    tb.availableTokens += (tick - tb.latestTick) * tb.quantum</span><br><span class="line">    if tb.availableTokens &gt; tb.capacity &#123;</span><br><span class="line">        tb.availableTokens = tb.capacity</span><br><span class="line">    &#125;</span><br><span class="line">    tb.latestTick = tick</span><br><span class="line">    return</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>获取令牌的<code>TakeAvailable()</code>函数关键部分的源代码如下：</p>
<figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="code"><pre><span class="line">func (tb *Bucket) takeAvailable(now time.Time, count int64) int64 &#123;</span><br><span class="line">    if count &lt;= 0 &#123;</span><br><span class="line">        return 0</span><br><span class="line">    &#125;</span><br><span class="line">    tb.adjustavailableTokens(tb.currentTick(now))</span><br><span class="line">    if tb.availableTokens &lt;= 0 &#123;</span><br><span class="line">        return 0</span><br><span class="line">    &#125;</span><br><span class="line">    if count &gt; tb.availableTokens &#123;</span><br><span class="line">        count = tb.availableTokens</span><br><span class="line">    &#125;</span><br><span class="line">    tb.availableTokens -= count</span><br><span class="line">    return count</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>大家从代码中也可以看到其实令牌桶的实现并没有很复杂。</p>
<h2 id="gin框架中使用限流中间件"><a href="#gin框架中使用限流中间件" class="headerlink" title="gin框架中使用限流中间件"></a>gin框架中使用限流中间件</h2><p>在gin框架构建的项目中，我们可以将限流组件定义成中间件。</p>
<p>这里使用令牌桶作为限流策略，编写一个限流中间件如下：</p>
<figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="code"><pre><span class="line">func RateLimitMiddleware(fillInterval time.Duration, cap int64) func(c *gin.Context) &#123;</span><br><span class="line">    bucket := ratelimit.NewBucket(fillInterval, cap)</span><br><span class="line">    return func(c *gin.Context) &#123;</span><br><span class="line">        // 如果取不到令牌就中断本次请求返回 rate limit...</span><br><span class="line">        if bucket.TakeAvailable(1) &lt; 1 &#123;</span><br><span class="line">            c.String(http.StatusOK, &quot;rate limit...&quot;)</span><br><span class="line">            c.Abort()</span><br><span class="line">            return</span><br><span class="line">        &#125;</span><br><span class="line">        c.Next()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>对于该限流中间件的注册位置，我们可以按照不同的限流策略将其注册到不同的位置，例如：</p>
<ol>
<li><p>如果要对全站限流就可以注册成全局的中间件。</p>
</li>
<li><p>如果是某一组路由需要限流，那么就只需将该限流中间件注册到对应的路由组即可。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>面试题</tag>
        <tag>限流</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot基础知识</title>
    <url>/2022/10/01/technology/java/springboot_basic/</url>
    <content><![CDATA[<p>Java SpringBoot基础知识汇总，包含基础语法，面试常见问题等…</p>
<span id="more"></span>

<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h3 id="什么是-Spring-Boot？"><a href="#什么是-Spring-Boot？" class="headerlink" title="什么是 Spring Boot？"></a>什么是 Spring Boot？</h3><p>Spring Boot 是 Spring 开源组织下的子项目，是 Spring 组件一站式解决方案，主要是简化了使用 Spring 的难度，简省了繁重的配置，提供了各种启动器，开发者能快速上手。</p>
<h3 id="Spring-Boot-有哪些优点？"><a href="#Spring-Boot-有哪些优点？" class="headerlink" title="Spring Boot 有哪些优点？"></a>Spring Boot 有哪些优点？</h3><p>Spring Boot 主要有如下优点：</p>
<ol>
<li><p>容易上手，提升开发效率，为 Spring 开发提供一个更快、更广泛的入门体验。</p>
</li>
<li><p>开箱即用，远离繁琐的配置。</p>
</li>
<li><p>提供了一系列大型项目通用的非业务性功能，例如：内嵌服务器、安全管理、运行数据监控、运行状况检查和外部化配置等。</p>
</li>
<li><p>没有代码生成，也不需要XML配置。</p>
</li>
<li><p>避免大量的 Maven 导入和各种版本冲突。</p>
</li>
</ol>
<h3 id="Spring-Boot-的核心注解是哪个？它主要由哪几个注解组成的？"><a href="#Spring-Boot-的核心注解是哪个？它主要由哪几个注解组成的？" class="headerlink" title="Spring Boot 的核心注解是哪个？它主要由哪几个注解组成的？"></a>Spring Boot 的核心注解是哪个？它主要由哪几个注解组成的？</h3><p>启动类上面的注解是@SpringBootApplication，它也是 Spring Boot 的核心注解，主要组合包含了以下 3 个注解：</p>
<p>@SpringBootConfiguration：组合了 @Configuration 注解，实现配置文件的功能。</p>
<p>@EnableAutoConfiguration：打开自动配置的功能，也可以关闭某个自动配置的选项，如关闭数据源自动配置功能： @SpringBootApplication(exclude &#x3D; { DataSourceAutoConfiguration.class })。</p>
<p>@ComponentScan：Spring组件扫描。</p>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><h3 id="什么是-JavaConfig？"><a href="#什么是-JavaConfig？" class="headerlink" title="什么是 JavaConfig？"></a>什么是 JavaConfig？</h3><p>Spring JavaConfig 是 Spring 社区的产品，它提供了配置 Spring IoC 容器的纯Java 方法。因此它有助于避免使用 XML 配置。使用 JavaConfig 的优点在于：</p>
<p>（1）面向对象的配置。由于配置被定义为 JavaConfig 中的类，因此用户可以充分利用 Java 中的面向对象功能。一个配置类可以继承另一个，重写它的@Bean 方法等。</p>
<p>（2）减少或消除 XML 配置。基于依赖注入原则的外化配置的好处已被证明。但是，许多开发人员不希望在 XML 和 Java 之间来回切换。JavaConfig 为开发人员提供了一种纯 Java 方法来配置与 XML 配置概念相似的 Spring 容器。从技术角度来讲，只使用 JavaConfig 配置类来配置容器是可行的，但实际上很多人认为将JavaConfig 与 XML 混合匹配是理想的。</p>
<p>（3）类型安全和重构友好。JavaConfig 提供了一种类型安全的方法来配置 Spring容器。由于 Java 5.0 对泛型的支持，现在可以按类型而不是按名称检索 bean，不需要任何强制转换或基于字符串的查找。</p>
<h3 id="Spring-Boot-自动配置原理是什么？"><a href="#Spring-Boot-自动配置原理是什么？" class="headerlink" title="Spring Boot 自动配置原理是什么？"></a>Spring Boot 自动配置原理是什么？</h3><p>注解 @EnableAutoConfiguration, @Configuration, @ConditionalOnClass 就是自动配置的核心，</p>
<p>@EnableAutoConfiguration 给容器导入META-INF&#x2F;spring.factories 里定义的自动配置类。</p>
<p>筛选有效的自动配置类。</p>
<p>每一个自动配置类结合对应的 xxxProperties.java 读取配置文件进行自动配置功能</p>
<h3 id="你如何理解-Spring-Boot-配置加载顺序？"><a href="#你如何理解-Spring-Boot-配置加载顺序？" class="headerlink" title="你如何理解 Spring Boot 配置加载顺序？"></a>你如何理解 Spring Boot 配置加载顺序？</h3><p>在 Spring Boot 里面，可以使用以下几种方式来加载配置。</p>
<p>1）properties文件；</p>
<p>2）YAML文件；</p>
<p>3）系统环境变量；</p>
<p>4）命令行参数；</p>
<p>等等……</p>
<h3 id="什么是-YAML？"><a href="#什么是-YAML？" class="headerlink" title="什么是 YAML？"></a>什么是 YAML？</h3><p>YAML 是一种人类可读的数据序列化语言。它通常用于配置文件。与属性文件相比，如果我们想要在配置文件中添加复杂的属性，YAML 文件就更加结构化，而且更少混淆。可以看出 YAML 具有分层配置数据。</p>
<h3 id="YAML-配置的优势在哪里"><a href="#YAML-配置的优势在哪里" class="headerlink" title="YAML 配置的优势在哪里 ?"></a>YAML 配置的优势在哪里 ?</h3><p>YAML 现在可以算是非常流行的一种配置文件格式了，无论是前端还是后端，都可以见到 YAML 配置。那么 YAML 配置和传统的 properties 配置相比到底有哪些优势呢？</p>
<ol start="6">
<li><p>配置有序，在一些特殊的场景下，配置有序很关键</p>
</li>
<li><p>支持数组，数组中的元素可以是基本数据类型也可以是对象</p>
</li>
<li><p>简洁</p>
</li>
</ol>
<p>相比 properties 配置文件，YAML 还有一个缺点，就是不支持 @PropertySource 注解导入自定义的 YAML 配置。</p>
<h3 id="Spring-Boot-是否可以使用-XML-配置"><a href="#Spring-Boot-是否可以使用-XML-配置" class="headerlink" title="Spring Boot 是否可以使用 XML 配置 ?"></a>Spring Boot 是否可以使用 XML 配置 ?</h3><p>Spring Boot 推荐使用 Java 配置而非 XML 配置，但是 Spring Boot 中也可以使用 XML 配置，通过 @ImportResource 注解可以引入一个 XML 配置。</p>
<h3 id="spring-boot-核心配置文件是什么？bootstrap-properties-和-application-properties-有何区别"><a href="#spring-boot-核心配置文件是什么？bootstrap-properties-和-application-properties-有何区别" class="headerlink" title="spring boot 核心配置文件是什么？bootstrap.properties 和 application.properties 有何区别 ?"></a>spring boot 核心配置文件是什么？bootstrap.properties 和 application.properties 有何区别 ?</h3><p>单纯做 Spring Boot 开发，可能不太容易遇到 bootstrap.properties 配置文件，但是在结合 Spring Cloud 时，这个配置就会经常遇到了，特别是在需要加载一些远程配置文件的时侯。</p>
<p>spring boot 核心的两个配置文件：</p>
<ul>
<li><p>bootstrap (. yml 或者 . properties)：boostrap 由父 ApplicationContext 加载的，比 applicaton 优先加载，配置在应用程序上下文的引导阶段生效。一般来说我们在 Spring Cloud Config 或者 Nacos 中会用到它。且 boostrap 里面的属性不能被覆盖；</p>
</li>
<li><p>application (. yml 或者 . properties)： 由ApplicatonContext 加载，用于 spring boot 项目的自动化配置。</p>
</li>
</ul>
<h3 id="什么是-Spring-Profiles？"><a href="#什么是-Spring-Profiles？" class="headerlink" title="什么是 Spring Profiles？"></a>什么是 Spring Profiles？</h3><p>Spring Profiles 允许用户根据配置文件（dev，test，prod 等）来注册 bean。因此，当应用程序在开发中运行时，只有某些 bean 可以加载，而在 PRODUCTION中，某些其他 bean 可以加载。假设我们的要求是 Swagger 文档仅适用于 QA 环境，并且禁用所有其他文档。这可以使用配置文件来完成。Spring Boot 使得使用配置文件非常简单。</p>
<h3 id="如何在自定义端口上运行-Spring-Boot-应用程序？"><a href="#如何在自定义端口上运行-Spring-Boot-应用程序？" class="headerlink" title="如何在自定义端口上运行 Spring Boot 应用程序？"></a>如何在自定义端口上运行 Spring Boot 应用程序？</h3><p>为了在自定义端口上运行 Spring Boot 应用程序，您可以在application.properties 中指定端口。server.port &#x3D; 8090</p>
<h2 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h2><h3 id="如何实现-Spring-Boot-应用程序的安全性？"><a href="#如何实现-Spring-Boot-应用程序的安全性？" class="headerlink" title="如何实现 Spring Boot 应用程序的安全性？"></a>如何实现 Spring Boot 应用程序的安全性？</h3><p>为了实现 Spring Boot 的安全性，我们使用 spring-boot-starter-security 依赖项，并且必须添加安全配置。它只需要很少的代码。配置类将必须扩展WebSecurityConfigurerAdapter 并覆盖其方法。</p>
<h3 id="比较一下-Spring-Security-和-Shiro-各自的优缺点"><a href="#比较一下-Spring-Security-和-Shiro-各自的优缺点" class="headerlink" title="比较一下 Spring Security 和 Shiro 各自的优缺点 ?"></a>比较一下 Spring Security 和 Shiro 各自的优缺点 ?</h3><p>由于 Spring Boot 官方提供了大量的非常方便的开箱即用的 Starter ，包括 Spring Security 的 Starter ，使得在 Spring Boot 中使用 Spring Security 变得更加容易，甚至只需要添加一个依赖就可以保护所有的接口，所以，如果是 Spring Boot 项目，一般选择 Spring Security 。当然这只是一个建议的组合，单纯从技术上来说，无论怎么组合，都是没有问题的。Shiro 和 Spring Security 相比，主要有如下一些特点：</p>
<ol>
<li><p>Spring Security 是一个重量级的安全管理框架；Shiro 则是一个轻量级的安全管理框架</p>
</li>
<li><p>Spring Security 概念复杂，配置繁琐；Shiro 概念简单、配置简单</p>
</li>
<li><p>Spring Security 功能强大；Shiro 功能简单</p>
</li>
</ol>
<h3 id="Spring-Boot-中如何解决跨域问题"><a href="#Spring-Boot-中如何解决跨域问题" class="headerlink" title="Spring Boot 中如何解决跨域问题 ?"></a>Spring Boot 中如何解决跨域问题 ?</h3><p>跨域可以在前端通过 JSONP 来解决，但是 JSONP 只可以发送 GET 请求，无法发送其他类型的请求，在 RESTful 风格的应用中，就显得非常鸡肋，因此我们推荐在后端通过 （CORS，Cross-origin resource sharing） 来解决跨域问题。这种解决方案并非 Spring Boot 特有的，在传统的 SSM 框架中，就可以通过 CORS 来解决跨域问题，只不过之前我们是在 XML 文件中配置 CORS ，现在可以通过实现WebMvcConfigurer接口然后重写addCorsMappings方法解决跨域问题。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CorsConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addCorsMappings</span><span class="params">(CorsRegistry registry)</span> &#123;</span><br><span class="line">        registry.addMapping(<span class="string">&quot;/**&quot;</span>)</span><br><span class="line">                .allowedOrigins(<span class="string">&quot;*&quot;</span>)</span><br><span class="line">                .allowCredentials(<span class="literal">true</span>)</span><br><span class="line">                .allowedMethods(<span class="string">&quot;GET&quot;</span>, <span class="string">&quot;POST&quot;</span>, <span class="string">&quot;PUT&quot;</span>, <span class="string">&quot;DELETE&quot;</span>, <span class="string">&quot;OPTIONS&quot;</span>)</span><br><span class="line">                .maxAge(<span class="number">3600</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>项目中前后端分离部署，所以需要解决跨域的问题。<br>我们使用cookie存放用户登录的信息，在spring拦截器进行权限控制，当权限不符合时，直接返回给用户固定的json结果。<br>当用户登录以后，正常使用；当用户退出登录状态时或者token过期时，由于拦截器和跨域的顺序有问题，出现了跨域的现象。<br>我们知道一个http请求，先走filter，到达servlet后才进行拦截器的处理，如果我们把cors放在filter里，就可以优先于权限拦截器执行。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CorsConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> CorsFilter <span class="title function_">corsFilter</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">CorsConfiguration</span> <span class="variable">corsConfiguration</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CorsConfiguration</span>();</span><br><span class="line">        corsConfiguration.addAllowedOrigin(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">        corsConfiguration.addAllowedHeader(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">        corsConfiguration.addAllowedMethod(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">        corsConfiguration.setAllowCredentials(<span class="literal">true</span>);</span><br><span class="line">        <span class="type">UrlBasedCorsConfigurationSource</span> <span class="variable">urlBasedCorsConfigurationSource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UrlBasedCorsConfigurationSource</span>();</span><br><span class="line">        urlBasedCorsConfigurationSource.registerCorsConfiguration(<span class="string">&quot;/**&quot;</span>, corsConfiguration);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CorsFilter</span>(urlBasedCorsConfigurationSource);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="什么是-CSRF-攻击？"><a href="#什么是-CSRF-攻击？" class="headerlink" title="什么是 CSRF 攻击？"></a>什么是 CSRF 攻击？</h3><p>CSRF 代表跨站请求伪造。这是一种攻击，迫使最终用户在当前通过身份验证的Web 应用程序上执行不需要的操作。CSRF 攻击专门针对状态改变请求，而不是数据窃取，因为攻击者无法查看对伪造请求的响应。</p>
<h2 id="监视器"><a href="#监视器" class="headerlink" title="监视器"></a>监视器</h2><h3 id="Spring-Boot-中的监视器是什么？"><a href="#Spring-Boot-中的监视器是什么？" class="headerlink" title="Spring Boot 中的监视器是什么？"></a>Spring Boot 中的监视器是什么？</h3><p>Spring boot actuator 是 spring 启动框架中的重要功能之一。Spring boot 监视器可帮助您访问生产环境中正在运行的应用程序的当前状态。有几个指标必须在生产环境中进行检查和监控。即使一些外部应用程序可能正在使用这些服务来向相关人员触发警报消息。监视器模块公开了一组可直接作为 HTTP URL 访问的REST 端点来检查状态。</p>
<h3 id="如何在-Spring-Boot-中禁用-Actuator-端点安全性？"><a href="#如何在-Spring-Boot-中禁用-Actuator-端点安全性？" class="headerlink" title="如何在 Spring Boot 中禁用 Actuator 端点安全性？"></a>如何在 Spring Boot 中禁用 Actuator 端点安全性？</h3><p>默认情况下，所有敏感的 HTTP 端点都是安全的，只有具有 ACTUATOR 角色的用户才能访问它们。安全性是使用标准的 HttpServletRequest.isUserInRole 方法实施的。 我们可以使用来禁用安全性。只有在执行机构端点在防火墙后访问时，才建议禁用安全性。</p>
<h3 id="我们如何监视所有-Spring-Boot-微服务？"><a href="#我们如何监视所有-Spring-Boot-微服务？" class="headerlink" title="我们如何监视所有 Spring Boot 微服务？"></a>我们如何监视所有 Spring Boot 微服务？</h3><p>Spring Boot 提供监视器端点以监控各个微服务的度量。这些端点对于获取有关应用程序的信息（如它们是否已启动）以及它们的组件（如数据库等）是否正常运行很有帮助。但是，使用监视器的一个主要缺点或困难是，我们必须单独打开应用程序的知识点以了解其状态或健康状况。想象一下涉及 50 个应用程序的微服务，管理员将不得不击中所有 50 个应用程序的执行终端。为了帮助我们处理这种情况，我们将使用位于的开源项目。 它建立在 Spring Boot Actuator 之上，它提供了一个 Web UI，使我们能够可视化多个应用程序的度量。</p>
<h2 id="整合第三方项目"><a href="#整合第三方项目" class="headerlink" title="整合第三方项目"></a>整合第三方项目</h2><h3 id="什么是-WebSockets？"><a href="#什么是-WebSockets？" class="headerlink" title="什么是 WebSockets？"></a>什么是 WebSockets？</h3><p>WebSocket 是一种计算机通信协议，通过单个 TCP 连接提供全双工通信信道。</p>
<p>1、WebSocket 是双向的 -使用 WebSocket 客户端或服务器可以发起消息发送。</p>
<p>2、WebSocket 是全双工的 -客户端和服务器通信是相互独立的。</p>
<p>3、单个 TCP 连接 -初始连接使用 HTTP，然后将此连接升级到基于套接字的连接。然后这个单一连接用于所有未来的通信</p>
<p>4、Light -与 http 相比，WebSocket 消息数据交换要轻得多。</p>
<h3 id="什么是-Spring-Data"><a href="#什么是-Spring-Data" class="headerlink" title="什么是 Spring Data ?"></a>什么是 Spring Data ?</h3><p>Spring Data 是 Spring 的一个子项目。用于简化数据库访问，支持NoSQL 和 关系数据存储。其主要目标是使数据库的访问变得方便快捷。Spring Data 具有如下特点：</p>
<p>SpringData 项目支持 NoSQL 存储：</p>
<ol>
<li><p>MongoDB （文档数据库）</p>
</li>
<li><p>Neo4j（图形数据库）</p>
</li>
<li><p>Redis（键&#x2F;值存储）</p>
</li>
<li><p>Hbase（列族数据库）</p>
</li>
</ol>
<p>SpringData 项目所支持的关系数据存储技术：</p>
<ol start="5">
<li><p>JDBC</p>
</li>
<li><p>JPA</p>
</li>
</ol>
<p>Spring Data Jpa 致力于减少数据访问层 (DAO) 的开发量. 开发者唯一要做的，就是声明持久层的接口，其他都交给 Spring Data JPA 来帮你完成！Spring Data JPA 通过规范方法的名字，根据符合规范的名字来确定方法需要实现什么样的逻辑。</p>
<h3 id="什么是-Spring-Batch？"><a href="#什么是-Spring-Batch？" class="headerlink" title="什么是 Spring Batch？"></a>什么是 Spring Batch？</h3><p>Spring Boot Batch 提供可重用的函数，这些函数在处理大量记录时非常重要，包括日志&#x2F;跟踪，事务管理，作业处理统计信息，作业重新启动，跳过和资源管理。它还提供了更先进的技术服务和功能，通过优化和分区技术，可以实现极高批量和高性能批处理作业。简单以及复杂的大批量批处理作业可以高度可扩展的方式利用框架处理重要大量的信息。</p>
<h3 id="什么是-FreeMarker-模板？"><a href="#什么是-FreeMarker-模板？" class="headerlink" title="什么是 FreeMarker 模板？"></a>什么是 FreeMarker 模板？</h3><p>FreeMarker 是一个基于 Java 的模板引擎，最初专注于使用 MVC 软件架构进行动态网页生成。使用 Freemarker 的主要优点是表示层和业务层的完全分离。程序员可以处理应用程序代码，而设计人员可以处理 html 页面设计。最后使用freemarker 可以将这些结合起来，给出最终的输出页面。</p>
<h3 id="如何集成-Spring-Boot-和-ActiveMQ？"><a href="#如何集成-Spring-Boot-和-ActiveMQ？" class="headerlink" title="如何集成 Spring Boot 和 ActiveMQ？"></a>如何集成 Spring Boot 和 ActiveMQ？</h3><p>对于集成 Spring Boot 和 ActiveMQ，我们使用依赖关系。 它只需要很少的配置，并且不需要样板代码。</p>
<h3 id="什么是-Apache-Kafka？"><a href="#什么是-Apache-Kafka？" class="headerlink" title="什么是 Apache Kafka？"></a>什么是 Apache Kafka？</h3><p>Apache Kafka 是一个分布式发布 - 订阅消息系统。它是一个可扩展的，容错的发布 - 订阅消息系统，它使我们能够构建分布式应用程序。这是一个 Apache 顶级项目。Kafka 适合离线和在线消息消费。</p>
<h3 id="什么是-Swagger？你用-Spring-Boot-实现了它吗？"><a href="#什么是-Swagger？你用-Spring-Boot-实现了它吗？" class="headerlink" title="什么是 Swagger？你用 Spring Boot 实现了它吗？"></a>什么是 Swagger？你用 Spring Boot 实现了它吗？</h3><p>Swagger 广泛用于可视化 API，使用 Swagger UI 为前端开发人员提供在线沙箱。Swagger 是用于生成 RESTful Web 服务的可视化表示的工具，规范和完整框架实现。它使文档能够以与服务器相同的速度更新。当通过 Swagger 正确定义时，消费者可以使用最少量的实现逻辑来理解远程服务并与其进行交互。因此，Swagger消除了调用服务时的猜测。</p>
<h3 id="前后端分离，如何维护接口文档"><a href="#前后端分离，如何维护接口文档" class="headerlink" title="前后端分离，如何维护接口文档 ?"></a>前后端分离，如何维护接口文档 ?</h3><p>前后端分离开发日益流行，大部分情况下，我们都是通过 Spring Boot 做前后端分离开发，前后端分离一定会有接口文档，不然会前后端会深深陷入到扯皮中。一个比较笨的方法就是使用 word 或者 md 来维护接口文档，但是效率太低，接口一变，所有人手上的文档都得变。在 Spring Boot 中，这个问题常见的解决方案是 Swagger ，使用 Swagger 我们可以快速生成一个接口文档网站，接口一旦发生变化，文档就会自动更新，所有开发工程师访问这一个在线网站就可以获取到最新的接口文档，非常方便。</p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="如何重新加载-Spring-Boot-上的更改，而无需重新启动服务器？Spring-Boot项目如何热部署？"><a href="#如何重新加载-Spring-Boot-上的更改，而无需重新启动服务器？Spring-Boot项目如何热部署？" class="headerlink" title="如何重新加载 Spring Boot 上的更改，而无需重新启动服务器？Spring Boot项目如何热部署？"></a>如何重新加载 Spring Boot 上的更改，而无需重新启动服务器？Spring Boot项目如何热部署？</h3><p>这可以使用 DEV 工具来实现。通过这种依赖关系，您可以节省任何更改，嵌入式tomcat 将重新启动。Spring Boot 有一个开发工具（DevTools）模块，它有助于提高开发人员的生产力。Java 开发人员面临的一个主要挑战是将文件更改自动部署到服务器并自动重启服务器。开发人员可以重新加载 Spring Boot 上的更改，而无需重新启动服务器。这将消除每次手动部署更改的需要。Spring Boot 在发布它的第一个版本时没有这个功能。这是开发人员最需要的功能。DevTools 模块完全满足开发人员的需求。该模块将在生产环境中被禁用。它还提供 H2 数据库控制台以更好地测试应用程序。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-devtools<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>


<h3 id="您使用了哪些-starter-maven-依赖项？"><a href="#您使用了哪些-starter-maven-依赖项？" class="headerlink" title="您使用了哪些 starter maven 依赖项？"></a>您使用了哪些 starter maven 依赖项？</h3><p>使用了下面的一些依赖项</p>
<p>spring-boot-starter-activemq</p>
<p>spring-boot-starter-security</p>
<p>这有助于增加更少的依赖关系，并减少版本的冲突。</p>
<h3 id="Spring-Boot-中的-starter-到底是什么"><a href="#Spring-Boot-中的-starter-到底是什么" class="headerlink" title="Spring Boot 中的 starter 到底是什么 ?"></a>Spring Boot 中的 starter 到底是什么 ?</h3><p>首先，这个 Starter 并非什么新的技术点，基本上还是基于 Spring 已有功能来实现的。首先它提供了一个自动化配置类，一般命名为 <code>XXXAutoConfiguration</code> ，在这个配置类中通过条件注解来决定一个配置是否生效（条件注解就是 Spring 中原本就有的），然后它还会提供一系列的默认配置，也允许开发者根据实际情况自定义相关配置，然后通过类型安全的属性注入将这些配置属性注入进来，新注入的属性会代替掉默认属性。正因为如此，很多第三方框架，我们只需要引入依赖就可以直接使用了。当然，开发者也可以自定义 Starter</p>
<h3 id="spring-boot-starter-parent-有什么用"><a href="#spring-boot-starter-parent-有什么用" class="headerlink" title="spring-boot-starter-parent 有什么用 ?"></a>spring-boot-starter-parent 有什么用 ?</h3><p>我们都知道，新创建一个 Spring Boot 项目，默认都是有 parent 的，这个 parent 就是 spring-boot-starter-parent ，spring-boot-starter-parent 主要有如下作用：</p>
<ol>
<li><p>定义了 Java 编译版本为 1.8 。</p>
</li>
<li><p>使用 UTF-8 格式编码。</p>
</li>
<li><p>继承自 spring-boot-dependencies，这个里边定义了依赖的版本，也正是因为继承了这个依赖，所以我们在写依赖时才不需要写版本号。</p>
</li>
<li><p>执行打包操作的配置。</p>
</li>
<li><p>自动化的资源过滤。</p>
</li>
<li><p>自动化的插件配置。</p>
</li>
<li><p>针对 application.properties 和 application.yml 的资源过滤，包括通过 profile 定义的不同环境的配置文件，例如 application-dev.properties 和 application-dev.yml。</p>
</li>
</ol>
<h3 id="Spring-Boot-打成的-jar-和普通的-jar-有什么区别"><a href="#Spring-Boot-打成的-jar-和普通的-jar-有什么区别" class="headerlink" title="Spring Boot 打成的 jar 和普通的 jar 有什么区别 ?"></a>Spring Boot 打成的 jar 和普通的 jar 有什么区别 ?</h3><p>Spring Boot 项目最终打包成的 jar 是可执行 jar ，这种 jar 可以直接通过 <code>java -jar xxx.jar</code> 命令来运行，这种 jar 不可以作为普通的 jar 被其他项目依赖，即使依赖了也无法使用其中的类。</p>
<p>Spring Boot 的 jar 无法被其他项目依赖，主要还是他和普通 jar 的结构不同。普通的 jar 包，解压后直接就是包名，包里就是我们的代码，而 Spring Boot 打包成的可执行 jar 解压后，在 <code>\BOOT-INF\classes</code> 目录下才是我们的代码，因此无法被直接引用。如果非要引用，可以在 pom.xml 文件中增加配置，将 Spring Boot 项目打包成两个 jar ，一个可执行，一个可引用。</p>
<h3 id="运行-Spring-Boot-有哪几种方式？"><a href="#运行-Spring-Boot-有哪几种方式？" class="headerlink" title="运行 Spring Boot 有哪几种方式？"></a>运行 Spring Boot 有哪几种方式？</h3><p>1）打包用命令或者放到容器中运行</p>
<p>2）用 Maven&#x2F; Gradle 插件运行</p>
<p>3）直接执行 main 方法运行</p>
<h3 id="Spring-Boot-需要独立的容器运行吗？"><a href="#Spring-Boot-需要独立的容器运行吗？" class="headerlink" title="Spring Boot 需要独立的容器运行吗？"></a>Spring Boot 需要独立的容器运行吗？</h3><p>可以不需要，内置了 Tomcat&#x2F; Jetty 等容器。</p>
<h3 id="开启-Spring-Boot-特性有哪几种方式？"><a href="#开启-Spring-Boot-特性有哪几种方式？" class="headerlink" title="开启 Spring Boot 特性有哪几种方式？"></a>开启 Spring Boot 特性有哪几种方式？</h3><p>1）继承spring-boot-starter-parent项目</p>
<p>2）导入spring-boot-dependencies项目依赖</p>
<h3 id="如何使用-Spring-Boot-实现异常处理？"><a href="#如何使用-Spring-Boot-实现异常处理？" class="headerlink" title="如何使用 Spring Boot 实现异常处理？"></a>如何使用 Spring Boot 实现异常处理？</h3><p>Spring 提供了一种使用 ControllerAdvice 处理异常的非常有用的方法。 我们通过实现一个 ControlerAdvice 类，来处理控制器类抛出的所有异常。</p>
<h3 id="如何使用-Spring-Boot-实现分页和排序？"><a href="#如何使用-Spring-Boot-实现分页和排序？" class="headerlink" title="如何使用 Spring Boot 实现分页和排序？"></a>如何使用 Spring Boot 实现分页和排序？</h3><p>使用 Spring Boot 实现分页非常简单。使用 Spring Data-JPA 可以实现将可分页的传递给存储库方法。</p>
<h3 id="微服务中如何实现-session-共享"><a href="#微服务中如何实现-session-共享" class="headerlink" title="微服务中如何实现 session 共享 ?"></a>微服务中如何实现 session 共享 ?</h3><p>在微服务中，一个完整的项目被拆分成多个不相同的独立的服务，各个服务独立部署在不同的服务器上，各自的 session 被从物理空间上隔离开了，但是经常，我们需要在不同微服务之间共享 session ，常见的方案就是 Spring Session + Redis 来实现 session 共享。将所有微服务的 session 统一保存在 Redis 上，当各个微服务对 session 有相关的读写操作时，都去操作 Redis 上的 session 。这样就实现了 session 共享，Spring Session 基于 Spring 中的代理过滤器实现，使得 session 的同步操作对开发人员而言是透明的，非常简便。</p>
<h3 id="Spring-Boot-中如何实现定时任务"><a href="#Spring-Boot-中如何实现定时任务" class="headerlink" title="Spring Boot 中如何实现定时任务 ?"></a>Spring Boot 中如何实现定时任务 ?</h3><p>定时任务也是一个常见的需求，Spring Boot 中对于定时任务的支持主要还是来自 Spring 框架。</p>
<p>在 Spring Boot 中使用定时任务主要有两种不同的方式，一个就是使用 Spring 中的 @Scheduled 注解，另一个则是使用第三方框架 Quartz。</p>
<p>使用 Spring 中的 @Scheduled 的方式主要通过 @Scheduled 注解来实现。</p>
<p>使用 Quartz ，则按照 Quartz 的方式，定义 Job 和 Trigger 即可。</p>
]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>面试题</tag>
        <tag>Java</tag>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>Java基础知识面试题</title>
    <url>/2022/10/01/technology/java/java_review/</url>
    <content><![CDATA[<p>Java基础知识汇总，包含基础语法，面试常见问题，底层原理等…</p>
<span id="more"></span>


<h3 id="面向对象的三个基本特征？"><a href="#面向对象的三个基本特征？" class="headerlink" title="面向对象的三个基本特征？"></a>面向对象的三个基本特征？</h3><p>面向对象的三个基本特征是：封装、继承和多态。</p>
<p>继承：让某个类型的对象获得另一个类型的对象的属性的方法。继承就是子类继承父类的特征和行为，使得子类对象（实例）具有父类的实例域和方法，或子类从父类继承方法，使得子类具有父类相同的行为。</p>
<p>封装：隐藏部分对象的属性和实现细节，对数据的访问只能通过外公开的接口。通过这种方式，对象对内部数据提供了不同级别的保护，以防止程序中无关的部分意外的改变或错误的使用了对象的私有部分。</p>
<p>多态：对于同一个行为，不同的子类对象具有不同的表现形式。多态存在的3个条件：1）继承；2）重写；3）父类引用指向子类对象。</p>
<p>举个简单的例子：英雄联盟里面我们按下 Q 键这个动作：</p>
<ul>
<li><p>对于亚索，就是斩钢闪</p>
</li>
<li><p>对于提莫，就是致盲吹箭</p>
</li>
<li><p>对于剑圣，就是阿尔法突袭</p>
</li>
</ul>
<p>同一个事件发生在不同的对象上会产生不同的结果。</p>
<p>我再举一个简单的例子帮助大家理解，这个例子可能不是完全准确，但是我认为是有利于理解的。</p>
<figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="code"><pre><span class="line">20 1public class Animal &#123; // 动物2    public void sleep() &#123;3        System.out.println(&quot;躺着睡&quot;);4    &#125;5&#125;6class Horse extends Animal &#123; // 马 是一种动物7    public void sleep() &#123;8        System.out.println(&quot;站着睡&quot;);9        &#125;10    &#125;11class Cat extends Animal &#123; // 猫 是一种动物12    private int age;13    public int getAge() &#123;14        return age + 1;15    &#125;16    @Override17    public void sleep() &#123;18        System.out.println(&quot;四脚朝天的睡&quot;);19        &#125;20    &#125;</span><br></pre></td></tr></table></figure>


<p>在这个例子中：</p>
<p>House 和 Cat 都是 Animal，所以他们都继承了 Animal，同时也从 Animal 继承了 sleep 这个行为。</p>
<p>但是针对 sleep 这个行为，House 和 Cat 进行了重写，有了不同的表现形式（实现），这个我们称为多态。</p>
<p>在 Cat 里，将 age 属性定义为 private，外界无法直接访问，要获取 Cat 的 age 信息只能通过 getAge 方法，从而对外隐藏了 age 属性，这个就叫做封装。当然，这边 age 只是个例子，实际使用中可能是一个复杂很多的对象。</p>
<h3 id="访问修饰符public，private，protected，以及不写时的区别？"><a href="#访问修饰符public，private，protected，以及不写时的区别？" class="headerlink" title="访问修饰符public，private，protected，以及不写时的区别？"></a>访问修饰符public，private，protected，以及不写时的区别？</h3><img data-src="/2022/10/01/technology/java/java_review/image.png" class="" title="image.png">

<h3 id="下面两个代码块能正常编译和执行吗？"><a href="#下面两个代码块能正常编译和执行吗？" class="headerlink" title="下面两个代码块能正常编译和执行吗？"></a>下面两个代码块能正常编译和执行吗？</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 代码块1</span></span><br><span class="line"><span class="type">short</span> s1 = <span class="number">1</span>; s1 = s1 + <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 代码块2</span></span><br><span class="line"><span class="type">short</span> s1 = <span class="number">1</span>; s1 += <span class="number">1</span>;</span><br></pre></td></tr></table></figure>


<p>代码块1编译报错，错误原因是：不兼容的类型: 从int转换到short可能会有损失”。</p>
<p>代码块2正常编译和执行。</p>
<p>我们将代码块2进行编译，字节码如下：</p>
<figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="code"><pre><span class="line">17 1public class com.joonwhee.open.demo.Convert &#123;2    public com.joonwhee.open.demo.Convert();3    Code:4    0: aload_05    1: invokespecial #1 // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V6    4: return7    public static void main(java.lang.String[]);8    Code:9    0: iconst_1 // 将int类型值1入（操作数）栈10    1: istore_1 // 将栈顶int类型值保存到局部变量1中11    2: iload_1 // 从局部变量1中装载int类型值入栈12    3: iconst_1 // 将int类型值1入栈13    4: iadd // 将栈顶两int类型数相加，结果入栈14    5: i2s // 将栈顶int类型值截断成short类型值，后带符号扩展成int类型值入栈。15    6: istore_1 // 将栈顶int类型值保存到局部变量1中16    7: return17&#125;</span><br></pre></td></tr></table></figure>


<p>可以看到字节码中包含了 i2s 指令，该指令用于将 int 转成 short。i2s 是 int to short 的缩写。</p>
<p>其实，s1 +&#x3D; 1 相当于 s1 &#x3D; (short)(s1 + 1)，有兴趣的可以自己编译下这两行代码的字节码，你会发现是一摸一样的。</p>
<h3 id="基础考察，指出下题的输出结果"><a href="#基础考察，指出下题的输出结果" class="headerlink" title="基础考察，指出下题的输出结果"></a>基础考察，指出下题的输出结果</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="type">static</span> <span class="type">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Integer a = <span class="number">128</span>, b = <span class="number">128</span>, c = <span class="number">127</span>, d = <span class="number">127</span>;</span><br><span class="line">    System.out.<span class="built_in">println</span>(a == b);</span><br><span class="line">    System.out.<span class="built_in">println</span>(c == d);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>答案是：false，true。</p>
<p>执行 Integer a &#x3D; 128，相当于执行：Integer a &#x3D; Integer.valueOf(128)，基本类型自动转换为包装类的过程称为自动装箱（autoboxing）。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="type">static</span> Integer <span class="title">valueOf</span><span class="params">(<span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">    <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Integer</span>(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>在 Integer 中引入了 IntegerCache 来缓存一定范围的值，IntegerCache 默认情况下范围为：-128~127。</p>
<p>本题中的 127 命中了 IntegerCache，所以 c 和 d 是相同对象，而 128 则没有命中，所以 a 和 b 是不同对象。</p>
<p>但是这个缓存范围时可以修改的，可能有些人不知道。可以通过JVM启动参数：-XX:AutoBoxCacheMax&#x3D; 来修改上限值，如下图所示：</p>
<img data-src="/2022/10/01/technology/java/java_review/image_1.png" class="" title="image.png">

<h3 id="用最有效率的方法计算2乘以8？"><a href="#用最有效率的方法计算2乘以8？" class="headerlink" title="用最有效率的方法计算2乘以8？"></a>用最有效率的方法计算2乘以8？</h3><p>2 &lt;&lt; 3。</p>
<p>进阶：通常情况下，可以认为位运算是性能最高的。但是，其实编译器现在已经“非常聪明了”，很多指令编译器都能自己做优化。所以在实际实用中，我们无需特意去追求实用位运算，这样不仅会导致代码可读性很差，而且某些自作聪明的优化反而会误导编译器，使得编译器无法进行更好的优化。</p>
<h3 id="和-的区别？"><a href="#和-的区别？" class="headerlink" title="&amp;和&amp;&amp;的区别？"></a>&amp;和&amp;&amp;的区别？</h3><p>&amp;&amp;：逻辑与运算符。当运算符左右两边的表达式都为 true，才返回 true。同时具有短路性，如果第一个表达式为 false，则直接返回 false。</p>
<p>&amp;：逻辑与运算符、按位与运算符。</p>
<p>按位与运算符：用于二进制的计算，只有对应的两个二进位均为1时，结果位才为1 ，否则为0。</p>
<p>逻辑与运算符：&amp; 在用于逻辑与时，和 &amp;&amp; 的区别是不具有短路性。所在通常使用逻辑与运算符都会使用 &amp;&amp;，而 &amp; 更多的适用于位运算。</p>
<h3 id="String-是-Java-基本数据类型吗？"><a href="#String-是-Java-基本数据类型吗？" class="headerlink" title="String 是 Java 基本数据类型吗？"></a>String 是 Java 基本数据类型吗？</h3><p>答：不是。Java 中的基本数据类型只有8个：byte、short、int、long、float、double、char、boolean；除了基本类型（primitive type），剩下的都是引用类型（reference type）。</p>
<p>基本数据类型：数据直接存储在栈上</p>
<p>引用数据类型区别：数据存储在堆上，栈上只存储引用地址</p>
<h3 id="String-类可以继承吗？"><a href="#String-类可以继承吗？" class="headerlink" title="String 类可以继承吗？"></a>String 类可以继承吗？</h3><p>不行。String 类使用 final 修饰，无法被继承。</p>
<h3 id="String和StringBuilder、StringBuffer的区别？"><a href="#String和StringBuilder、StringBuffer的区别？" class="headerlink" title="String和StringBuilder、StringBuffer的区别？"></a>String和StringBuilder、StringBuffer的区别？</h3><p>String：String 的值被创建后不能修改，任何对 String 的修改都会引发新的 String 对象的生成。</p>
<p>StringBuffer：跟 String 类似，但是值可以被修改，使用 synchronized 来保证线程安全。</p>
<p>StringBuilder：StringBuffer 的非线程安全版本，没有使用 synchronized，具有更高的性能，推荐优先使用。</p>
<h3 id="String-s-new-String-“xyz”-创建了几个字符串对象？"><a href="#String-s-new-String-“xyz”-创建了几个字符串对象？" class="headerlink" title="String s &#x3D; new String(“xyz”) 创建了几个字符串对象？"></a>String s &#x3D; new String(“xyz”) 创建了几个字符串对象？</h3><p>一个或两个。如果字符串常量池已经有“xyz”，则是一个；否则，两个。</p>
<p>当字符创常量池没有 “xyz”，此时会创建如下两个对象：</p>
<p>一个是字符串字面量 “xyz” 所对应的、驻留（intern）在一个全局共享的字符串常量池中的实例，此时该实例也是在堆中，字符串常量池只放引用。</p>
<p>另一个是通过 new String() 创建并初始化的，内容与”xyz”相同的实例，也是在堆中。</p>
<h3 id="String-s-“xyz”-和-String-s-new-String-“xyz”-区别？"><a href="#String-s-“xyz”-和-String-s-new-String-“xyz”-区别？" class="headerlink" title="String s &#x3D; “xyz” 和 String s &#x3D; new String(“xyz”) 区别？"></a>String s &#x3D; “xyz” 和 String s &#x3D; new String(“xyz”) 区别？</h3><p>两个语句都会先去字符串常量池中检查是否已经存在 “xyz”，如果有则直接使用，如果没有则会在常量池中创建 “xyz” 对象。</p>
<p>另外，String s &#x3D; new String(“xyz”) 还会通过 new String() 在堆里创建一个内容与 “xyz” 相同的对象实例。</p>
<p>所以前者其实理解为被后者的所包含。</p>
<h3 id="和-equals-的区别是什么？"><a href="#和-equals-的区别是什么？" class="headerlink" title="&#x3D;&#x3D; 和 equals 的区别是什么？"></a>&#x3D;&#x3D; 和 equals 的区别是什么？</h3><p>&#x3D;&#x3D;：运算符，用于比较基础类型变量和引用类型变量。</p>
<p>对于基础类型变量，比较的变量保存的值是否相同，类型不一定要相同。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">short</span> s1 = <span class="number">1</span>; <span class="type">long</span> l1 = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 结果：true。类型不同，但是值相同</span></span><br><span class="line">System.out.<span class="built_in">println</span>(s1 == l1);</span><br></pre></td></tr></table></figure>


<p>对于引用类型变量，比较的是两个对象的地址是否相同。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Integer i1 = <span class="keyword">new</span> <span class="built_in">Integer</span>(<span class="number">1</span>);</span><br><span class="line">Integer i2 = <span class="keyword">new</span> <span class="built_in">Integer</span>(<span class="number">1</span>);</span><br><span class="line"><span class="comment">// 结果：false。通过new创建，在内存中指向两个不同的对象</span></span><br><span class="line">System.out.<span class="built_in">println</span>(i1 == i2);</span><br></pre></td></tr></table></figure>


<p>equals：Object 类中定义的方法，通常用于比较两个对象的值是否相等。</p>
<p>equals 在 Object 方法中其实等同于 &#x3D;&#x3D;，但是在实际的使用中，equals 通常被重写用于比较两个对象的值是否相同。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Integer i1 = <span class="keyword">new</span> <span class="built_in">Integer</span>(<span class="number">1</span>);</span><br><span class="line">Integer i2 = <span class="keyword">new</span> <span class="built_in">Integer</span>(<span class="number">1</span>);</span><br><span class="line"><span class="comment">// 结果：true。两个不同的对象，但是具有相同的值</span></span><br><span class="line">System.out.<span class="built_in">println</span>(i<span class="number">1.</span><span class="built_in">equals</span>(i2));</span><br><span class="line"><span class="comment">// Integer的equals重写方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> boolean <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (obj instanceof Integer) &#123;</span><br><span class="line">    <span class="comment">// 比较对象中保存的值是否相同</span></span><br><span class="line">        <span class="keyword">return</span> value == ((Integer)obj).<span class="built_in">intValue</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="两个对象的-hashCode-相同，则-equals-也一定为-true，对吗？"><a href="#两个对象的-hashCode-相同，则-equals-也一定为-true，对吗？" class="headerlink" title="两个对象的 hashCode() 相同，则 equals() 也一定为 true，对吗？"></a>两个对象的 hashCode() 相同，则 equals() 也一定为 true，对吗？</h3><p>不对。hashCode() 和 equals() 之间的关系如下：</p>
<p>当有 a.equals(b) &#x3D;&#x3D; true 时，则 a.hashCode() &#x3D;&#x3D; b.hashCode() 必然成立，</p>
<p>反过来，当 a.hashCode() &#x3D;&#x3D; b.hashCode() 时，a.equals(b) 不一定为 true。</p>
<h3 id="什么是反射"><a href="#什么是反射" class="headerlink" title="什么是反射"></a>什么是反射</h3><p>反射是指在运行状态中，对于任意一个类都能够知道这个类所有的属性和方法；并且对于任意一个对象，都能够调用它的任意一个方法；这种动态获取信息以及动态调用对象方法的功能称为反射机制。</p>
<h3 id="深拷贝和浅拷贝区别是什么？"><a href="#深拷贝和浅拷贝区别是什么？" class="headerlink" title="深拷贝和浅拷贝区别是什么？"></a>深拷贝和浅拷贝区别是什么？</h3><p>数据分为基本数据类型和引用数据类型。基本数据类型：数据直接存储在栈中；引用数据类型：存储在栈中的是对象的引用地址，真实的对象数据存放在堆内存里。</p>
<p>浅拷贝：对于基础数据类型：直接复制数据值；对于引用数据类型：只是复制了对象的引用地址，新旧对象指向同一个内存地址，修改其中一个对象的值，另一个对象的值随之改变。</p>
<p>深拷贝：对于基础数据类型：直接复制数据值；对于引用数据类型：开辟新的内存空间，在新的内存空间里复制一个一模一样的对象，新老对象不共享内存，修改其中一个对象的值，不会影响另一个对象。</p>
<p>深拷贝相比于浅拷贝速度较慢并且花销较大。</p>
<h3 id="并发和并行有什么区别？"><a href="#并发和并行有什么区别？" class="headerlink" title="并发和并行有什么区别？"></a>并发和并行有什么区别？</h3><p>并发：两个或多个事件在同一时间间隔发生。</p>
<p>并行：两个或者多个事件在同一时刻发生。</p>
<p>并行是真正意义上，同一时刻做多件事情，而并发在同一时刻只会做一件事件，只是可以将时间切碎，交替做多件事情。</p>
<p>网上有个例子挺形象的：</p>
<p>你吃饭吃到一半，电话来了，你一直到吃完了以后才去接，这就说明你不支持并发也不支持并行。</p>
<p>你吃饭吃到一半，电话来了，你停了下来接了电话，接完后继续吃饭，这说明你支持并发。</p>
<p>你吃饭吃到一半，电话来了，你一边打电话一边吃饭，这说明你支持并行。</p>
<h3 id="构造器是否可被-重写"><a href="#构造器是否可被-重写" class="headerlink" title="构造器是否可被 重写?"></a>构造器是否可被 重写?</h3><p>Constructor 不能被 override（重写），但是可以 overload（重载），所以你可以看到⼀个类中有多个构造函数的情况。</p>
<h3 id="当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递？"><a href="#当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递？" class="headerlink" title="当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递？"></a>当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递？</h3><p>值传递。Java 中只有值传递，对于对象参数，值的内容是对象的引用。</p>
<h3 id="Java-静态变量和成员变量的区别。"><a href="#Java-静态变量和成员变量的区别。" class="headerlink" title="Java 静态变量和成员变量的区别。"></a>Java 静态变量和成员变量的区别。</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 静态变量：又称类变量，static修饰</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">static</span> String STATIC_VARIABLE = <span class="string">&quot;静态变量&quot;</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 实例变量：又称成员变量，没有static修饰</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> String INSTANCE_VARIABLE = <span class="string">&quot;实例变量&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>成员变量存在于堆内存中。静态变量存在于方法区中。</p>
<p>成员变量与对象共存亡，随着对象创建而存在，随着对象被回收而释放。静态变量与类共存亡，随着类的加载而存在，随着类的消失而消失。</p>
<p>成员变量所属于对象，所以也称为实例变量。静态变量所属于类，所以也称为类变量。</p>
<p>成员变量只能被对象所调用 。静态变量可以被对象调用，也可以被类名调用。</p>
<h3 id="是否可以从一个静态（static）方法内部发出对非静态（non-static）方法的调用？"><a href="#是否可以从一个静态（static）方法内部发出对非静态（non-static）方法的调用？" class="headerlink" title="是否可以从一个静态（static）方法内部发出对非静态（non-static）方法的调用？"></a>是否可以从一个静态（static）方法内部发出对非静态（non-static）方法的调用？</h3><p>区分两种情况，发出调用时是否显示创建了对象实例。</p>
<p>1）没有显示创建对象实例：不可以发起调用，非静态方法只能被对象所调用，静态方法可以通过对象调用，也可以通过类名调用，所以静态方法被调用时，可能还没有创建任何实例对象。因此通过静态方法内部发出对非静态方法的调用，此时可能无法知道非静态方法属于哪个对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">staticMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 直接调用非静态方法：编译报错</span></span><br><span class="line">        instanceMethod();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">instanceMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;非静态方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>2）显示创建对象实例：可以发起调用，在静态方法中显示的创建对象实例，则可以正常的调用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">staticMethod</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">// 先创建实例对象，再调用非静态方法：成功执行</span></span><br><span class="line"><span class="type">Demo</span> <span class="variable">demo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Demo</span>();</span><br><span class="line">demo.instanceMethod();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">instanceMethod</span><span class="params">()</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;非静态方法&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="初始化考察，请指出下面程序的运行结果。"><a href="#初始化考察，请指出下面程序的运行结果。" class="headerlink" title="初始化考察，请指出下面程序的运行结果。"></a>初始化考察，请指出下面程序的运行结果。</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InitialTest</span> &#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="type">static</span> <span class="type">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">A ab = <span class="keyword">new</span> <span class="built_in">B</span>();</span><br><span class="line">ab = <span class="keyword">new</span> <span class="built_in">B</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="type">static</span> &#123; <span class="comment">// 父类静态代码块</span></span><br><span class="line">System.out.<span class="built_in">print</span>(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">A</span><span class="params">()</span> </span>&#123; <span class="comment">// 父类构造器</span></span><br><span class="line">System.out.<span class="built_in">print</span>(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> extends A &#123;</span><br><span class="line"><span class="type">static</span> &#123; <span class="comment">// 子类静态代码块</span></span><br><span class="line">System.out.<span class="built_in">print</span>(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">B</span><span class="params">()</span> </span>&#123; <span class="comment">// 子类构造器</span></span><br><span class="line">System.out.<span class="built_in">print</span>(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>执行结果：ABabab，两个考察点：</p>
<p>1）静态变量只会初始化（执行）一次。</p>
<p>2）当有父类时，完整的初始化顺序为：父类静态变量（静态代码块）-&gt;子类静态变量（静态代码块）-&gt;父类非静态变量（非静态代码块）-&gt;父类构造器 -&gt;子类非静态变量（非静态代码块）-&gt;子类构造器 。</p>
<p>关于初始化，这题算入门题，我之前还写过一道有（fei）点（chang）意（bian）思（tai）的进阶题目，有兴趣的可以看看：<a href="https://blog.csdn.net/v123411739/article/details/79600228">一道有意思的“初始化”面试题</a></p>
<h3 id="重载（Overload）和重写（Override）的区别？"><a href="#重载（Overload）和重写（Override）的区别？" class="headerlink" title="重载（Overload）和重写（Override）的区别？"></a>重载（Overload）和重写（Override）的区别？</h3><p>方法的重载和重写都是实现多态的方式，区别在于前者实现的是编译时的多态性，而后者实现的是运行时的多态性。</p>
<p>重载：一个类中有多个同名的方法，但是具有有不同的参数列表（参数类型不同、参数个数不同或者二者都不同）。</p>
<p>重写：发生在子类与父类之间，子类对父类的方法进行重写，参数都不能改变，返回值类型可以不相同，但是必须是父类返回值的派生类。即外壳不变，核心重写！重写的好处在于子类可以根据需要，定义特定于自己的行为。</p>
<h3 id="为什么不能根据返回类型来区分重载？"><a href="#为什么不能根据返回类型来区分重载？" class="headerlink" title="为什么不能根据返回类型来区分重载？"></a>为什么不能根据返回类型来区分重载？</h3><p>如果我们有两个方法如下，当我们调用：test(1) 时，编译器无法确认要调用的是哪个。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 方法1</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">test</span><span class="params">(<span class="type">int</span> a)</span></span>;</span><br><span class="line"><span class="comment">// 方法2</span></span><br><span class="line"><span class="function"><span class="type">long</span> <span class="title">test</span><span class="params">(<span class="type">int</span> a)</span></span>;</span><br></pre></td></tr></table></figure>


<p>方法的返回值只是作为方法运行之后的一个“状态”，但是并不是所有调用都关注返回值，所以不能将返回值作为重载的唯一区分条件。</p>
<h3 id="抽象类（abstract-class）和接口（interface）有什么区别？"><a href="#抽象类（abstract-class）和接口（interface）有什么区别？" class="headerlink" title="抽象类（abstract class）和接口（interface）有什么区别？"></a>抽象类（abstract class）和接口（interface）有什么区别？</h3><p>抽象类只能单继承，接口可以多实现。</p>
<p>抽象类可以有构造方法，接口中不能有构造方法。</p>
<p>抽象类中可以有成员变量，接口中没有成员变量，只能有常量（默认就是 public static final）</p>
<p>抽象类中可以包含非抽象的方法，在 Java 7 之前接口中的所有方法都是抽象的，在 Java 8 之后，接口支持非抽象方法：default 方法、静态方法等。Java 9 支持私有方法、私有静态方法。</p>
<p>抽象类中的抽象方法类型可以是任意修饰符，Java 8 之前接口中的方法只能是 public 类型，Java 9 支持 private 类型。</p>
<p>设计思想的区别：</p>
<p>接口是自上而下的抽象过程，接口规范了某些行为，是对某一行为的抽象。我需要这个行为，我就去实现某个接口，但是具体这个行为怎么实现，完全由自己决定。</p>
<p>抽象类是自下而上的抽象过程，抽象类提供了通用实现，是对某一类事物的抽象。我们在写实现类的时候，发现某些实现类具有几乎相同的实现，因此我们将这些相同的实现抽取出来成为抽象类，然后如果有一些差异点，则可以提供抽象方法来支持自定义实现。</p>
<p>我在网上看到有个说法，挺形象的：</p>
<p>普通类像亲爹 ，他有啥都是你的。</p>
<p>抽象类像叔伯，有一部分会给你，还能指导你做事的方法。</p>
<p>接口像干爹，可以给你指引方法，但是做成啥样得你自己努力实现。</p>
<h3 id="Error-和-Exception-有什么区别？"><a href="#Error-和-Exception-有什么区别？" class="headerlink" title="Error 和 Exception 有什么区别？"></a>Error 和 Exception 有什么区别？</h3><p>Error 和 Exception 都是 Throwable 的子类，用于表示程序出现了不正常的情况。区别在于：</p>
<p>Error 表示系统级的错误和程序不必处理的异常，是恢复不是不可能但很困难的情况下的一种严重问题，比如内存溢出，不可能指望程序能处理这样的情况。</p>
<p>Exception 表示需要捕捉或者需要程序进行处理的异常，是一种设计或实现问题，也就是说，它表示如果程序运行正常，从不会发生的情况。</p>
<h3 id="Java-中的-final-关键字有哪些用法？"><a href="#Java-中的-final-关键字有哪些用法？" class="headerlink" title="Java 中的 final 关键字有哪些用法？"></a>Java 中的 final 关键字有哪些用法？</h3><p>修饰类：该类不能再派生出新的子类，不能作为父类被继承。因此，一个类不能同时被声明为abstract 和 final。</p>
<p>修饰方法：该方法不能被子类重写。</p>
<p>修饰变量：该变量必须在声明时给定初值，而在以后只能读取，不可修改。 如果变量是对象，则指的是引用不可修改，但是对象的属性还是可以修改的</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FinalDemo</span> &#123;</span><br><span class="line"><span class="comment">// 不可再修改该变量的值</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">static</span> <span class="keyword">final</span> <span class="type">int</span> FINAL_VARIABLE = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 不可再修改该变量的引用，但是可以直接修改属性值</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">static</span> <span class="keyword">final</span> User USER = <span class="keyword">new</span> <span class="built_in">User</span>();</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="type">static</span> <span class="type">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 输出：User(id=0, name=null, age=0)</span></span><br><span class="line">System.out.<span class="built_in">println</span>(USER);</span><br><span class="line"><span class="comment">// 直接修改属性值</span></span><br><span class="line">USER.<span class="built_in">setName</span>(<span class="string">&quot;test&quot;</span>);</span><br><span class="line"><span class="comment">// 输出：User(id=0, name=test, age=0)</span></span><br><span class="line">System.out.<span class="built_in">println</span>(USER);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="阐述-final、finally、finalize-的区别。"><a href="#阐述-final、finally、finalize-的区别。" class="headerlink" title="阐述 final、finally、finalize 的区别。"></a>阐述 final、finally、finalize 的区别。</h3><p>其实是三个完全不相关的东西，只是长的有点像。。</p>
<p>final 如上所示。</p>
<p>finally：finally 是对 Java 异常处理机制的最佳补充，通常配合 try、catch 使用，用于存放那些无论是否出现异常都一定会执行的代码。在实际使用中，通常用于释放锁、数据库连接等资源，把资源释放方法放到 finally 中，可以大大降低程序出错的几率。</p>
<p>finalize：Object 中的方法，在垃圾收集器将对象从内存中清除出去之前做必要的清理工作。finalize()方法仅作为了解即可，在 Java 9 中该方法已经被标记为废弃，并添加新的 java.lang.ref.Cleaner，提供了更灵活和有效的方法来释放资源。这也侧面说明了，这个方法的设计是失败的，因此更加不能去使用它。</p>
<h3 id="try、catch、finally-考察，请指出下面程序的运行结果。"><a href="#try、catch、finally-考察，请指出下面程序的运行结果。" class="headerlink" title="try、catch、finally 考察，请指出下面程序的运行结果。"></a>try、catch、finally 考察，请指出下面程序的运行结果。</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TryDemo</span> &#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="type">static</span> <span class="type">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">System.out.<span class="built_in">println</span>(<span class="built_in">test</span>());</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="type">static</span> <span class="type">int</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125; <span class="built_in">catch</span> (Exception e) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">System.out.<span class="built_in">print</span>(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>执行结果：31。</p>
<p>相信很多同学应该都做对了，try、catch。finally 的基础用法，在 return 前会先执行 finally 语句块，所以是先输出 finally 里的 3，再输出 return 的 1。</p>
<h3 id="try、catch、finally-考察2，请指出下面程序的运行结果。"><a href="#try、catch、finally-考察2，请指出下面程序的运行结果。" class="headerlink" title="try、catch、finally 考察2，请指出下面程序的运行结果。"></a>try、catch、finally 考察2，请指出下面程序的运行结果。</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TryDemo</span> &#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="type">static</span> <span class="type">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">System.out.<span class="built_in">println</span>(<span class="built_in">test1</span>());</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="type">static</span> <span class="type">int</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125; finally &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>执行结果：3。</p>
<p>这题有点先将，但也不难，try 返回前先执行 finally，结果 finally 里不按套路出牌，直接 return 了，自然也就走不到 try 里面的 return 了。</p>
<p>finally 里面使用 return 仅存在于面试题中，实际开发中千万不要这么用。</p>
<h3 id="try、catch、finally-考察3，请指出下面程序的运行结果。"><a href="#try、catch、finally-考察3，请指出下面程序的运行结果。" class="headerlink" title="try、catch、finally 考察3，请指出下面程序的运行结果。"></a>try、catch、finally 考察3，请指出下面程序的运行结果。</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TryDemo</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="type">static</span> <span class="type">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="built_in">test1</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="type">static</span> <span class="type">int</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            i = <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            i = <span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>执行结果：2。</p>
<p>这边估计有不少同学会以为结果应该是 3，因为我们知道在 return 前会执行 finally，而 i 在 finally 中被修改为 3 了，那最终返回 i 不是应该为 3 吗？确实很容易这么想，我最初也是这么想的，当初的自己还是太年轻了啊。</p>
<p>这边的根本原因是，在执行 finally 之前，JVM 会先将 i 的结果暂存起来，然后 finally 执行完毕后，会返回之前暂存的结果，而不是返回 i，所以即使这边 i 已经被修改为 3，最终返回的还是之前暂存起来的结果 2。</p>
<p>这边其实根据字节码可以很容易看出来，在进入 finally 之前，JVM 会使用 iload、istore 两个指令，将结果暂存，在最终返回时在通过 iload、ireturn 指令返回暂存的结果。</p>
<h3 id="JDK1-8之后有哪些新特性？"><a href="#JDK1-8之后有哪些新特性？" class="headerlink" title="JDK1.8之后有哪些新特性？"></a>JDK1.8之后有哪些新特性？</h3><p>接口默认方法：Java 8允许我们给接口添加一个非抽象的方法实现，只需要使用 default关键字即可</p>
<p>Lambda 表达式和函数式接口：Lambda 表达式本质上是一段匿名内部类，也可以是一段可以传递的代码。Lambda 允许把函数作为一个方法的参数（函数作为参数传递到方法中），使用 Lambda 表达式使代码更加简洁，但是也不要滥用，否则会有可读性等问题，《Effective Java》作者 Josh Bloch 建议使用 Lambda 表达式最好不要超过3行。</p>
<p>Stream API：用函数式编程方式在集合类上进行复杂操作的工具，配合Lambda表达式可以方便的对集合进行处理。Java8 中处理集合的关键抽象概念，它可以指定你希望对集合进行的操作，可以执行非常复杂的查找、过滤和映射数据等操作。使用Stream API 对集合数据进行操作，就类似于使用 SQL 执行的数据库查询。也可以使用 Stream API 来并行执行操作。简而言之，Stream API 提供了一种高效且易于使用的处理数据的方式。</p>
<p>方法引用：方法引用提供了非常有用的语法，可以直接引用已有Java类或对象（实例）的方法或构造器。与lambda联合使用，方法引用可以使语言的构造更紧凑简洁，减少冗余代码。</p>
<p>日期时间API：Java 8 引入了新的日期时间API改进了日期时间的管理。</p>
<p>Optional 类：著名的 NullPointerException 是引起系统失败最常见的原因。很久以前 Google Guava 项目引入了 Optional 作为解决空指针异常的一种方式，不赞成代码被 null 检查的代码污染，期望程序员写整洁的代码。受Google Guava的鼓励，Optional 现在是Java 8库的一部分。</p>
<p>新工具：新的编译工具，如：Nashorn引擎 jjs、 类依赖分析器 jdeps。</p>
<h3 id="wait-和-sleep-方法的区别"><a href="#wait-和-sleep-方法的区别" class="headerlink" title="wait() 和 sleep() 方法的区别"></a>wait() 和 sleep() 方法的区别</h3><p>来源不同：sleep() 来自 Thread 类，wait() 来自 Object 类。</p>
<p>对于同步锁的影响不同：sleep() 不会该表同步锁的行为，如果当前线程持有同步锁，那么 sleep 是不会让线程释放同步锁的。wait() 会释放同步锁，让其他线程进入 synchronized 代码块执行。</p>
<p>使用范围不同：sleep() 可以在任何地方使用。wait() 只能在同步控制方法或者同步控制块里面使用，否则会抛 IllegalMonitorStateException。</p>
<p>恢复方式不同：两者会暂停当前线程，但是在恢复上不太一样。sleep() 在时间到了之后会重新恢复；wait() 则需要其他线程调用同一对象的 notify()&#x2F;nofityAll() 才能重新恢复。</p>
<h3 id="线程的-sleep-方法和-yield-方法有什么区别？"><a href="#线程的-sleep-方法和-yield-方法有什么区别？" class="headerlink" title="线程的 sleep() 方法和 yield() 方法有什么区别？"></a>线程的 sleep() 方法和 yield() 方法有什么区别？</h3><p>线程执行 sleep() 方法后进入超时等待（TIMED_WAITING）状态，而执行 yield() 方法后进入就绪（READY）状态。</p>
<p>sleep() 方法给其他线程运行机会时不考虑线程的优先级，因此会给低优先级的线程运行的机会；yield() 方法只会给相同优先级或更高优先级的线程以运行的机会。</p>
<h3 id="线程的-join-方法是干啥用的？"><a href="#线程的-join-方法是干啥用的？" class="headerlink" title="线程的 join() 方法是干啥用的？"></a>线程的 join() 方法是干啥用的？</h3><p>用于等待当前线程终止。如果一个线程A执行了 threadB.join() 语句，其含义是：当前线程A等待 threadB 线程终止之后才从 threadB.join() 返回继续往下执行自己的代码。</p>
<h3 id="编写多线程程序有几种实现方式？"><a href="#编写多线程程序有几种实现方式？" class="headerlink" title="编写多线程程序有几种实现方式？"></a>编写多线程程序有几种实现方式？</h3><p>通常来说，可以认为有三种方式：1）继承 Thread 类；2）实现 Runnable 接口；3）实现 Callable 接口。</p>
<p>其中，Thread 其实也是实现了 Runable 接口。Runnable 和 Callable 的主要区别在于是否有返回值。</p>
<h3 id="Thread-调用-start-方法和调用-run-方法的区别"><a href="#Thread-调用-start-方法和调用-run-方法的区别" class="headerlink" title="Thread 调用 start() 方法和调用 run() 方法的区别"></a>Thread 调用 start() 方法和调用 run() 方法的区别</h3><p>run()：普通的方法调用，在主线程中执行，不会新建一个线程来执行。</p>
<p>start()：新启动一个线程，这时此线程处于就绪（可运行）状态，并没有运行，一旦得到 CPU 时间片，就开始执行 run() 方法。</p>
<h3 id="线程的状态流转"><a href="#线程的状态流转" class="headerlink" title="线程的状态流转"></a>线程的状态流转</h3><img data-src="/2022/10/01/technology/java/java_review/image_2.png" class="" title="image.png">

<p>一个线程可以处于以下状态之一：</p>
<p>NEW：新建但是尚未启动的线程处于此状态，没有调用 start() 方法。</p>
<p>RUNNABLE：包含就绪（READY）和运行中（RUNNING）两种状态。线程调用 start() 方法会会进入就绪（READY）状态，等待获取 CPU 时间片。如果成功获取到 CPU 时间片，则会进入运行中（RUNNING）状态。</p>
<p>BLOCKED：线程在进入同步方法&#x2F;同步块（synchronized）时被阻塞，等待同步锁的线程处于此状态。</p>
<p>WAITING：无限期等待另一个线程执行特定操作的线程处于此状态，需要被显示的唤醒，否则会一直等待下去。例如对于 Object.wait()，需要等待另一个线程执行 Object.notify() 或 Object.notifyAll()；对于 Thread.join()，则需要等待指定的线程终止。</p>
<p>TIMED_WAITING：在指定的时间内等待另一个线程执行某项操作的线程处于此状态。跟 WAITING 类似，区别在于该状态有超时时间参数，在超时时间到了后会自动唤醒，避免了无期限的等待。</p>
<p>TERMINATED：执行完毕已经退出的线程处于此状态。</p>
<p>线程在给定的时间点只能处于一种状态。这些状态是虚拟机状态，不反映任何操作系统线程状态。</p>
<h3 id="synchronized-和-Lock-的区别"><a href="#synchronized-和-Lock-的区别" class="headerlink" title="synchronized 和 Lock 的区别"></a>synchronized 和 Lock 的区别</h3><p>1）Lock 是一个接口；synchronized 是 Java 中的关键字，synchronized 是内置的语言实现；</p>
<p>2）Lock 在发生异常时，如果没有主动通过 unLock() 去释放锁，很可能会造成死锁现象，因此使用 Lock 时需要在 finally 块中释放锁；synchronized 不需要手动获取锁和释放锁，在发生异常时，会自动释放锁，因此不会导致死锁现象发生；</p>
<p>3）Lock 的使用更加灵活，可以有响应中断、有超时时间等；而 synchronized 却不行，使用 synchronized 时，等待的线程会一直等待下去，直到获取到锁；</p>
<p>4）在性能上，随着近些年 synchronized 的不断优化，Lock 和 synchronized 在性能上已经没有很明显的差距了，所以性能不应该成为我们选择两者的主要原因。官方推荐尽量使用 synchronized，除非 synchronized 无法满足需求时，则可以使用 Lock。</p>
<h3 id="synchronized-各种加锁场景的作用范围"><a href="#synchronized-各种加锁场景的作用范围" class="headerlink" title="synchronized 各种加锁场景的作用范围"></a>synchronized 各种加锁场景的作用范围</h3><p>1.作用于非静态方法，锁住的是对象实例（this），每一个对象实例有一个锁。</p>
<figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="code"><pre><span class="line">public synchronized void method() &#123;&#125;</span><br></pre></td></tr></table></figure>


<p>2.作用于静态方法，锁住的是类的Class对象，因为Class的相关数据存储在永久代元空间，元空间是全局共享的，因此静态方法锁相当于类的一个全局锁，会锁所有调用该方法的线程。</p>
<figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="code"><pre><span class="line">public static synchronized void method() &#123;&#125;</span><br></pre></td></tr></table></figure>


<p>3.作用于 Lock.class，锁住的是 Lock 的Class对象，也是全局只有一个。</p>
<figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="code"><pre><span class="line">synchronized (Lock.class) &#123;&#125;</span><br></pre></td></tr></table></figure>


<p>4.作用于 this，锁住的是对象实例，每一个对象实例有一个锁。</p>
<figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="code"><pre><span class="line">synchronized (this) &#123;&#125;</span><br></pre></td></tr></table></figure>


<p>5.作用于静态成员变量，锁住的是该静态成员变量对象，由于是静态变量，因此全局只有一个。</p>
<figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="code"><pre><span class="line">public static Object monitor = new Object(); synchronized (monitor) &#123;&#125;</span><br></pre></td></tr></table></figure>


<h3 id="如何检测死锁？"><a href="#如何检测死锁？" class="headerlink" title="如何检测死锁？"></a>如何检测死锁？</h3><p>死锁的四个必要条件：</p>
<p>1）互斥条件：进程对所分配到的资源进行排他性控制，即在一段时间内某资源仅为一个进程所占有。此时若有其他进程请求该资源，则请求进程只能等待。</p>
<p>2）请求和保持条件：进程已经获得了至少一个资源，但又对其他资源发出请求，而该资源已被其他进程占有，此时该进程的请求被阻塞，但又对自己获得的资源保持不放。</p>
<p>3）不可剥夺条件：进程已获得的资源在未使用完毕之前，不可被其他进程强行剥夺，只能由自己释放。</p>
<p>4）环路等待条件：存在一种进程资源的循环等待链，链中每一个进程已获得的资源同时被 链中下一个进程所请求。即存在一个处于等待状态的进程集合{Pl, P2, …, pn}，其中 Pi 等待的资源被 P(i+1) 占有（i&#x3D;0, 1, …, n-1)，Pn 等待的资源被 P0占 有，如下图所示。</p>
<img data-src="/2022/10/01/technology/java/java_review/image_3.png" class="" title="image.png">

<h3 id="怎么预防死锁？"><a href="#怎么预防死锁？" class="headerlink" title="怎么预防死锁？"></a>怎么预防死锁？</h3><p>预防死锁的方式就是打破四个必要条件中的任意一个即可。</p>
<p>1）打破互斥条件：在系统里取消互斥。若资源不被一个进程独占使用，那么死锁是肯定不会发生的。但一般来说在所列的四个条件中，“互斥”条件是无法破坏的。因此，在死锁预防里主要是破坏其他几个必要条件，而不去涉及破坏“互斥”条件。。</p>
<p>2）打破请求和保持条件：1）采用资源预先分配策略，即进程运行前申请全部资源，满足则运行，不然就等待。 2）每个进程提出新的资源申请前，必须先释放它先前所占有的资源。</p>
<p>3）打破不可剥夺条件：当进程占有某些资源后又进一步申请其他资源而无法满足，则该进程必须释放它原来占有的资源。</p>
<p>4）打破环路等待条件：实现资源有序分配策略，将系统的所有资源统一编号，所有进程只能采用按序号递增的形式申请资源。</p>
<h3 id="为什么要使用线程池？直接new个线程不是很舒服？"><a href="#为什么要使用线程池？直接new个线程不是很舒服？" class="headerlink" title="为什么要使用线程池？直接new个线程不是很舒服？"></a>为什么要使用线程池？直接new个线程不是很舒服？</h3><p>如果我们在方法中直接new一个线程来处理，当这个方法被调用频繁时就会创建很多线程，不仅会消耗系统资源，还会降低系统的稳定性，一不小心把系统搞崩了，就可以直接去财务那结帐了。</p>
<p>如果我们合理的使用线程池，则可以避免把系统搞崩的窘境。总得来说，使用线程池可以带来以下几个好处：</p>
<ul>
<li><p>降低资源消耗。通过重复利用已创建的线程，降低线程创建和销毁造成的消耗。</p>
</li>
<li><p>提高响应速度。当任务到达时，任务可以不需要等到线程创建就能立即执行。</p>
</li>
<li><p>增加线程的可管理型。线程是稀缺资源，使用线程池可以进行统一分配，调优和监控。</p>
</li>
</ul>
<h3 id="线程池的核心属性有哪些？"><a href="#线程池的核心属性有哪些？" class="headerlink" title="线程池的核心属性有哪些？"></a>线程池的核心属性有哪些？</h3><p>threadFactory（线程工厂）：用于创建工作线程的工厂。</p>
<p>corePoolSize（核心线程数）：当线程池运行的线程少于 corePoolSize 时，将创建一个新线程来处理请求，即使其他工作线程处于空闲状态。</p>
<p>workQueue（队列）：用于保留任务并移交给工作线程的阻塞队列。</p>
<p>maximumPoolSize（最大线程数）：线程池允许开启的最大线程数。</p>
<p>handler（拒绝策略）：往线程池添加任务时，将在下面两种情况触发拒绝策略：1）线程池运行状态不是 RUNNING；2）线程池已经达到最大线程数，并且阻塞队列已满时。</p>
<p>keepAliveTime（保持存活时间）：如果线程池当前线程数超过 corePoolSize，则多余的线程空闲时间超过 keepAliveTime 时会被终止。</p>
<h3 id="说下线程池的运作流程。"><a href="#说下线程池的运作流程。" class="headerlink" title="说下线程池的运作流程。"></a>说下线程池的运作流程。</h3><img data-src="/2022/10/01/technology/java/java_review/image_4.png" class="" title="image.png">

<h3 id="线程池有哪些拒绝策略？"><a href="#线程池有哪些拒绝策略？" class="headerlink" title="线程池有哪些拒绝策略？"></a>线程池有哪些拒绝策略？</h3><p>AbortPolicy：中止策略。默认的拒绝策略，直接抛出 RejectedExecutionException。调用者可以捕获这个异常，然后根据需求编写自己的处理代码。</p>
<p>DiscardPolicy：抛弃策略。什么都不做，直接抛弃被拒绝的任务。</p>
<p>DiscardOldestPolicy：抛弃最老策略。抛弃阻塞队列中最老的任务，相当于就是队列中下一个将要被执行的任务，然后重新提交被拒绝的任务。如果阻塞队列是一个优先队列，那么“抛弃最旧的”策略将导致抛弃优先级最高的任务，因此最好不要将该策略和优先级队列放在一起使用。</p>
<p>CallerRunsPolicy：调用者运行策略。在调用者线程中执行该任务。该策略实现了一种调节机制，该策略既不会抛弃任务，也不会抛出异常，而是将任务回退到调用者（调用线程池执行任务的主线程），由于执行任务需要一定时间，因此主线程至少在一段时间内不能提交任务，从而使得线程池有时间来处理完正在执行的任务。</p>
<h3 id="List、Set、Map三者的区别"><a href="#List、Set、Map三者的区别" class="headerlink" title="List、Set、Map三者的区别?"></a>List、Set、Map三者的区别?</h3><p>List（对付顺序的好帮手）： List 接口存储一组不唯一（可以有多个元素引用相同的对象）、有序的对象。</p>
<p>Set（注重独一无二的性质）：不允许重复的集合，不会有多个元素引用相同的对象。</p>
<p>Map（用Key来搜索的专业户）: 使用键值对存储。Map 会维护与 Key 有关联的值。两个 Key可以引用相同的对象，但 Key 不能重复，典型的 Key 是String类型，但也可以是任何对象。</p>
<h3 id="ArrayList-和-LinkedList-的区别。"><a href="#ArrayList-和-LinkedList-的区别。" class="headerlink" title="ArrayList 和 LinkedList 的区别。"></a>ArrayList 和 LinkedList 的区别。</h3><p>ArrayList 底层基于动态数组实现，LinkedList 底层基于链表实现。</p>
<p>对于按 index 索引数据（get&#x2F;set方法）：ArrayList 通过 index 直接定位到数组对应位置的节点，而 LinkedList需要从头结点或尾节点开始遍历，直到寻找到目标节点，因此在效率上 ArrayList 优于 LinkedList。</p>
<p>对于随机插入和删除：ArrayList 需要移动目标节点后面的节点（使用System.arraycopy 方法移动节点），而 LinkedList 只需修改目标节点前后节点的 next 或 prev 属性即可，因此在效率上 LinkedList 优于 ArrayList。</p>
<p>对于顺序插入和删除：由于 ArrayList 不需要移动节点，因此在效率上比 LinkedList 更好。这也是为什么在实际使用中 ArrayList 更多，因为大部分情况下我们的使用都是顺序插入。</p>
<h3 id="ArrayList-和-Vector-的区别。"><a href="#ArrayList-和-Vector-的区别。" class="headerlink" title="ArrayList 和 Vector 的区别。"></a>ArrayList 和 Vector 的区别。</h3><p>Vector 和 ArrayList 几乎一致，唯一的区别是 Vector 在方法上使用了 synchronized 来保证线程安全，因此在性能上 ArrayList 具有更好的表现。</p>
<p>有类似关系的还有：StringBuilder 和 StringBuffer、HashMap 和 Hashtable。</p>
<h3 id="介绍下-HashMap-的底层数据结构"><a href="#介绍下-HashMap-的底层数据结构" class="headerlink" title="介绍下 HashMap 的底层数据结构"></a>介绍下 HashMap 的底层数据结构</h3><p>我们现在用的都是 JDK 1.8，底层是由“数组+链表+红黑树”组成，如下图，而在 JDK 1.8 之前是由“数组+链表”组成。</p>
<img data-src="/2022/10/01/technology/java/java_review/image_5.png" class="" title="image.png">

<h3 id="为什么要改成“数组-链表-红黑树”？"><a href="#为什么要改成“数组-链表-红黑树”？" class="headerlink" title="为什么要改成“数组+链表+红黑树”？"></a>为什么要改成“数组+链表+红黑树”？</h3><p>主要是为了提升在 hash 冲突严重时（链表过长）的查找性能，使用链表的查找性能是 O(n)，而使用红黑树是 O(logn)。</p>
<h3 id="那在什么时候用链表？什么时候用红黑树？"><a href="#那在什么时候用链表？什么时候用红黑树？" class="headerlink" title="那在什么时候用链表？什么时候用红黑树？"></a>那在什么时候用链表？什么时候用红黑树？</h3><p>对于插入，默认情况下是使用链表节点。当同一个索引位置的节点在新增后超过8个（阈值8）：如果此时数组长度大于等于 64，则会触发链表节点转红黑树节点（treeifyBin）；而如果数组长度小于64，则不会触发链表转红黑树，而是会进行扩容，因为此时的数据量还比较小。</p>
<p>对于移除，当同一个索引位置的节点在移除后达到 6 个，并且该索引位置的节点为红黑树节点，会触发红黑树节点转链表节点（untreeify）。</p>
<h3 id="HashMap-的默认初始容量是多少？HashMap-的容量有什么限制吗？"><a href="#HashMap-的默认初始容量是多少？HashMap-的容量有什么限制吗？" class="headerlink" title="HashMap 的默认初始容量是多少？HashMap 的容量有什么限制吗？"></a>HashMap 的默认初始容量是多少？HashMap 的容量有什么限制吗？</h3><p>默认初始容量是16。HashMap 的容量必须是2的N次方，HashMap 会根据我们传入的容量计算一个大于等于该容量的最小的2的N次方，例如传 9，容量为16。</p>
<h3 id="HashMap-的插入流程是怎么样的？"><a href="#HashMap-的插入流程是怎么样的？" class="headerlink" title="HashMap 的插入流程是怎么样的？"></a>HashMap 的插入流程是怎么样的？</h3><img data-src="/2022/10/01/technology/java/java_review/image_6.png" class="" title="image.png">

<h3 id="HashMap-的扩容（resize）流程是怎么样的？"><a href="#HashMap-的扩容（resize）流程是怎么样的？" class="headerlink" title="HashMap 的扩容（resize）流程是怎么样的？"></a>HashMap 的扩容（resize）流程是怎么样的？</h3><img data-src="/2022/10/01/technology/java/java_review/image_7.png" class="" title="image.png">



<h3 id="除了-HashMap，还用过哪些-Map，在使用时怎么选择？"><a href="#除了-HashMap，还用过哪些-Map，在使用时怎么选择？" class="headerlink" title="除了 HashMap，还用过哪些 Map，在使用时怎么选择？"></a>除了 HashMap，还用过哪些 Map，在使用时怎么选择？</h3><img data-src="/2022/10/01/technology/java/java_review/image_8.png" class="" title="image.png">

<h3 id="HashMap-和Hashtable-的区别"><a href="#HashMap-和Hashtable-的区别" class="headerlink" title="HashMap 和Hashtable 的区别?"></a>HashMap 和Hashtable 的区别?</h3><p>HashMap 允许 key 和 value 为 null，Hashtable 不允许。</p>
<p>HashMap 的默认初始容量为 16，Hashtable 为 11。</p>
<p>HashMap 的扩容为原来的 2 倍，Hashtable 的扩容为原来的 2 倍加 1。</p>
<p>HashMap 是非线程安全的，Hashtable是线程安全的。</p>
<p>HashMap 的 hash 值重新计算过，Hashtable 直接使用 hashCode。</p>
<p>HashMap 去掉了 Hashtable 中的 contains 方法。</p>
<p>HashMap 继承自 AbstractMap 类，Hashtable 继承自 Dictionary 类。</p>
<h3 id="Java-内存结构（运行时数据区）"><a href="#Java-内存结构（运行时数据区）" class="headerlink" title="Java 内存结构（运行时数据区）"></a>Java 内存结构（运行时数据区）</h3><p>程序计数器：线程私有。一块较小的内存空间，可以看作当前线程所执行的字节码的行号指示器。如果线程正在执行的是一个Java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是Native方法，这个计数器值则为空。</p>
<p>Java虚拟机栈：线程私有。它的生命周期与线程相同。虚拟机栈描述的是Java方法执行的内存模型：每个方法在执行的同时都会创建一个栈帧用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。</p>
<p>本地方法栈：线程私有。本地方法栈与虚拟机栈所发挥的作用是非常相似的，它们之间的区别不过是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则为虚拟机使用到的Native方法服务。</p>
<p>Java堆：线程共享。对大多数应用来说，Java堆是Java虚拟机所管理的内存中最大的一块。Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。</p>
<p>方法区：与Java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息（构造方法、接口定义）、常量、静态变量、即时编译器编译后的代码（字节码）等数据。方法区是JVM规范中定义的一个概念，具体放在哪里，不同的实现可以放在不同的地方。</p>
<p>运行时常量池：运行时常量池是方法区的一部分。Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池，用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放。</p>
<figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="code"><pre><span class="line">String str = new String(&quot;hello&quot;);</span><br></pre></td></tr></table></figure>


<p>上面的语句中变量 str 放在栈上，用 new 创建出来的字符串对象放在堆上，而”hello”这个字面量是放在堆中。</p>
<h3 id="什么是双亲委派模型？"><a href="#什么是双亲委派模型？" class="headerlink" title="什么是双亲委派模型？"></a>什么是双亲委派模型？</h3><p>如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去加载。</p>
<h3 id="Java虚拟机中有哪些类加载器？"><a href="#Java虚拟机中有哪些类加载器？" class="headerlink" title="Java虚拟机中有哪些类加载器？"></a>Java虚拟机中有哪些类加载器？</h3><p><strong>启动类加载器（Bootstrap ClassLoader）：</strong></p>
<p>这个类加载器负责将存放在<JAVA_HOME>\lib目录中的，或者被-Xbootclasspath参数所指定的路径中的，并且是虚拟机识别的（仅按照文件名识别，如rt.jar，名字不符合的类库即使放在lib目录中也不会被加载）类库加载到虚拟机内存中。</p>
<p><strong>扩展类加载器（Extension ClassLoader）：</strong></p>
<p>这个加载器由sun.misc.Launcher$ExtClassLoader实现，它负责加载<JAVA_HOME>\lib\ext目录中的，或者被java.ext.dirs系统变量所指定的路径中的所有类库，开发者可以直接使用扩展类加载器。</p>
<p><strong>应用程序类加载器（Application ClassLoader）：</strong></p>
<p>这个类加载器由sun.misc.Launcher$AppClassLoader实现。由于这个类加载器是ClassLoader中的getSystemClassLoader()方法的返回值，所以一般也称它为系统类加载器。它负责加载用户类路径（ClassPath）上所指定的类库，开发者可以直接使用这个类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。</p>
<p><strong>自定义类加载器：</strong></p>
<p>用户自定义的类加载器。</p>
<h3 id="类加载的过程"><a href="#类加载的过程" class="headerlink" title="类加载的过程"></a>类加载的过程</h3><p>类加载的过程包括：加载、验证、准备、解析、初始化，其中验证、准备、解析统称为连接。</p>
<p>加载：通过一个类的全限定名来获取定义此类的二进制字节流，在内存中生成一个代表这个类的java.lang.Class对象。</p>
<p>验证：确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。</p>
<p>准备：为静态变量分配内存并设置静态变量初始值，这里所说的初始值“通常情况”下是数据类型的零值。</p>
<p>解析：将常量池内的符号引用替换为直接引用。</p>
<p>初始化：到了初始化阶段，才真正开始执行类中定义的 Java 初始化程序代码。主要是静态变量赋值动作和静态语句块（static{}）中的语句。</p>
<h3 id="介绍下垃圾收集机制（在什么时候，对什么，做了什么）？"><a href="#介绍下垃圾收集机制（在什么时候，对什么，做了什么）？" class="headerlink" title="介绍下垃圾收集机制（在什么时候，对什么，做了什么）？"></a>介绍下垃圾收集机制（在什么时候，对什么，做了什么）？</h3><p><strong>在什么时候？</strong></p>
<p>在触发GC的时候，具体如下，这里只说常见的 Young GC 和 Full GC。</p>
<p>触发Young GC：当新生代中的 Eden 区没有足够空间进行分配时会触发Young GC。</p>
<p>触发Full GC：</p>
<ul>
<li><p>当准备要触发一次Young GC时，如果发现统计数据说之前Young GC的平均晋升大小比目前老年代剩余的空间大，则不会触发Young GC而是转为触发Full GC。（通常情况）</p>
</li>
<li><p>如果有永久代的话，在永久代需要分配空间但已经没有足够空间时，也要触发一次Full GC。</p>
</li>
<li><p>System.gc()默认也是触发Full GC。</p>
</li>
<li><p>heap dump带GC默认也是触发Full GC。</p>
</li>
<li><p>CMS GC时出现Concurrent Mode Failure会导致一次Full GC的产生。</p>
</li>
</ul>
<p><strong>对什么？</strong></p>
<p>对那些JVM认为已经“死掉”的对象。即从GC Root开始搜索，搜索不到的，并且经过一次筛选标记没有复活的对象。</p>
<p><strong>做了什么？</strong></p>
<p>对这些JVM认为已经“死掉”的对象进行垃圾收集，新生代使用复制算法，老年代使用标记-清除和标记-整理算法。</p>
<h3 id="GC-Root有哪些"><a href="#GC-Root有哪些" class="headerlink" title="GC Root有哪些?"></a>GC Root有哪些?</h3><p>在Java语言中，可作为GC Roots的对象包括下面几种：</p>
<ul>
<li><p>虚拟机栈（栈帧中的本地变量表）中引用的对象。</p>
</li>
<li><p>方法区中类静态属性引用的对象。</p>
</li>
<li><p>方法区中常量引用的对象。</p>
</li>
<li><p>本地方法栈中JNI（即一般说的Native方法）引用的对象。</p>
</li>
</ul>
<h3 id="垃圾收集有哪些算法，各自的特点？"><a href="#垃圾收集有哪些算法，各自的特点？" class="headerlink" title="垃圾收集有哪些算法，各自的特点？"></a>垃圾收集有哪些算法，各自的特点？</h3><p><strong>标记 - 清除算法</strong></p>
<p>首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。它的主要不足有两个：一个是效率问题，标记和清除两个过程的效率都不高；另一个是空间问题，标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后在程序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。</p>
<p><strong>复制算法</strong></p>
<p>为了解决效率问题，一种称为“复制”（Copying）的收集算法出现了，它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。这样使得每次都是对整个半区进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效。只是这种算法的代价是将内存缩小为了原来的一半，未免太高了一点。</p>
<p><strong>标记 - 整理算法</strong></p>
<p>复制收集算法在对象存活率较高时就要进行较多的复制操作，效率将会变低。更关键的是，如果不想浪费50%的空间，就需要有额外的空间进行分配担保，以应对被使用的内存中所有对象都100%存活的极端情况，所以在老年代一般不能直接选用这种算法。</p>
<p>根据老年代的特点，有人提出了另外一种“标记-整理”（Mark-Compact）算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。</p>
<p><strong>分代收集算法</strong></p>
<p>当前商业虚拟机的垃圾收集都采用“分代收集”（Generational Collection）算法，这种算法并没有什么新的思想，只是根据对象存活周期的不同将内存划分为几块。</p>
<p>一般是把Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。</p>
<p>在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。</p>
<p>在老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用标记—清理或者标记—整理算法来进行回收。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>面试题</tag>
        <tag>Java</tag>
      </tags>
  </entry>
</search>

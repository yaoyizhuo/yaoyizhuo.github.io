<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Welcome to My Blog</title>
    <url>/2018/02/26/home/home/</url>
    <content><![CDATA[<p>zhyyao测试内容,首页的内容还没想好</p>
<img data-src="/2018/02/26/home/home/1.jpg" class="" title="图片1">

<img data-src="/2018/02/26/home/home/2.jpg" class="" title="图片2">

<img data-src="/2018/02/26/home/home/3.jpg" class="" title="图片3">]]></content>
  </entry>
  <entry>
    <title>Go-GC垃圾回收</title>
    <url>/2021/02/02/technology/golang/gc_recycle/</url>
    <content><![CDATA[<h2 id="Go垃圾回收"><a href="#Go垃圾回收" class="headerlink" title="Go垃圾回收"></a>Go垃圾回收</h2><ul>
<li><p>G0 V1.3之前的标记-清除(mark and sweep)算法</p>
</li>
<li><p>Go V1.3之前的标记-清扫(mark and sweep)的缺点</p>
</li>
<li><p>Go V1.5的三色并发标记法</p>
</li>
<li><p>Go V1.5的三色标记为什么需要STW</p>
</li>
<li><p>Go V1.5的三色标记为什么需要屏障机制(“强-弱” 三色不变式、插入屏障、删除屏障 )</p>
</li>
<li><p>Go V1.8混合写屏障机制</p>
</li>
<li><p>Go V1.8混合写屏障机制的全场景分析</p>
</li>
</ul>
<h3 id="Go-V1-3-之前的标记-清除-mark-and-sweep-算法"><a href="#Go-V1-3-之前的标记-清除-mark-and-sweep-算法" class="headerlink" title="Go V1.3 之前的标记-清除(mark and sweep)算法"></a>Go V1.3 之前的标记-清除(mark and sweep)算法</h3><h4 id="步骤："><a href="#步骤：" class="headerlink" title="步骤："></a>步骤：</h4><ul>
<li><p>标记(Mark phase)</p>
</li>
<li><p>清除(Sweep phase)</p>
</li>
</ul>
<p><strong>第一步</strong>，暂停程序业务逻辑, 找出不可达的对象，然后做上标记。</p>
<p>操作非常简单，但是有一点需要额外注意：mark and sweep算法在执行的时候，需要程序暂停！即 <code>STW(stop the world)</code>。也就是说，这段时间程序会卡在哪儿。</p>
<img data-src="/2021/02/02/technology/golang/gc_recycle/image_1.png" class="" title="image.png">

<p><strong>第二步</strong>, 开始标记，程序找出它所有可达的对象，并做上标记。如下图所示：</p>
<img data-src="/2021/02/02/technology/golang/gc_recycle/image_2.png" class="" title="image.png">

<p><strong>第三步,</strong> 标记完了之后，然后开始清除未标记的对象. 结果如下.</p>
<img data-src="/2021/02/02/technology/golang/gc_recycle/image_3.png" class="" title="image.png">

<p><strong>第四步</strong>, 停止暂停，让程序继续跑。然后循环重复这个过程，直到process程序生命周期结束。</p>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul>
<li>STW，stop the world；让程序暂停，程序出现卡顿 (重要问题)。</li>
<li>标记需要扫描整个heap</li>
<li>清除数据会产生heap碎片</li>
</ul>
<p>所以Go V1.3版本之前就是以上来实施的, 流程是</p>
<img data-src="/2021/02/02/technology/golang/gc_recycle/image_4.png" class="" title="image.png">

<p>Go V1.3 做了简单的优化,将STW提前, 减少STW暂停的时间范围.如下所示</p>
<img data-src="/2021/02/02/technology/golang/gc_recycle/image_5.png" class="" title="image.png">

<pre><code>**这里面最重要的问题就是：mark-and-sweep 算法会暂停整个程序。**
</code></pre>
<p>Go是如何面对并这个问题的呢？接下来G V1.5版本 就用三色并发标记法来优化这个问题.</p>
<h3 id="Go-V1-5的三色并发标记法"><a href="#Go-V1-5的三色并发标记法" class="headerlink" title="Go V1.5的三色并发标记法"></a>Go V1.5的三色并发标记法</h3><p>三色标记法 实际上就是通过三个阶段的标记来确定清楚的对象都有哪些. 我们来看一下具体的过程.</p>
<p><strong>第一步</strong>, 就是只要是新创建的对象,默认的颜色都是标记为“白色”.</p>
<img data-src="/2021/02/02/technology/golang/gc_recycle/image_6.png" class="" title="image.png">

<p>这里面需要注意的是, 所谓“程序”, 则是一些对象的跟节点集合.</p>
<p><img data-src="https://tc-cdn.flowus.cn/oss/baa5e1df-bbd4-4fdf-9f2c-1d017c35254b/image.png?time=1740540600&token=ae2b03ecfa946373c66e0e06fc18f5a32bec68d4cad184b219924dfe7faf0fe4&role=free" alt="image.png"></p>
<p>所以上图,可以转换如下的方式来表示.</p>
<p>第二步, 每次GC回收开始, 然后从根节点开始遍历所有对象，把遍历到的对象从白色集合放入“灰色”集合。</p>
<p><img data-src="https://tc-cdn.flowus.cn/oss/2deaa445-5c90-4baf-b826-365395a2456f/image.png?time=1740540600&token=970940446480b161d9a2a6478a8b132f58778a199655a0b45b015567eebc1ee8&role=free" alt="image.png"></p>
<p>第三步, 遍历灰色集合，将灰色对象引用的对象从白色集合放入灰色集合，之后将此灰色对象放入黑色集合</p>
<p><img data-src="https://tc-cdn.flowus.cn/oss/ef6cf7e9-5385-42e4-958f-da9c57294f60/image.png?time=1740540600&token=0cd549762281ff62683165d9af5edbee5ded1eb18415d41544332b4f9af49c2c&role=free" alt="image.png"></p>
<p>第四步, 重复第三步, 直到灰色中无任何对象.</p>
<p><img data-src="https://tc-cdn.flowus.cn/oss/d08f61db-a82f-4aee-b635-4ecb71f99322/image.png?time=1740540600&token=f596e9f3d15e52e19147e471b3590487eab876e031539d80f3aca4b67fe149e7&role=free" alt="image.png"></p>
<p><img data-src="https://tc-cdn.flowus.cn/oss/0ad0d19e-5018-469d-af6a-6e9c4f4bb2fc/image.png?time=1740540600&token=4e667082687739168e53cc1d9b3d878cd6fd2026da53f9bd4da8da773b14e04b&role=free" alt="image.png"></p>
<p>第五步，回收所有的白色标记表的对象. 也就是回收垃圾.</p>
<p><img data-src="https://tc-cdn.flowus.cn/oss/14e66ab4-696c-4581-aa04-cefbdb4cbdc8/image.png?time=1740540600&token=f64cf7c5d2c6f6661f03d9d6417e9e005181fe31736ba7dc6223def8bea72006&role=free" alt="image.png"></p>
<p>  </p>
<p>以上便是<code>三色并发标记法</code>, 不难看出,我们上面已经清楚的体现<code>三色</code>的特性, 那么又是如何实现并行的呢?</p>
<p>_Go是如何解决标记-清除(mark and sweep)算法中的卡顿(stw，stop the world)问题的呢_？</p>
<p>四、没有STW的三色标记法</p>
<pre><code>    我们还是基于上述的三色并发标记法来说, 他是一定要依赖STW的. 因为如果不暂停程序, 程序的逻辑改变对象引用关系, 这种动作如果在标记阶段做了修改，会影响标记结果的正确性。我们举一个场景.
</code></pre>
<p>如果三色标记法, 标记过程不使用STW将会发生什么事情?</p>
<p><img data-src="https://tc-cdn.flowus.cn/oss/5020944e-ff31-4bd4-8d31-89a4907c214a/image.png?time=1740540600&token=ce4434ee5cd821a52f8ca9bb4aa989321585b1eb20da8ab8efc875b4d7f94297&role=free" alt="image.png"></p>
<hr>
<p><img data-src="https://tc-cdn.flowus.cn/oss/672b5c62-0747-438e-acea-7f45c9760723/image.png?time=1740540600&token=0de4ffbf2a1ec099ba85b01acbfaad7d58ea70577b9cf90b4e2ffb5029fe5694&role=free" alt="image.png"></p>
<p><img data-src="https://tc-cdn.flowus.cn/oss/03cf14b9-a12e-4a98-ba0a-35c1e550e431/image.png?time=1740540600&token=9518a8c875aedaf1e9b693f6af086e6b9ec6c083d2be7a8651ec7ac80bec2153&role=free" alt="image.png"></p>
<p><img data-src="https://tc-cdn.flowus.cn/oss/f2a15102-f02f-4cb4-a378-c26b4a953ba3/image.png?time=1740540600&token=18f772923bd5a06dd811ff208f02a580ace3968ec93dee40f0c1ab74cb349b3b&role=free" alt="image.png"></p>
<p><img data-src="https://tc-cdn.flowus.cn/oss/72d06c4e-b9b9-4fae-9c4e-46146f077cd9/image.png?time=1740540600&token=5418c5508b235bf7626fa0a9874a43da874dce70433b707a6e54b93f258fe8e4&role=free" alt="image.png"></p>
<p>可以看出，有两个问题, 在三色标记法中,是不希望被发生的</p>
<ul>
<li><p><strong>条件1:</strong> 一个白色对象被黑色对象引用(白色被挂在黑色下)</p>
</li>
<li><p><strong>条件2:</strong> 灰色对象与它之间的可达关系的白色对象遭到破坏(灰色同时丢了该白色)</p>
</li>
</ul>
<p>当以上两个条件同时满足时, 就会出现对象丢失现象!</p>
<p>当然, 如果上述中的白色对象3, 如果他还有很多下游对象的话, 也会一并都清理掉.</p>
<p>为了防止这种现象的发生，最简单的方式就是STW，直接禁止掉其他用户程序对对象引用关系的干扰，但是STW的过程有明显的资源浪费，对所有的用户程序都有很大影响，如何能在保证对象不丢失的情况下合理的尽可能的提高GC效率，减少STW时间呢？</p>
<p>答案就是, 那么我们只要使用一个机制,来破坏上面的两个条件就可以了.</p>
<p>五、屏障机制</p>
<p>我们让GC回收器,满足下面两种情况之一时,可保对象不丢失. 所以引出两种方式.</p>
<h4 id="“强-弱”-三色不变式"><a href="#“强-弱”-三色不变式" class="headerlink" title="“强-弱” 三色不变式"></a>“强-弱” 三色不变式</h4><p>01</p>
<ul>
<li><strong>强三色不变式</strong></li>
</ul>
<p>不存在黑色对象引用到白色对象的指针。</p>
<p><img data-src="https://tc-cdn.flowus.cn/oss/b3c09a81-13c3-4dea-8fa9-72ff9516a23e/image.png?time=1740540600&token=59aee5fcf493fa2bdddfb0d447aaa1183b9e63ca4eb6b8b0718d9dd107dd0c45&role=free" alt="image.png"></p>
<ul>
<li><strong>弱三色不变式</strong></li>
</ul>
<p>所有被黑色对象引用的白色对象都处于灰色保护状态.</p>
<p><img data-src="https://tc-cdn.flowus.cn/oss/0e764162-f946-4105-a6ed-2f760e805d65/image.png?time=1740540600&token=2bc4b8c5f440f40bf8467e27af5a3dcafa48889d47f84573f87a56bde8ba0abc&role=free" alt="image.png"></p>
<p>为了遵循上述的两个方式,Golang团队初步得到了如下具体的两种屏障方式“插入屏障”, “删除屏障”.</p>
<h4 id="插入屏障"><a href="#插入屏障" class="headerlink" title="插入屏障"></a>插入屏障</h4><p>02</p>
<p><code>具体操作</code>: 在A对象引用B对象的时候，B对象被标记为灰色。(将B挂在A下游，B必须被标记为灰色)</p>
<p><code>满足</code>: 强三色不变式. (不存在黑色对象引用白色对象的情况了， 因为白色会强制变成灰色)</p>
<p>伪码如下:</p>
<p><code>添加下游对象``(``当前下游对象**slot**``,</code> <code>新下游对象**ptr**``) &#123;     //1     标记灰色(``新下游对象**ptr**``)          //2    `` 当前下游对象**slot**</code> <code>=</code> <code>新下游对象**ptr**``   &#125;</code></p>
<p>场景：</p>
<figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="code"><pre><span class="line">A.添加下游对象(nil, B)   //A 之前没有下游， 新添加一个下游对象B， B被标记为灰色</span><br><span class="line">A.添加下游对象(C, B)     //A 将下游对象C 更换为B，  B被标记为灰色</span><br></pre></td></tr></table></figure>


<p>这段伪码逻辑就是写屏障,. 我们知道,黑色对象的内存槽有两种位置, <code>栈</code>和<code>堆</code>. 栈空间的特点是容量小,但是要求相应速度快,因为函数调用弹出频繁使用, 所以“插入屏障”机制,在栈空间的对象操作中不使用. 而仅仅使用在堆空间对象的操作中.</p>
<p>接下来，我们用几张图，来模拟整个一个详细的过程， 希望您能够更可观的看清晰整体流程。</p>
<p><img data-src="https://tc-cdn.flowus.cn/oss/e6f4d697-8809-4d15-b0d1-de4b1237b93f/image.png?time=1740540600&token=22ca2185a69aca061a1d6d3ea497cf0b39a96cd125f549769d675d3c6b4493bc&role=free" alt="image.png"></p>
<p><img data-src="https://tc-cdn.flowus.cn/oss/515d6479-386e-4e81-a500-c35bfd588dfd/image.png?time=1740540600&token=3ea6ed9607acd637aa60b7becf59b3f02046250874bdc9d4cbfd8e1379fd99a8&role=free" alt="image.png"></p>
<p><img data-src="https://tc-cdn.flowus.cn/oss/6a437e45-8e14-480d-b7f4-bb67af1e50fb/image.png?time=1740540600&token=bf1e02f1dc89acae06efecb9cb424585d7c4cbbea284d40bb5f898010ebcefad&role=free" alt="image.png"></p>
<p><img data-src="https://tc-cdn.flowus.cn/oss/39f8b94f-8be1-4f73-954c-2d7155963a45/image.png?time=1740540600&token=c6671e39c2e773f2a916cef083a9855c2f0a286fc52fa934c1bc6f749dcd2e0f&role=free" alt="image.png"></p>
<p><img data-src="https://tc-cdn.flowus.cn/oss/91964183-070c-4346-a50c-8e3a1cdc4358/image.png?time=1740540600&token=7fc185883afede4226b79f66df504ce131157f3a60a84a291183a12acb2296b1&role=free" alt="image.png"></p>
<p><img data-src="https://tc-cdn.flowus.cn/oss/55477941-6d67-4f03-8293-3e2e9ef6c2c1/image.png?time=1740540600&token=0d10321bf4c993c49ada813f5d7534a5f4acd4af3a5027cf68c9a7614c491846&role=free" alt="image.png"></p>
<p>但是如果栈不添加,当全部三色标记扫描之后,栈上有可能依然存在白色对象被引用的情况(如上图的对象9). 所以要对栈重新进行三色标记扫描, 但这次为了对象不丢失, 要对本次标记扫描启动STW暂停. 直到栈空间的三色标记结束.</p>
<p><img data-src="https://tc-cdn.flowus.cn/oss/60586705-27c8-4778-b21b-0ae4216ab02b/image.png?time=1740540600&token=6c3bcb954557a7a70e0f74b3321a93b18b632ae58e3279de3660cc1d79813107&role=free" alt="image.png"></p>
<p><img data-src="https://tc-cdn.flowus.cn/oss/677d4e9f-32c0-43ef-affb-dee59c96d9fa/image.png?time=1740540600&token=81881095546a2f260ba4a94ac39aeaf3990066919f1269c3cd69c5b6fa0f9505&role=free" alt="image.png"></p>
<p><img data-src="https://tc-cdn.flowus.cn/oss/f9b7966f-2997-4b19-903a-fa29f7c8e3d8/image.png?time=1740540600&token=ce7323709600bf490185b7bc46b7f9ce5f48d5db25e1cc1b58425e27396b0b5a&role=free" alt="image.png"></p>
<p>最后将栈和堆空间 扫描剩余的全部 白色节点清除. 这次STW大约的时间在10~100ms间.</p>
<p><img data-src="https://tc-cdn.flowus.cn/oss/e80cc589-874d-409f-b800-cd0a6d6dd6db/image.png?time=1740540600&token=23cd011a99d617f27498fe877a5c5dd0f12a7b6135f36a8a80eb20903ed6f213&role=free" alt="image.png"></p>
<hr>
<h4 id="删除屏障"><a href="#删除屏障" class="headerlink" title="删除屏障"></a>删除屏障</h4><p>03</p>
<p><code>具体操作</code>: 被删除的对象，如果自身为灰色或者白色，那么被标记为灰色。</p>
<p><code>满足</code>: 弱三色不变式. (保护灰色对象到白色对象的路径不会断)</p>
<p>伪代码：</p>
<p><code>添加下游对象``(``当前下游对象**slot**``，</code> <code>新下游对象**ptr**``) &#123;     //1     if (``当前下游对象**slot**``是灰色 ||</code> <code>当前下游对象**slot**``是白色) &#123;             标记灰色(``当前下游对象**slo**``**t**``) //slot为被删除对象， 标记为灰色     &#125;          //2</code>  <code>当前下游对象**slot**</code> <code>=</code> <code>新下游对象**ptr**``   &#125;</code></p>
<p>场景：</p>
<figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="code"><pre><span class="line">A.添加下游对象(B, nil)   //A对象，删除B对象的引用。B被A删除，被标记为灰(如果B之前为白)</span><br><span class="line">A.添加下游对象(B, C)     //A对象，更换下游B变成C。B被A删除，被标记为灰(如果B之前为白)</span><br></pre></td></tr></table></figure>


<p>接下来，我们用几张图，来模拟整个一个详细的过程， 希望您能够更可观的看清晰整体流程。</p>
<p><img data-src="https://tc-cdn.flowus.cn/oss/046d0ff8-2af9-4cdd-a4fc-a3fe12d7fa7d/image.png?time=1740540600&token=365a6c390d144974c57b61a614c7b9654262e7a90d1b3fa9fc78768f8006596b&role=free" alt="image.png"></p>
<p><img data-src="https://tc-cdn.flowus.cn/oss/bb509edd-1db1-4f37-bad9-e5cbcaf624ba/image.png?time=1740540600&token=1e2d1d73b389c4739e93a1e6a5b086109e47c143c3a5cd9c9102fd911ecca4b0&role=free" alt="image.png"></p>
<p><img data-src="https://tc-cdn.flowus.cn/oss/d71af4a0-e3db-4903-981f-1d1ee776d079/image.png?time=1740540600&token=262dddc5aa6dcbce70bb61dd36eef1f34aaef5ed005660e604295855402a8a86&role=free" alt="image.png"></p>
<p><img data-src="https://tc-cdn.flowus.cn/oss/395afdaa-3ce6-4b1b-bdda-b49f99eaadd7/image.png?time=1740540600&token=54327c93e4a93a1d972ecce11b6687ca811f18345f9b9f38b52353090809e123&role=free" alt="image.png"></p>
<p><img data-src="https://tc-cdn.flowus.cn/oss/bde52ac3-b81e-40d0-bc58-b9c29d255aec/image.png?time=1740540600&token=0a47c23122dee556b58c57e08376df640e2da18015efe16d55669e2c070ee1b9&role=free" alt="image.png"></p>
<p><img data-src="https://tc-cdn.flowus.cn/oss/65da2a0e-37a5-43c5-9e4c-490de9327d4d/image.png?time=1740540600&token=5143c152f61f4141b917e7aca329d6bc944d5f541cd568aef9aaacb9c3d4d656&role=free" alt="image.png"></p>
<p><img data-src="https://tc-cdn.flowus.cn/oss/8298dac8-528a-48a4-9579-cca4de7907bb/image.png?time=1740540600&token=f70ab2fc19afa31702069e3b3d22909b0ff54f63392e43ee24649aa97c9397f4&role=free" alt="image.png"></p>
<p>这种方式的回收精度低，一个对象即使被删除了最后一个指向它的指针也依旧可以活过这一轮，在下一轮GC中被清理掉。</p>
<p>六、Go V1.8的混合写屏障(hybrid write barrier)机制</p>
<p>插入写屏障和删除写屏障的短板：</p>
<ul>
<li><strong>插入写屏障</strong>：结束时需要STW来重新扫描栈，标记栈上引用的白色对象的</li>
</ul>
<p>存活；</p>
<ul>
<li><strong>删除写屏障</strong>：回收精度低，GC开始时STW扫描堆栈来记录初始快照，这个</li>
</ul>
<p>过程会保护开始时刻的所有存活对象。</p>
<p>Go V1.8版本引入了混合写屏障机制（hybrid write barrier）,避免了对栈</p>
<p>re-scan的过程，极大的减少了STW的时间。结合了两者的优点。</p>
<hr>
<h4 id="混合写屏障规则"><a href="#混合写屏障规则" class="headerlink" title="混合写屏障规则"></a>混合写屏障规则</h4><p>01</p>
<p><code>具体操作</code>:</p>
<p>1、GC开始将栈上的对象全部扫描并标记为黑色(之后不再进行第二次重复扫描，无需STW)，</p>
<p>2、GC期间，任何在栈上创建的新对象，均为黑色。</p>
<p>3、被删除的对象标记为灰色。</p>
<p>4、被添加的对象标记为灰色。</p>
<p><code>满足</code>: 变形的弱三色不变式.</p>
<p>伪代码：</p>
<p><code>添加下游对象``(``当前下游对象**slot**``,</code> <code>新下游对象**ptr**``) &#123;         //1         标记灰色(``当前下游对象**slot**``) //只要当前下游对象被移走，就标记灰色                  //2         标记灰色(``新下游对象**ptr**``)                      //3</code>      <code>当前下游对象**slot**</code> <code>=</code> <code>新下游对象**ptr**``   &#125;</code></p>
<p>这里我们注意， 屏障技术是不在栈上应用的，因为要保证栈的运行效率。</p>
<h4 id="混合写屏障的具体场景分析"><a href="#混合写屏障的具体场景分析" class="headerlink" title="混合写屏障的具体场景分析"></a>混合写屏障的具体场景分析</h4><p>02</p>
<pre><code>    接下来，我们用几张图，来模拟整个一个详细的过程， 希望您能够更可观的看清晰整体流程。
</code></pre>
<p>注意混合写屏障是Gc的一种屏障机制，所以只是当程序执行GC的时候，才会触发这种机制。</p>
<h4 id="GC开始：扫描栈区，将可达对象全部标记为黑"><a href="#GC开始：扫描栈区，将可达对象全部标记为黑" class="headerlink" title="GC开始：扫描栈区，将可达对象全部标记为黑"></a>GC开始：扫描栈区，将可达对象全部标记为黑</h4><p><img data-src="https://tc-cdn.flowus.cn/oss/91fabae1-af41-457a-a3ad-f33c4eaf87ef/image.png?time=1740540600&token=b8aa100289aea76b37c0db3a4f508fe07452c8a902566f75b2b8ac2656953ae3&role=free" alt="image.png"></p>
<p><img data-src="https://tc-cdn.flowus.cn/oss/402575e1-72a1-40e4-b456-f6920c22f8d6/image.png?time=1740540600&token=c082f352f4b1401e517931f76b34a4ab4214a792e092b3521a680476ba8c6f73&role=free" alt="image.png"></p>
<h4 id="场景一：对象被一个堆对象删除引用，成为栈对象的下游"><a href="#场景一：对象被一个堆对象删除引用，成为栈对象的下游" class="headerlink" title="场景一：对象被一个堆对象删除引用，成为栈对象的下游"></a>场景一：对象被一个堆对象删除引用，成为栈对象的下游</h4><figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="code"><pre><span class="line">//前提：堆对象4-&gt;对象7 = 对象7；//对象7 被 对象4引用</span><br><span class="line">栈对象1-&gt;对象7 = 堆对象7；//将堆对象7 挂在 栈对象1 下游</span><br><span class="line">堆对象4-&gt;对象7 = null；//对象4 删除引用 对象7</span><br></pre></td></tr></table></figure>


<p><img data-src="https://tc-cdn.flowus.cn/oss/d619cd75-55cb-48ac-a11e-0a8492675a0f/image.png?time=1740540600&token=facf73a3577444eec2aa27aee52356b393046806cf3dd54308570f2bc4355d9d&role=free" alt="image.png"></p>
<p><img data-src="https://tc-cdn.flowus.cn/oss/8d2955ad-2f58-4052-8758-8677f3c63cd9/image.png?time=1740540600&token=3c33afef57dee5889b335ddf2b228e28d342d9cf0be630dcf95732e70fa9d447&role=free" alt="image.png"></p>
<h4 id="场景二：对象被一个栈对象删除引用，成为另一个栈对象的下游"><a href="#场景二：对象被一个栈对象删除引用，成为另一个栈对象的下游" class="headerlink" title="场景二：对象被一个栈对象删除引用，成为另一个栈对象的下游"></a>场景二：对象被一个栈对象删除引用，成为另一个栈对象的下游</h4><p>new 栈对象9；</p>
<p>对象9-&gt;对象3 &#x3D; 对象3；      &#x2F;&#x2F;将栈对象3 挂在 栈对象9 下游</p>
<p>对象2-&gt;对象3 &#x3D; null；      &#x2F;&#x2F;对象2 删除引用 对象3</p>
<p><img data-src="https://tc-cdn.flowus.cn/oss/1da952ba-65bb-4602-a1f5-877120192d8e/image.png?time=1740540600&token=491ef63302f9a3852063be9deea6e0812aa5cbb23076aae9981e3cc7140dbef7&role=free" alt="image.png"></p>
<p><img data-src="https://tc-cdn.flowus.cn/oss/0eab000f-df37-40c0-bb4c-8f5cc4e09ec8/image.png?time=1740540600&token=4bddfa00e100176f27ccee2316d7dc649a0d594bec7ca345e97efd914625e43b&role=free" alt="image.png"></p>
<p><img data-src="https://tc-cdn.flowus.cn/oss/46225ed4-617b-4394-b2b8-ca66ddd844a0/image.png?time=1740540600&token=56d65338da39f9bfe102f32be9fe812f9a8c73d35c83436ef05f39c4517688d7&role=free" alt="image.png"></p>
<h4 id="场景三：对象被一个堆对象删除引用，成为另一个堆对象的下游"><a href="#场景三：对象被一个堆对象删除引用，成为另一个堆对象的下游" class="headerlink" title="场景三：对象被一个堆对象删除引用，成为另一个堆对象的下游"></a>场景三：对象被一个堆对象删除引用，成为另一个堆对象的下游</h4><figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="code"><pre><span class="line">堆对象10-&gt;对象7 = 堆对象7；//将堆对象7 挂在 堆对象10 下游</span><br><span class="line">堆对象4-&gt;对象7 = null；//对象4 删除引用 对象7</span><br></pre></td></tr></table></figure>


<p><img data-src="https://tc-cdn.flowus.cn/oss/d580dee2-ecb8-4923-acc7-d8970fd0db12/image.png?time=1740540600&token=a96f2b2525c249b576ceaa1bdb2083ccac4a16ca7d4882079d1c226636fc4d88&role=free" alt="image.png"></p>
<p><img data-src="https://tc-cdn.flowus.cn/oss/6999b22a-d7af-483b-b5f1-36993f20d9b5/image.png?time=1740540600&token=1c277f4d0db255e39f975c5d24e61d738c2db9074baec92a699e3482d4f0b5bf&role=free" alt="image.png"></p>
<p><img data-src="https://tc-cdn.flowus.cn/oss/329cfe15-a808-47fc-9b5e-0a35c89c7834/image.png?time=1740540600&token=3de4dc3a57b0f1e7f3e3229160f6c3ba65f37f7e06c28eaffcf76bcf0ffb4674&role=free" alt="image.png"></p>
<h4 id="场景四：对象从一个栈对象删除引用，成为另一个堆对象的下游"><a href="#场景四：对象从一个栈对象删除引用，成为另一个堆对象的下游" class="headerlink" title="场景四：对象从一个栈对象删除引用，成为另一个堆对象的下游"></a>场景四：对象从一个栈对象删除引用，成为另一个堆对象的下游</h4><p>栈对象1-&gt;对象2 &#x3D; null；      &#x2F;&#x2F;对象1 删除引用 对象2</p>
<p>堆对象4-&gt;对象2 &#x3D; 栈对象2；    &#x2F;&#x2F;对象4 添加 下游 栈对象2</p>
<p>堆对象4-&gt;对象7 &#x3D; null;       &#x2F;&#x2F;对象4 删除引用 对象7null；&#x2F;&#x2F;对象4 删除引用 对象7</p>
<p><img data-src="https://tc-cdn.flowus.cn/oss/a73350f8-0daa-4ca5-9c47-f8470dc23e4f/image.png?time=1740540600&token=ffa73b2c6322209e0952f92e04f902eceee6f5dda60a899fcaec9d58f57764b3&role=free" alt="image.png"></p>
<p><img data-src="https://tc-cdn.flowus.cn/oss/3272830b-004c-42f9-93c5-41c8fc91780e/image.png?time=1740540600&token=a56328d90be3136bbc6314f62a70173dfff90487abdb4f75b36abb41738c0149&role=free" alt="image.png"></p>
<p><img data-src="https://tc-cdn.flowus.cn/oss/e978f905-c284-4b7d-bff2-12c6fdd198e1/image.png?time=1740540600&token=f07f4fa37d9f277c86ba98b4c79b4dd5fed13e5c9f52bed15989ab7efbddc164&role=free" alt="image.png"></p>
<pre><code>    Golang中的混合写屏障满足`弱三色不变式`，结合了删除写屏障和插入写屏障的优点，只需要在开始时并发扫描各个goroutine的栈，使其变黑并一直保持，这个过程不需要STW，而标记结束后，因为栈在扫描后始终是黑色的，也无需再进行re-scan操作了，减少了STW的时间。
</code></pre>
<hr>
<p>七、总结</p>
<pre><code>    以上便是Golang的GC全部的标记-清除逻辑及场景演示全过程。
</code></pre>
<p>GoV1.3- 普通标记清除法，整体过程需要启动STW，效率极低。</p>
<p>GoV1.5- 三色标记法， 堆空间启动写屏障，栈空间不启动，全部扫描之后，需要重新扫描一次栈(需要STW)，效率普通</p>
<p>GoV1.8-三色标记法，混合写屏障机制， 栈空间不启动，堆空间启动。整个过程几乎不需要STW，效率较高。</p>
<p>参考文献:</p>
<p><a href="https://www.cnblogs.com/wangyiyang/p/12191591.html">https://www.cnblogs.com/wangyiyang/p/12191591.html</a><br><a href="https://www.jianshu.com/p/eb6b3aff9ca5">https://www.jianshu.com/p/eb6b3aff9ca5</a><br><a href="https://zhuanlan.zhihu.com/p/74853110">https://zhuanlan.zhihu.com/p/74853110</a></p>
]]></content>
      <categories>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>底层原理</tag>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title>Go语言底层基础知识</title>
    <url>/2021/02/01/technology/golang/go-basic/</url>
    <content><![CDATA[<h2 id="new和make的区别"><a href="#new和make的区别" class="headerlink" title="new和make的区别"></a>new和make的区别</h2><ol>
<li>new和make都是全部用来分配内存的关键字，new(T)创建一个没有任何数据的类型为T的实例，并返回该实例的指针；make(T, args)只能创建 slice、map和channel，并且返回一个有初始值args（非零）的T类型的实例，非指针。</li>
<li>对于返回值，new用于类型的内存分配，并且内存置零，返回的是一个指向类型的指针；make是对他们的初始化，（非0值）返回的是一个类型引用对象 ，对于引用类型的变量，我们不光要声明它，还要为它分配内容空间 。</li>
<li>对于入参，new只有一个Type参数，Type可以是任何类型的数据；make传入Type参数（map、slice、chan）中的一种，还有一个size  。（map：根据slice大小分配资源，以足够存储size个元素，如果省略size，会默认分配一个小的起始size ；slice ：第一个是长度，第二个是cap（容量）；对于chan，size表示缓冲区容量；如果省略则表示channel为无缓冲的channel）<br>总结：</li>
</ol>
<ul>
<li><p>new() 是分配内存给一个零值的指针，返回的是这个类型的指针，还可以返回自己定义的结构体，置零之后的。</p>
</li>
<li><p>make（）是开辟一块内存，并且初始化，返回这个经过初始化的对象，只能初始化slice、map、chan，返回的是这个类型的引用，它可以设置初始化的长度，如果是slice，则可以添加一个参数，容量，容量的大小要小于slice的大小。</p>
</li>
</ul>
<h2 id="array和slice的区别"><a href="#array和slice的区别" class="headerlink" title="array和slice的区别"></a>array和slice的区别</h2><ol>
<li>array在定义的时候必须传入数组的长度，并且是一个常量，并且不可改变，数组的赋值都是值传递，所以一般情况会就比较耗费内存。</li>
<li>slice是通过指针引用底层数组，是对数组一个连续片段的引用，这个片段可以是全部的数组，也可以是其中的一个片段，slice自身是一个结构体，切片的长度可以改变。切片在进行append时，未超过切片的容量，进行浅拷贝（传递引用），超过容量，进行扩容的时候才会执行深拷贝（生成一个新的内存空间，不共享。）</li>
</ol>
<h2 id="通道是什么"><a href="#通道是什么" class="headerlink" title="通道是什么"></a>通道是什么</h2><p>通道是go中的一个通信方式，提供goroutine进行通信，可以为并发的两个实体之间提供通信通道，而不是共享内存的方式。<br>通道分为无缓冲通道和有缓冲通道:</p>
<ul>
<li>对于无缓冲通道，接收方从通道接收东西的时候，如果通道中没有消息，则接收方进入阻塞，直到通道中有消息。对于发送方，直到接收方收到消息之后，才能继续给通道发送消息。</li>
<li>对于有缓冲通道，指的是在通道中可以缓冲指定数量的数据，直到数据填满，发送方阻塞，直到接收方接收，采用了环形数组的方式进行存储。</li>
</ul>
<p>通道在Go中的代码定义:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> hchan <span class="keyword">struct</span> &#123;</span><br><span class="line">  qcount   <span class="type">uint</span>           <span class="comment">// 当前队列中剩余元素个数</span></span><br><span class="line">  dataqsiz <span class="type">uint</span>           <span class="comment">// 环形队列长度，即可以存放的元素个数</span></span><br><span class="line">  buf      unsafe.Pointer <span class="comment">// 环形队列指针</span></span><br><span class="line">  elemsize <span class="type">uint16</span>         <span class="comment">// 每个元素的大小</span></span><br><span class="line">  closed   <span class="type">uint32</span>            <span class="comment">// 标识关闭状态</span></span><br><span class="line">  elemtype *_type         <span class="comment">// 元素类型</span></span><br><span class="line">  sendx    <span class="type">uint</span>           <span class="comment">// 队列下标，指示元素写入时存放到队列中的位置</span></span><br><span class="line">  recvx    <span class="type">uint</span>           <span class="comment">// 队列下标，指示元素从队列的该位置读出</span></span><br><span class="line">  recvq    waitq          <span class="comment">// 等待读消息的goroutine队列</span></span><br><span class="line">  sendq    waitq          <span class="comment">// 等待写消息的goroutine队列</span></span><br><span class="line">  lock mutex              <span class="comment">// 互斥锁，chan不允许并发读写</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通道内部维护一个环形队列，队列的长度是在用户创建的时候指定的。</p>
<ul>
<li>sendx代表写入时的位置</li>
<li>recvx代表读数据时的位置</li>
<li>chan内部还维护了两个等待队列</li>
<li>一个等待读消息的groutine队列</li>
<li>一个等待写消息的groutine队列</li>
<li>一般情况下，recvq和sendq至少有一个为空；一个例外(同一个groutine使用select向channel一边写数据，一边读数据)</li>
</ul>
<p>注意：</p>
<ul>
<li> channel关闭之后任然可以读，如果channel中仍然有未读取的数据，则仍然可以读取到，没有数据会返回0。</li>
<li>关闭一个未初始化的channel会产生panic。</li>
<li>重复关闭同一个channel会产生painc。</li>
<li>从已经关闭的channel中读取消息不会产生painc，且能读出channel中还未被读取的消息，如果消息已经读出，则返回0值；(有缓冲无缓冲都是)。</li>
<li>关闭的channel中读取消息永远不会阻塞，并且会返回一个为false的ok-idiom。</li>
</ul>
<h2 id="map的底层实现"><a href="#map的底层实现" class="headerlink" title="map的底层实现"></a>map的底层实现</h2><p>golang的map是hasmap，使用数组+链表的形式 实现的，使用拉链法消除hash冲突。<br>map类型的变量默认初始值为nil，需要使用make()函数来分配内存。语法为：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">map</span>[keyType]ValueType</span><br><span class="line"><span class="built_in">make</span>(<span class="keyword">map</span>[KeyType]ValueType, [<span class="built_in">cap</span>])</span><br></pre></td></tr></table></figure>
<p>golang的map有两种重要的结构：hmap，bmap，主要就是hmap中包含bmap的一个指针。<br>存储时key不能重复，如果重复则覆盖value，通过key进行hash运算（可以简单的理解为把key转化为一个整数）然后对数组的长度取余,得到key存储在数组的哪个下标位置，咱以后将key和value组装成一个结构体，放入下标的位置。</p>
<h3 id="1-关于hash冲突"><a href="#1-关于hash冲突" class="headerlink" title="1. 关于hash冲突"></a>1. 关于hash冲突</h3><p>数组一个下标只能存储一个元素，也就是说一个数组下标只能存储一对key，value，hashkey（小明）&#x3D;4占用了下标0的位置，假设我们遇到了另一个key，它的hashkey(xiaowang)也是4，这就是hash冲突（不同的key经过hash之后得到的值一样）那么key&#x3D;xiaowang怎么存储？</p>
<ul>
<li><p>开放定址法：当我们存储一个key，value时，发现下标已经被占了，那么我们再这个数组中重新找一个没被占用的存储这个冲突的key，那么没有被占用的有很多，找哪个呢？常见的有线性探测法，线性补偿探测法、随机探测法。</p>
</li>
<li><p>线性探测：按照顺序来，从冲突的下标开始往后探测，到达数组末尾时，从数组开始探测，直到找到一个空位置存储这个key，当数组找不到的情况下会扩容（当数组快满的时候就会扩容了）；<br>如下图：首先存储key&#x3D;xiaoming在下标0处，当存储key&#x3D;xiaowang时，hash冲突了，按照线性探测，存储在下标1处，（红色的线是冲突或者下标已经被占用了） 再者key&#x3D;xiaozhao存储在下标4处，当存储key&#x3D;xiaoliu是，hash冲突了，按照线性探测，从头开始，存储在下标2处 （黄色的是冲突或者下标已经被占用了）</p>
<img data-src="/2021/02/01/technology/golang/go-basic/image_1.png" class="" title="图1">
</li>
<li><p>拉链法：拉链简单理解为链表，当key的hash冲突的时候，我们在冲突位置的元素上形成一个链表，通过指针相互连接，当查找时，发现key冲突，顺着链表一直往下找，直到链表的尾结点，找不到则返回空；<br>如下图描述：</p>
<img data-src="/2021/02/01/technology/golang/go-basic/image_2.png" class="" title="图2">
<p>开放定址和拉链的优缺点：</p>
<ul>
<li>拉链比线性探测处理简单</li>
<li>线性探测查找会比拉链更消耗时间</li>
<li>线性探测会比拉链更容易导致扩容，而拉链不会</li>
<li>拉链存储了指针，所以空间上会比线性探测占用多一点</li>
<li>拉链是动态申请存储空间的，所以更适合链长不确定的。</li>
</ul>
</li>
</ul>
<h3 id="2-HashMap怎么扩容"><a href="#2-HashMap怎么扩容" class="headerlink" title="2. HashMap怎么扩容"></a>2. HashMap怎么扩容</h3><p>首先需要知道哈希表的存储过程，当有新的数据进行存储的时候，需要根据key计算出它的哈希值h，假设哈希表的 容量是n，那么键值对就会放在h%n个位置中，如果该位置已经有了键值对，会分局开放寻址法或者拉链法解决冲突；<br>哈希表的扩容会创建原来的两倍容量，因此即使key的哈希值不变，求余结果也会改变，因此所有的键值对存放的位置都会发生改变，此时需要重新哈希。扩容的时候需要分配一个新的数组，新数组是老数组的2倍长，然后遍历旧的哈希，重新分配到新的结果中。</p>
<h2 id="Go中的interface关键字"><a href="#Go中的interface关键字" class="headerlink" title="Go中的interface关键字"></a>Go中的interface关键字</h2><ul>
<li>interface是方法声明的集合</li>
<li>任何类型的对象实现在interface接口中声明的全部方法，则表明这个类型实现了接口</li>
<li>interface可以作为一种数据类型，实现了该接口的任何对象，都可以给对应的接口类型变量赋值</li>
<li>interface可以被任意对象实现，一个类型&#x2F;对象也可以实现多个(interface)接口</li>
<li>继承和多态的特点，在golang的语法中对多态的特点体现从语法上不是很明显</li>
<li>父类是子类的私有内部类(组合)</li>
<li>发生多态的几个要素：（满足这三个条件，就可以产生多态的效果，父类可以调用子类的具体方法）</li>
<li>有interface接口，并且有接口定义的方法（可以看做一个类型，父类）</li>
<li>有子类去重写interface的接口</li>
<li>有父类指针指向子类的具体对象</li>
</ul>
<h2 id="GMP并发模型："><a href="#GMP并发模型：" class="headerlink" title="GMP并发模型："></a>GMP并发模型：</h2><ul>
<li>G代表goroutine,占用内存更小（几kb），能在有限的内存空间支持更多的并发,调度灵活度更高（runtime调度）</li>
<li>M代表操作系统线程，负责执行 Goroutine</li>
<li>P代表逻辑处理器，负责调度 Goroutine</li>
<li>包含了运行goroutine的资源processor处理</li>
<li>可以运行的G队列<br>在Go中线程是运行goroutine的实体，调度器（runtime）的功能是把可运行的    goroutine分配到工作线程上。<br>Goroutine调度器和OS调度器是通过M结合起来的，每个M都代表了1个内核线程，OS调度器负责把内核线程分配到CPU执行。<img data-src="/2021/02/01/technology/golang/go-basic/image_3.png" class="" title="图3"></li>
</ul>
<h3 id="1-GMP-模型的优势"><a href="#1-GMP-模型的优势" class="headerlink" title="1. GMP 模型的优势"></a>1. GMP 模型的优势</h3><ul>
<li><strong>高效利用 CPU</strong>：通过多 P 和多 M 的绑定，充分利用多核 CPU 的计算能力。</li>
<li><strong>低延迟</strong>：Goroutine 的调度由 Go 运行时负责，避免了操作系统线程切换的开销。</li>
<li><strong>高并发</strong>：Goroutine 的轻量级特性使得 Go 程序可以轻松创建成千上万的并发任务。<br>以下是一个简单的 Go 程序，展示了 Goroutine 的创建和调度：<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">worker</span><span class="params">(id <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;Worker %d: %d\n&quot;</span>, id, i)</span><br><span class="line">		time.Sleep(time.Second)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">		<span class="keyword">go</span> worker(i)</span><br><span class="line">	&#125;</span><br><span class="line">	time.Sleep(<span class="number">5</span> * time.Second) <span class="comment">// 等待所有 Goroutine 执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="GO的GC垃圾回收机制"><a href="#GO的GC垃圾回收机制" class="headerlink" title="GO的GC垃圾回收机制"></a>GO的GC垃圾回收机制</h2><p>三色标记清楚法：</p>
<ul>
<li>初始化所有的对象为白色；</li>
<li>从root根出发扫描所有的根对象，将他们引用的对象标记为灰色；</li>
<li>这里的根对象是程序运行到当前时刻的栈和全局数据区域；</li>
<li>分析灰色对象是否引用了其他的对象，如果没有引用其他的对象，则将该灰色标记为黑色，如果有引用，则将它变为黑色的同时将引用对象标记为灰色；</li>
<li>重复步骤三，直到灰色对象队列为空，此时白色的对象是垃圾，进行回收。</li>
</ul>
<h2 id="Context关键字"><a href="#Context关键字" class="headerlink" title="Context关键字"></a>Context关键字</h2><p>Go1.7加入了一个新的标准库context，它定义了Context类型，专门用来简化 对于处理单个请求的多个 goroutine 之间与请求域的数据、取消信号、截止时间等相关操作，这些操作可能涉及多个 API 调用。<br>对服务器传入的请求应该创建上下文，而对服务器的传出调用应该接受上下文。它们之间的函数调用链必须传递上下文，或者可以使用WithCancel(获得数据通知关闭)、(获得数据定时关闭)WithDeadline、(超时关闭)WithTimeout或(传递KV)WithValue创建的派生上下文。当一个上下文被取消时，它派生的所有上下文也被取消。<br>context.Background()返回的是全局的上下文根（我在文章中多次提到），context.TODO()返回的是空的上下文（表明应用的不确定性）</p>
<h2 id="GO内存分配与逃逸分析"><a href="#GO内存分配与逃逸分析" class="headerlink" title="GO内存分配与逃逸分析"></a>GO内存分配与逃逸分析</h2><ul>
<li>逃逸分析的好处是为了减少gc的压力,不逃逸的对象分配到栈上,当函数返回释放即可,不需要gc标记删除</li>
<li>逃逸分析完成之后可以确定哪些变量可以分配在栈上,栈的分配比堆快,性能好(逃逸变量分配到堆,不逃逸变量分配到栈)</li>
<li>同步消除,如果你定义的对象的方法上有同步锁,在运行时,却只有一个线程在访问,此时逃逸分析后的机器码会去掉同步锁运行<br>总结:</li>
<li>栈上分配内存比在堆中分配内存有更高的效率</li>
<li>栈上分配的内存不需要GC处理</li>
<li>堆上分配的内存使用完毕会交给GC处理</li>
<li>逃逸分析的目的是决定分配地址是栈还是堆</li>
<li>逃逸分析在编译阶段完成</li>
</ul>
<h3 id="1-函数传递指针真的比传值效率高吗"><a href="#1-函数传递指针真的比传值效率高吗" class="headerlink" title="1. 函数传递指针真的比传值效率高吗?"></a>1. 函数传递指针真的比传值效率高吗?</h3><ul>
<li>传递指针可以减少底层值拷贝,可以提高效率,但是如果拷贝数据量小,由于指针传递会产生逃逸;</li>
<li>可能会使用堆,也可能会增加GC的负担,所以传递指针不一定是高效的;<br><strong>栈</strong> :函数内存申请临时变量,并不会作为返回值返回,它就会被编译器申请到栈中<br>在函数中申请一个新对象,如果在栈中,函数执行结束会自动将内存回收;<br><strong>申请到栈内存好处</strong>:  函数返回直接释放,不会引起垃圾回收,对性能没有影响.<br><strong>堆</strong>:    函数申请内存之后,作为返回值返回了,编译器会默认变量之后还会被使用,<br>当函数返回之后并不会将内存归还,那么他就会被申请到堆中.<br>如果分配到堆中,则函数执行结束之后交给GC处理;<br><strong>申请到堆的内存</strong>  :  会引起垃圾回收,如果这个过程(特指垃圾回收不断被触发)过高频次就会导致gc压力过大,性能变低。<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">F</span><span class="params">()</span></span> []<span class="type">int</span>&#123;</span><br><span class="line">    a := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>, <span class="number">20</span>)</span><br><span class="line">    <span class="keyword">return</span> a</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">F</span><span class="params">()</span></span> &#123;</span><br><span class="line">    a := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>, <span class="number">20</span>)     <span class="comment">// 栈 空间小</span></span><br><span class="line">    b := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>, <span class="number">20000</span>) <span class="comment">// 堆 空间过大</span></span><br><span class="line"></span><br><span class="line">    l := <span class="number">20</span></span><br><span class="line">    c := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>, l) <span class="comment">// 堆 动态分配不定空间,也会在堆</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="2-什么是逃逸分析，有哪些场景"><a href="#2-什么是逃逸分析，有哪些场景" class="headerlink" title="2. 什么是逃逸分析，有哪些场景"></a>2. 什么是逃逸分析，有哪些场景</h3><p>逃逸分析指的是由编译器决定内存分配的位置,不需要开发者指定。</p>
<h3 id="1-逃逸场景-什么时候才会被分配到堆中"><a href="#1-逃逸场景-什么时候才会被分配到堆中" class="headerlink" title="1.逃逸场景(什么时候才会被分配到堆中)"></a>1.逃逸场景(什么时候才会被分配到堆中)</h3><ul>
<li>指针逃逸 : go可以返回局部变量指针,典型的变量逃逸案例</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="type">string</span></span><br><span class="line">    Age <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">StudentRegister</span><span class="params">(name <span class="type">string</span>,age <span class="type">int</span>)</span></span>*Student  &#123;</span><br><span class="line">    s :=<span class="built_in">new</span>(Student) <span class="comment">//局部变量s逃逸到堆</span></span><br><span class="line">    s.Name = name</span><br><span class="line">    s.Age = age</span><br><span class="line">    <span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    StudentRegister(<span class="string">&quot;Jin&quot;</span>,<span class="number">19</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>虽然在函数StudentRegister<strong>中内存s 为局部变量</strong>,它的值通过函数返回值返回,s本身为一个指针</p>
<p>它指向发内存地址不会是对,而是栈,这是典型的逃逸案例</p>
<p>终端执行: go build -gcflags &#x3D; - m</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">C:\Users\Administrator\<span class="keyword">go</span>\src\内存逃逸分析&gt;<span class="keyword">go</span> build -gcflags=-m</span><br><span class="line"># 内存逃逸分析</span><br><span class="line">.\<span class="number">1.</span>指针逃逸.<span class="keyword">go</span>:<span class="number">8</span>:<span class="number">6</span>: can inline StudentRegister</span><br><span class="line">.\<span class="number">1.</span>指针逃逸.<span class="keyword">go</span>:<span class="number">15</span>:<span class="number">6</span>: can inline main</span><br><span class="line">.\<span class="number">1.</span>指针逃逸.<span class="keyword">go</span>:<span class="number">16</span>:<span class="number">17</span>: inlining call to StudentRegister</span><br><span class="line">.\<span class="number">1.</span>指针逃逸.<span class="keyword">go</span>:<span class="number">8</span>:<span class="number">22</span>: leaking param: name</span><br><span class="line">.\<span class="number">1.</span>指针逃逸.<span class="keyword">go</span>:<span class="number">9</span>:<span class="number">9</span>: <span class="built_in">new</span>(Student) escapes to heap  <span class="comment">//显示指针逃逸</span></span><br><span class="line">.\<span class="number">1.</span>指针逃逸.<span class="keyword">go</span>:<span class="number">16</span>:<span class="number">17</span>: <span class="built_in">new</span>(Student) does not escape</span><br></pre></td></tr></table></figure>

<ul>
<li>栈空间不足逃逸(空间开辟过大)</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Slice</span><span class="params">()</span></span> &#123;</span><br><span class="line">    s := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">10000</span>, <span class="number">10000</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> index, _ := <span class="keyword">range</span> s &#123;</span><br><span class="line">        s[index] = index</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    Slice()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//当切片长度扩大到100000时会逃逸</span></span><br><span class="line"><span class="comment">//实际上当栈空间不足以存放当前对象或者无法判断当前切片长度时会将对象分配到堆中</span></span><br><span class="line"></span><br><span class="line">C:\Users\Administrator\<span class="keyword">go</span>\src\内存逃逸分析&gt;<span class="keyword">go</span> build -gcflags=-m</span><br><span class="line"># 内存逃逸分析</span><br><span class="line">.\<span class="number">1.</span>指针逃逸.<span class="keyword">go</span>:<span class="number">11</span>:<span class="number">6</span>: can inline main</span><br><span class="line">.\<span class="number">1.</span>指针逃逸.<span class="keyword">go</span>:<span class="number">4</span>:<span class="number">11</span>: <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">10000</span>, <span class="number">10000</span>) escapes to heap</span><br></pre></td></tr></table></figure>

<ul>
<li>动态类型逃逸(不确定长度大小)</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    s := <span class="string">&quot;Escape&quot;</span></span><br><span class="line">    fmt.Println(s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">C:\Users\Administrator\<span class="keyword">go</span>\src\内存逃逸分析&gt;<span class="keyword">go</span> build -gcflags=-m</span><br><span class="line"># 内存逃逸分析</span><br><span class="line">.\<span class="number">1.</span>指针逃逸.<span class="keyword">go</span>:<span class="number">7</span>:<span class="number">13</span>: inlining call to fmt.Println</span><br><span class="line">.\<span class="number">1.</span>指针逃逸.<span class="keyword">go</span>:<span class="number">7</span>:<span class="number">13</span>: s escapes to heap</span><br><span class="line">.\<span class="number">1.</span>指针逃逸.<span class="keyword">go</span>:<span class="number">7</span>:<span class="number">13</span>: []<span class="keyword">interface</span> &#123;&#125; literal does not escape</span><br><span class="line">&lt;autogenerated&gt;:<span class="number">1</span>: .this does not escape</span><br><span class="line">&lt;autogenerated&gt;:<span class="number">1</span>: .this does not escape</span><br></pre></td></tr></table></figure>

<ul>
<li>闭包引用对象逃逸</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Fibonacci</span><span class="params">()</span></span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    a, b := <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">int</span> &#123;</span><br><span class="line">        a, b = b, a+b</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    f := Fibonacci()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;Fibonacci: %d\n&quot;</span>, f())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">C:\Users\Administrator\<span class="keyword">go</span>\src\内存逃逸分析&gt;<span class="keyword">go</span> build -gcflags=-m</span><br><span class="line"># 内存逃逸分析</span><br><span class="line">.\<span class="number">1.</span>指针逃逸.<span class="keyword">go</span>:<span class="number">7</span>:<span class="number">9</span>: can inline Fibonacci.func1</span><br><span class="line">.\<span class="number">1.</span>指针逃逸.<span class="keyword">go</span>:<span class="number">17</span>:<span class="number">13</span>: inlining call to fmt.Printf</span><br><span class="line">.\<span class="number">1.</span>指针逃逸.<span class="keyword">go</span>:<span class="number">6</span>:<span class="number">2</span>: moved to heap: a</span><br><span class="line">.\<span class="number">1.</span>指针逃逸.<span class="keyword">go</span>:<span class="number">6</span>:<span class="number">5</span>: moved to heap: b</span><br><span class="line">.\<span class="number">1.</span>指针逃逸.<span class="keyword">go</span>:<span class="number">7</span>:<span class="number">9</span>: <span class="function"><span class="keyword">func</span> <span class="title">literal</span> <span class="title">escapes</span> <span class="title">to</span> <span class="title">heap</span></span></span><br><span class="line">.\<span class="number">1.</span>指针逃逸.<span class="keyword">go</span>:<span class="number">17</span>:<span class="number">34</span>: f() escapes to heap</span><br><span class="line">.\<span class="number">1.</span>指针逃逸.<span class="keyword">go</span>:<span class="number">17</span>:<span class="number">13</span>: []<span class="keyword">interface</span> &#123;&#125; literal does not escape</span><br><span class="line">&lt;autogenerated&gt;:<span class="number">1</span>: .this does not escape</span><br><span class="line">&lt;autogenerated&gt;:<span class="number">1</span>: .this does not escape</span><br></pre></td></tr></table></figure>

<h2 id="runtime机制是什么"><a href="#runtime机制是什么" class="headerlink" title="runtime机制是什么"></a>runtime机制是什么</h2><p>go 语言的可执行文件已经包含了 golang 的 runtime，它为用户的 go 程序提供协程调度、内存分配、垃圾回收等功能.此外还会与系统内核进行交互，从而真正的利用好 CPU 等资源。</p>
<ul>
<li><strong>Gosched</strong>：让当前线程让出 <code>cpu</code> 以让其它线程运行,它不会挂起当前线程，因此当前线程未来会继续执行</li>
<li><strong>NumCPU</strong>：返回当前系统的 <code>CPU</code> 核数量</li>
<li><strong>GOMAXPROCS</strong>：设置最大的可同时使用的 <code>CPU</code> 核数</li>
<li><strong>Goexit</strong>：退出当前 <code>goroutine</code>(但是<code>defer</code>语句会照常执行)</li>
<li><strong>NumGoroutine</strong>：返回正在执行和排队的任务总数</li>
<li><strong>GOOS</strong>：目标操作系统</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">fmt.Println(<span class="string">&quot;cpus:&quot;</span>, runtime.NumCPU())</span><br><span class="line">fmt.Println(<span class="string">&quot;goroot:&quot;</span>, runtime.GOROOT())</span><br><span class="line">fmt.Println(<span class="string">&quot;archive:&quot;</span>, runtime.GOOS)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>底层原理</tag>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title>Go内存逃逸分析</title>
    <url>/2021/02/03/technology/golang/memory_escape/</url>
    <content><![CDATA[<h2 id="1-关于-堆和栈"><a href="#1-关于-堆和栈" class="headerlink" title="1. 关于 堆和栈"></a>1. 关于 堆和栈</h2><p>栈可以简单得理解成一次函数调用内部申请到的内存，它们会随着函数的返回把内存还给系统。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">F</span><span class="params">()</span></span> &#123;</span><br><span class="line">    temp := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>, <span class="number">20</span>)</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>类似于上面代码里面的temp变量，只是内函数内部申请的临时变量，并不会作为返回值返回，它就是被编译器申请到栈里面。 </p>
<p>申请到<strong>栈内存</strong>好处：函数返回直接释放，不会引起垃圾回收，对性能没有影响。</p>
<p>再来看看堆得情况之一如下代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">F</span><span class="params">()</span></span> []<span class="type">int</span>&#123;</span><br><span class="line">    a := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>, <span class="number">20</span>)</span><br><span class="line">    <span class="keyword">return</span> a</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而上面这段代码，申请的代码一模一样，但是申请后作为返回值返回了，编译器会认为变量之后还会被使用，当函数返回之后并不会将其内存归还，那么它就会被申请到 堆 上面了。</p>
<p><strong>申请到堆上面的内存才会引起垃圾回收，如果这个过程（特指垃圾回收不断被触发）过于高频就会导致 gc 压力过大，程序性能出问题。</strong></p>
<p>我们再看看如下几个例子：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">F</span><span class="params">()</span></span> &#123;</span><br><span class="line">    a := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>, <span class="number">20</span>)     <span class="comment">// 栈 空间小</span></span><br><span class="line">    b := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>, <span class="number">20000</span>) <span class="comment">// 堆 空间过大</span></span><br><span class="line"></span><br><span class="line">    l := <span class="number">20</span></span><br><span class="line">    c := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>, l) <span class="comment">// 堆 动态分配不定空间</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>像是 b 这种 即使是临时变量，申请过大也会在堆上面申请。对于 c 编译器对于这种不定长度的申请方式，也会在堆上面申请，即使申请的长度很短。</p>
<h2 id="2-逃逸分析（Escape-analysis）"><a href="#2-逃逸分析（Escape-analysis）" class="headerlink" title="2. 逃逸分析（Escape analysis）"></a>2. 逃逸分析（Escape analysis）</h2><p>逃逸分析指的是由编译器决定内存分配的位置,不需要由程序员指定.</p>
<p>在函数中申请一个新的对象</p>
<ul>
<li><p><strong>如果申请到栈中,则函数执行结束可以自动将内存回收.</strong></p>
</li>
<li><p><strong>如果分配到堆,则函数执行结束就可以交给GC处理.</strong></p>
</li>
</ul>
<h2 id="3-逃逸场景（什么情况才分配到堆中）"><a href="#3-逃逸场景（什么情况才分配到堆中）" class="headerlink" title="3. 逃逸场景（什么情况才分配到堆中）"></a>3. 逃逸场景（什么情况才分配到堆中）</h2><h3 id="3-1-指针逃逸"><a href="#3-1-指针逃逸" class="headerlink" title="3.1 指针逃逸"></a>3.1 指针逃逸</h3><p>Go可以返回局部变量指针，这其实是一个典型的变量逃逸案例，示例代码如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="type">string</span></span><br><span class="line">    Age  <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">StudentRegister</span><span class="params">(name <span class="type">string</span>, age <span class="type">int</span>)</span></span> *Student &#123;</span><br><span class="line">    s := <span class="built_in">new</span>(Student) <span class="comment">//局部变量s逃逸到堆</span></span><br><span class="line"></span><br><span class="line">    s.Name = name</span><br><span class="line">    s.Age = age</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    StudentRegister(<span class="string">&quot;Jim&quot;</span>, <span class="number">18</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>虽然 在函数 StudentRegister() 内部 s 为局部变量，其值通过函数返回值返回，s 本身为一指针，其指向的内存地址不会是栈而是堆，这就是典型的逃逸案例。</p>
<p>终端运行命令查看逃逸分析日志：</p>
<figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="code"><pre><span class="line">go build -gcflags=-m</span><br></pre></td></tr></table></figure>


<img data-src="/2021/02/03/technology/golang/memory_escape/img_1.png" class="" title="image.png">

<p>可见在StudentRegister()函数中，也即代码第9行显示”escapes to heap”，代表该行内存分配发生了逃逸现象。</p>
<h3 id="3-2-栈空间不足逃逸（空间开辟过大）"><a href="#3-2-栈空间不足逃逸（空间开辟过大）" class="headerlink" title="3.2 栈空间不足逃逸（空间开辟过大）"></a>3.2 栈空间不足逃逸（空间开辟过大）</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Slice</span><span class="params">()</span></span> &#123;</span><br><span class="line">    s := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">1000</span>, <span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> index, _ := <span class="keyword">range</span> s &#123;</span><br><span class="line">        s[index] = index</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    Slice()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>上面代码Slice()函数中分配了一个1000个长度的切片，是否逃逸取决于栈空间是否足够大。 直接查看编译提示，如下：</p>
<img data-src="/2021/02/03/technology/golang/memory_escape/img_2.png" class="" title="image.png">

<p>所以只是1000的长度还不足以发生逃逸现象。然后就x10倍吧</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Slice</span><span class="params">()</span></span> &#123;</span><br><span class="line">    s := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">10000</span>, <span class="number">10000</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> index, _ := <span class="keyword">range</span> s &#123;</span><br><span class="line">        s[index] = index</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    Slice()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>分析如下：当切片长度扩大到10000时就会逃逸。实际上当栈空间不足以存放当前对象时或无法判断当前切片长度时会将对象分配到堆中。</p>
<h3 id="3-3-动态类型逃逸（不确定长度大小）"><a href="#3-3-动态类型逃逸（不确定长度大小）" class="headerlink" title="3.3 动态类型逃逸（不确定长度大小）"></a>3.3 动态类型逃逸（不确定长度大小）</h3><p>很多函数参数为interface类型，比如fmt.Println(a …interface{})，编译期间很难确定其参数的具体类型，也能产生逃逸。</p>
<p>如下代码所示：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    s := <span class="string">&quot;Escape&quot;</span></span><br><span class="line">    fmt.Println(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>逃逸分下如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">D:\SourceCode\GoExpert\src&gt;go build -gcflags=-m</span><br><span class="line"># _/D_/SourceCode/GoExpert/src</span><br><span class="line">.\main.go:7: s escapes to heap</span><br><span class="line">.\main.go:7: main ... argument does not escape</span><br></pre></td></tr></table></figure>


<p>又或者像前面提到的例子：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">F</span><span class="params">()</span></span> &#123;</span><br><span class="line">    a := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>, <span class="number">20</span>)     <span class="comment">// 栈 空间小</span></span><br><span class="line">    b := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>, <span class="number">20000</span>) <span class="comment">// 堆 空间过大 逃逸</span></span><br><span class="line"></span><br><span class="line">    l := <span class="number">20</span></span><br><span class="line">    c := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>, l) <span class="comment">// 堆 动态分配不定空间 逃逸</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="3-4-闭包引用对象逃逸"><a href="#3-4-闭包引用对象逃逸" class="headerlink" title="3.4 闭包引用对象逃逸"></a>3.4 闭包引用对象逃逸</h3><p>Fibonacci数列的函数：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Fibonacci</span><span class="params">()</span></span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    a, b := <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">int</span> &#123;</span><br><span class="line">        a, b = b, a+b</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    f := Fibonacci()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;Fibonacci: %d\n&quot;</span>, f())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>输出如下：</p>
<figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="code"><pre><span class="line"> ~/go/src/gitHub/test/pool  go run main.go</span><br><span class="line">Fibonacci: 1</span><br><span class="line">Fibonacci: 1</span><br><span class="line">Fibonacci: 2</span><br><span class="line">Fibonacci: 3</span><br><span class="line">Fibonacci: 5</span><br><span class="line">Fibonacci: 8</span><br><span class="line">Fibonacci: 13</span><br><span class="line">Fibonacci: 21</span><br><span class="line">Fibonacci: 34</span><br><span class="line">Fibonacci: 55</span><br></pre></td></tr></table></figure>


<p>逃逸如下：</p>
<figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="code"><pre><span class="line"> ~/go/src/gitHub/test/pool  go build -gcflags=-m</span><br><span class="line"># gitHub/test/pool</span><br><span class="line">./main.go:7:9: can inline Fibonacci.func1</span><br><span class="line">./main.go:7:9: func literal escapes to heap</span><br><span class="line">./main.go:7:9: func literal escapes to heap</span><br><span class="line">./main.go:8:10: &amp;b escapes to heap</span><br><span class="line">./main.go:6:5: moved to heap: b</span><br><span class="line">./main.go:8:13: &amp;a escapes to heap</span><br><span class="line">./main.go:6:2: moved to heap: a</span><br><span class="line">./main.go:17:34: f() escapes to heap</span><br><span class="line">./main.go:17:13: main ... argument does not escape</span><br></pre></td></tr></table></figure>


<p>Fibonacci()函数中原本属于局部变量的a和b由于闭包的引用，不得不将二者放到堆上，以致产生逃逸。</p>
<h3 id="逃逸分析的作用是什么呢？"><a href="#逃逸分析的作用是什么呢？" class="headerlink" title="逃逸分析的作用是什么呢？"></a>逃逸分析的作用是什么呢？</h3><ol>
<li><p>逃逸分析的好处是为了减少gc的压力，不逃逸的对象分配在栈上，当函数返回时就回收了资源，不需要gc标记清除。</p>
</li>
<li><p>逃逸分析完后可以确定哪些变量可以分配在栈上，栈的分配比堆快，性能好(逃逸的局部变量会在堆上分配 ,而没有发生逃逸的则有编译器在栈上分配)。</p>
</li>
<li><p>同步消除，如果你定义的对象的方法上有同步锁，但在运行时，却只有一个线程在访问，此时逃逸分析后的机器码，会去掉同步锁运行。</p>
</li>
</ol>
<h3 id="逃逸总结："><a href="#逃逸总结：" class="headerlink" title="逃逸总结："></a>逃逸总结：</h3><ul>
<li><p>栈上分配内存比在堆中分配内存有更高的效率</p>
</li>
<li><p>栈上分配的内存不需要GC处理</p>
</li>
<li><p>堆上分配的内存使用完毕会交给GC处理</p>
</li>
<li><p>逃逸分析目的是决定内分配地址是栈还是堆</p>
</li>
<li><p>逃逸分析在编译阶段完成</p>
</li>
</ul>
<p>提问：函数传递指针真的比传值效率高吗？</p>
<blockquote>
<p>我们知道传递指针可以减少底层值的拷贝，可以提高效率，但是如果拷贝的数据量小，由于指针传递会产生逃逸，可能会使用堆，也可能会增加GC的负担，所以传递指针不一定是高效的。</p>
</blockquote>
<p>在官网 (golang.org) FAQ 上有一个关于变量分配的问题如下：</p>
<blockquote>
<p>From a correctness standpoint, you don’t need to know. Each variable in Go exists as long as there are references to it. The storage location chosen by the implementation is irrelevant to the semantics of the language.</p>
</blockquote>
<blockquote>
<p>The storage location does have an effect on writing efficient programs. When possible, the Go compilers will allocate variables that are local to a function in that function’s stack frame.</p>
</blockquote>
<blockquote>
<p>However, if the compiler cannot prove that the variable is not referenced after the function returns, then the compiler must allocate the variable on the garbage-collected heap to avoid dangling pointer errors. Also, if a local variable is very large, it might make more sense to store it on the heap rather than the stack.</p>
</blockquote>
<blockquote>
<p>In the current compilers, if a variable has its address taken, that variable is a candidate for allocation on the heap. However, a basic escape analysis recognizes some cases when such variables will not live past the return from the function and can reside on the stack.</p>
</blockquote>
<p>翻译如下：</p>
<p>如何得知变量是分配在栈（stack）上还是堆（heap）上？</p>
<p>准确地说，你并不需要知道。Golang 中的变量只要被引用就一直会存活，存储在堆上还是栈上由内部实现决定而和具体的语法没有关系。</p>
<p>知道变量的存储位置确实和效率编程有关系。如果可能，Golang 编译器会将函数的局部变量分配到函数栈帧（stack frame）上。 然而，如果编译器不能确保变量在函数 return之后不再被引用，编译器就会将变量分配到堆上。而且，如果一个局部变量非常大，那么它也应该被分配到堆上而不是栈上。</p>
<p>当前情况下，如果一个变量被取地址，那么它就有可能被分配到堆上。然而，还要对这些变量做逃逸分析，如果函数return之后，变量不再被引用，则将其分配到栈上。</p>
]]></content>
      <categories>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>底层原理</tag>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title>Go高频面试题</title>
    <url>/2021/02/02/technology/golang/interview_issue/</url>
    <content><![CDATA[<h2 id="1-关于select"><a href="#1-关于select" class="headerlink" title="1.关于select"></a>1.关于select</h2><ul>
<li><p>select是Go语言中的一个控制语句，类似于switch，但是select主要用于通道操作（每一个case必须是一个通信操作，要么接收，要么发送）。 </p>
</li>
<li><p>select会随机选择一个可以运行的case；如果没有case可运行，那么将会阻塞，直到有一个case可以运行。</p>
</li>
</ul>
<h2 id="2-变量会怎么分配："><a href="#2-变量会怎么分配：" class="headerlink" title="2.变量会怎么分配："></a>2.变量会怎么分配：</h2><p>变量分配在栈还是堆是由go编译器自己控制的；编译时，会做逃逸分析，当变量作用域没有跑出函数的范围，就放在栈上；反之则必须放在堆上。<a href="/2021/02/03/technology/golang/memory_escape/">Go内存逃逸分析</a></p>
<h2 id="3-GC垃圾回收"><a href="#3-GC垃圾回收" class="headerlink" title="3.GC垃圾回收"></a>3.GC垃圾回收</h2><ul>
<li><p>v1.3：标记清除：整体过程需要启动STW，效率极低。</p>
</li>
<li><p>v1.5：三色标记法：堆空间启动写屏障，栈空间不启动，全部扫描之后，需要重新扫描一次栈(需要STW)，效率普通</p>
</li>
<li><p>v1.8：混合写屏障机制： 栈空间不启动，堆空间启动。整个过程几乎不需要STW，效率较高 <a href="/2021/02/02/technology/golang/gc_recycle/">Go垃圾回收</a></p>
</li>
</ul>
<h2 id="4-协程调度GPM"><a href="#4-协程调度GPM" class="headerlink" title="4.协程调度GPM"></a>4.协程调度GPM</h2><p>G：就是个goroutine（调度系统最基本的单位），里面除了存放本goroutine信息（执行stack信息；状态信息；所在的任务函数信息等）与所在P的绑定等信息。</p>
<p>P：就是process，管理着一组goroutine队列，存储当前goroutine运行的上下文环境。</p>
<p>M：machine，代表着真正的执行计算资源。</p>
<p>P管理着一组G在M上执行。<a href="https://flowus.cn/00f325cf-3352-461e-a91f-419ae8c3a4ef">GPM轻量理解</a></p>
<ul>
<li><p>每一个运行的M都必须绑定一个P，线程M创建后会检查并执行G对象</p>
</li>
<li><p>每一个P都保存着一个G队列</p>
</li>
<li><p>除了P保存的G队列外，还有一个全局G队列</p>
</li>
<li><p>M从队列中取出G并执行</p>
</li>
<li><p>P的个数就是 GOMAXPROCS(256)，一般不做修改</p>
</li>
<li><p>M的个数和P的个数不一定一样多</p>
</li>
<li><p>P是一个全局数组（255）来保存，并且维护者一个全局的P空闲链表</p>
</li>
</ul>
<h2 id="5-runtime机制"><a href="#5-runtime机制" class="headerlink" title="5.runtime机制"></a>5.runtime机制</h2><p><a href="https://blog.csdn.net/futurewu/article/details/104692651?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522162220408116780262566000%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=162220408116780262566000&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_v2~rank_v29-2-104692651.first_rank_v2_pc_rank_v29&utm_term=golang+%E7%9A%84+runtime+%E6%9C%BA%E5%88%B6&spm=1018.2226.3001.4187">runtime机制</a></p>
<p>runtime负责：管理调度，垃圾回收以及运行环境等。。Go语言的goroutine，channel这些高级功能都需要runtime的支持。</p>
<p>如何运行：用户编译代码后，runtime和编译后的代码会被静态链接起来，形成一个可执行文件。runtime通过接口函数调用来管理goroutine，channel这些高级功能；而且从用户代码调用操作系统的API调用会被runtime拦截处理。</p>
<p>组成：一个重要组成部分是goroutine scheduler ，它负责追踪调度goroutine运行，实际上是从应用程序的process所属的thread pool（线程池）中分配一个thread来执行这个goroutine。因此，每个goroutine只有分配到一个OS thread才能运行。</p>
<h2 id="6-make和new的区别"><a href="#6-make和new的区别" class="headerlink" title="6.make和new的区别"></a>6.make和new的区别</h2><p><a href="https://www.cnblogs.com/ghj1976/archive/2013/02/12/2910384.html">区别</a></p>
<p>make：返回初始化后的值。make是引用类型初始化的方法；常用于slice,map,channle。make(T…)</p>
<p>new：返回指针，即new(T)返回的是*T</p>
<h2 id="7-channel有缓冲和无缓冲"><a href="#7-channel有缓冲和无缓冲" class="headerlink" title="7.channel有缓冲和无缓冲"></a>7.channel有缓冲和无缓冲</h2><p><a href="https://blog.csdn.net/sgsgy5/article/details/82054902?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522162227719016780262526931%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=162227719016780262526931&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-82054902.first_rank_v2_pc_rank_v29&utm_term=%E6%9C%89%E7%BC%93%E5%86%B2channel&spm=1018.2226.3001.4187">有无缓冲</a></p>
<p>无缓冲：channel接收阻数据塞直到读取数据；channel发送阻塞直到数据被接收</p>
<p>有缓冲：当缓冲满时，channel接收数据阻塞；当缓冲空时，channel发送数据阻塞</p>
<p>无缓冲的  就是一个送信人去你家门口送信 ，你不在家 他不走，你一定要接下信，他才会走。</p>
<p>无缓冲保证信能到你手上（同步）</p>
<p>有缓冲的 就是一个送信人去你家仍到你家的信箱 转身就走 ，除非你的信箱满了 他必须等信箱空下来。</p>
<p>有缓冲的 保证 信能进你家的邮箱（非同步）</p>
<h2 id="8-并发方式和退出"><a href="#8-并发方式和退出" class="headerlink" title="8.并发方式和退出"></a>8.并发方式和退出</h2><p>并发：通常使用无缓冲chan来实现goroutine来是实现</p>
<p>退出：使用for-range来退出；使用，ok来退出；使用退出通道来退出</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// for-range是使用频率很高的结构，常用它来遍历数据，**range能够感知channel的关闭，当channel被发送数据的协程关闭时，range就会结束**，接着退出for循环。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    inCh := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(in &lt;-<span class="keyword">chan</span> <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">        <span class="comment">// Using for-range to exit goroutine</span></span><br><span class="line">        <span class="comment">// range has the ability to detect the close/end of a channel</span></span><br><span class="line">        <span class="keyword">for</span> x := <span class="keyword">range</span> in &#123;</span><br><span class="line">            fmt.Printf(<span class="string">&quot;Process %d\n&quot;</span>, x)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;(inCh)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用一个专门的通道，发送退出的信号</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">worker</span><span class="params">(stopCh &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">defer</span> fmt.Println(<span class="string">&quot;worker exit&quot;</span>)</span><br><span class="line">        <span class="comment">// Using stop channel explicit exit</span></span><br><span class="line">        <span class="keyword">for</span> &#123;</span><br><span class="line">            <span class="keyword">select</span> &#123;</span><br><span class="line">            <span class="keyword">case</span> &lt;-stopCh:</span><br><span class="line">                fmt.Println(<span class="string">&quot;Recv stop signal&quot;</span>)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">case</span> &lt;-t.C:</span><br><span class="line">                fmt.Println(<span class="string">&quot;Working .&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="9-interface-技巧"><a href="#9-interface-技巧" class="headerlink" title="9.interface()技巧"></a>9.interface()技巧</h2><ul>
<li>空接口    可以存放任意类型的数据</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    data := <span class="built_in">make</span>([]<span class="keyword">interface</span>&#123;&#125;, <span class="number">3</span>)</span><br><span class="line">    intData := <span class="number">1</span></span><br><span class="line">    stringData := <span class="string">&quot;abc&quot;</span></span><br><span class="line">    boolData := <span class="literal">true</span></span><br><span class="line">    data[<span class="number">0</span>] = intData</span><br><span class="line">    data[<span class="number">1</span>] = stringData</span><br><span class="line">    data[<span class="number">2</span>] = boolData</span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> data &#123;</span><br><span class="line">        fmt.Println(v)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<ul>
<li>接口嵌套</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> ReadWrite <span class="keyword">interface</span> &#123;</span><br><span class="line">    Read(b Buffer) <span class="type">bool</span></span><br><span class="line">    Write(b Buffer) <span class="type">bool</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Lock <span class="keyword">interface</span> &#123;</span><br><span class="line">    Lock()</span><br><span class="line">    Unlock()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> File <span class="keyword">interface</span> &#123;   <span class="comment">// 除了上面两个还有一个额外的close()接口</span></span><br><span class="line">    ReadWrite</span><br><span class="line">    Lock</span><br><span class="line">    Close()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<ul>
<li>类型选择和断言</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> v, ok := varI.(T); ok &#123;  <span class="comment">// 判断是否是自己想要的类型</span></span><br><span class="line">    assertion</span><br><span class="line">    Process(v)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h2 id="10-用信道实现主程等待协程2s-如果超过2s-主程直接结束-不用sleep"><a href="#10-用信道实现主程等待协程2s-如果超过2s-主程直接结束-不用sleep" class="headerlink" title="10.用信道实现主程等待协程2s,如果超过2s,主程直接结束(不用sleep)"></a>10.用信道实现主程等待协程2s,如果超过2s,主程直接结束(不用sleep)</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    start := time.Now()</span><br><span class="line">    wait := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;做点东西&quot;</span>)</span><br><span class="line">        time.Sleep(<span class="number">3</span>* time.Second)</span><br><span class="line">        wait &lt;- <span class="number">2</span></span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="string">&quot;这里是主程序&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> nums := &lt;-wait:    <span class="comment">// 当超过(阻塞)2s后，不会再执行这个条件，直接执行下面的</span></span><br><span class="line">        fmt.Println(nums)</span><br><span class="line">    <span class="keyword">case</span> &lt;-time.After(<span class="number">2</span> * time.Second): </span><br><span class="line">        fmt.Println(<span class="string">&quot;2秒后&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(time.Since(start))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>底层原理</tag>
        <tag>面试题</tag>
      </tags>
  </entry>
</search>

<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Go语言底层基础知识</title>
    <url>/2025/02/25/technology/golang/go-basic/</url>
    <content><![CDATA[<h2 id="new和make的区别"><a href="#new和make的区别" class="headerlink" title="new和make的区别"></a>new和make的区别</h2><ol>
<li>new和make都是全部用来分配内存的关键字，new(T)创建一个没有任何数据的类型为T的实例，并返回该实例的指针；make(T, args)只能创建 slice、map和channel，并且返回一个有初始值args（非零）的T类型的实例，非指针。</li>
<li>对于返回值，new用于类型的内存分配，并且内存置零，返回的是一个指向类型的指针；make是对他们的初始化，（非0值）返回的是一个类型引用对象 ，对于引用类型的变量，我们不光要声明它，还要为它分配内容空间 。</li>
<li>对于入参，new只有一个Type参数，Type可以是任何类型的数据；make传入Type参数（map、slice、chan）中的一种，还有一个size  。（map：根据slice大小分配资源，以足够存储size个元素，如果省略size，会默认分配一个小的起始size ；slice ：第一个是长度，第二个是cap（容量）；对于chan，size表示缓冲区容量；如果省略则表示channel为无缓冲的channel）<br>总结：</li>
</ol>
<ul>
<li><p>new() 是分配内存给一个零值的指针，返回的是这个类型的指针，还可以返回自己定义的结构体，置零之后的。</p>
</li>
<li><p>make（）是开辟一块内存，并且初始化，返回这个经过初始化的对象，只能初始化slice、map、chan，返回的是这个类型的引用，它可以设置初始化的长度，如果是slice，则可以添加一个参数，容量，容量的大小要小于slice的大小。</p>
</li>
</ul>
<h2 id="array和slice的区别"><a href="#array和slice的区别" class="headerlink" title="array和slice的区别"></a>array和slice的区别</h2><ol>
<li>array在定义的时候必须传入数组的长度，并且是一个常量，并且不可改变，数组的赋值都是值传递，所以一般情况会就比较耗费内存。</li>
<li>slice是通过指针引用底层数组，是对数组一个连续片段的引用，这个片段可以是全部的数组，也可以是其中的一个片段，slice自身是一个结构体，切片的长度可以改变。切片在进行append时，未超过切片的容量，进行浅拷贝（传递引用），超过容量，进行扩容的时候才会执行深拷贝（生成一个新的内存空间，不共享。）</li>
</ol>
<h2 id="通道是什么"><a href="#通道是什么" class="headerlink" title="通道是什么"></a>通道是什么</h2><p>通道是go中的一个通信方式，提供goroutine进行通信，可以为并发的两个实体之间提供通信通道，而不是共享内存的方式。<br>通道分为无缓冲通道和有缓冲通道:</p>
<ul>
<li>对于无缓冲通道，接收方从通道接收东西的时候，如果通道中没有消息，则接收方进入阻塞，直到通道中有消息。对于发送方，直到接收方收到消息之后，才能继续给通道发送消息。</li>
<li>对于有缓冲通道，指的是在通道中可以缓冲指定数量的数据，直到数据填满，发送方阻塞，直到接收方接收，采用了环形数组的方式进行存储。</li>
</ul>
<p>通道在Go中的代码定义:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> hchan <span class="keyword">struct</span> &#123;</span><br><span class="line">  qcount   <span class="type">uint</span>           <span class="comment">// 当前队列中剩余元素个数</span></span><br><span class="line">  dataqsiz <span class="type">uint</span>           <span class="comment">// 环形队列长度，即可以存放的元素个数</span></span><br><span class="line">  buf      unsafe.Pointer <span class="comment">// 环形队列指针</span></span><br><span class="line">  elemsize <span class="type">uint16</span>         <span class="comment">// 每个元素的大小</span></span><br><span class="line">  closed   <span class="type">uint32</span>            <span class="comment">// 标识关闭状态</span></span><br><span class="line">  elemtype *_type         <span class="comment">// 元素类型</span></span><br><span class="line">  sendx    <span class="type">uint</span>           <span class="comment">// 队列下标，指示元素写入时存放到队列中的位置</span></span><br><span class="line">  recvx    <span class="type">uint</span>           <span class="comment">// 队列下标，指示元素从队列的该位置读出</span></span><br><span class="line">  recvq    waitq          <span class="comment">// 等待读消息的goroutine队列</span></span><br><span class="line">  sendq    waitq          <span class="comment">// 等待写消息的goroutine队列</span></span><br><span class="line">  lock mutex              <span class="comment">// 互斥锁，chan不允许并发读写</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通道内部维护一个环形队列，队列的长度是在用户创建的时候指定的。</p>
<ul>
<li>sendx代表写入时的位置</li>
<li>recvx代表读数据时的位置</li>
<li>chan内部还维护了两个等待队列</li>
<li>一个等待读消息的groutine队列</li>
<li>一个等待写消息的groutine队列</li>
<li>一般情况下，recvq和sendq至少有一个为空；一个例外(同一个groutine使用select向channel一边写数据，一边读数据)</li>
</ul>
<p>注意：</p>
<ul>
<li> channel关闭之后任然可以读，如果channel中仍然有未读取的数据，则仍然可以读取到，没有数据会返回0。</li>
<li>关闭一个未初始化的channel会产生panic。</li>
<li>重复关闭同一个channel会产生painc。</li>
<li>从已经关闭的channel中读取消息不会产生painc，且能读出channel中还未被读取的消息，如果消息已经读出，则返回0值；(有缓冲无缓冲都是)。</li>
<li>关闭的channel中读取消息永远不会阻塞，并且会返回一个为false的ok-idiom。</li>
</ul>
<h2 id="map的底层实现"><a href="#map的底层实现" class="headerlink" title="map的底层实现"></a>map的底层实现</h2><p>golang的map是hasmap，使用数组+链表的形式 实现的，使用拉链法消除hash冲突。<br>map类型的变量默认初始值为nil，需要使用make()函数来分配内存。语法为：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">map</span>[keyType]ValueType</span><br><span class="line"><span class="built_in">make</span>(<span class="keyword">map</span>[KeyType]ValueType, [<span class="built_in">cap</span>])</span><br></pre></td></tr></table></figure>
<p>golang的map有两种重要的结构：hmap，bmap，主要就是hmap中包含bmap的一个指针。<br>存储时key不能重复，如果重复则覆盖value，通过key进行hash运算（可以简单的理解为把key转化为一个整数）然后对数组的长度取余,得到key存储在数组的哪个下标位置，咱以后将key和value组装成一个结构体，放入下标的位置。</p>
<h3 id="1-关于hash冲突"><a href="#1-关于hash冲突" class="headerlink" title="1. 关于hash冲突"></a>1. 关于hash冲突</h3><p>数组一个下标只能存储一个元素，也就是说一个数组下标只能存储一对key，value，hashkey（小明）&#x3D;4占用了下标0的位置，假设我们遇到了另一个key，它的hashkey(xiaowang)也是4，这就是hash冲突（不同的key经过hash之后得到的值一样）那么key&#x3D;xiaowang怎么存储？</p>
<ul>
<li><p>开放定址法：当我们存储一个key，value时，发现下标已经被占了，那么我们再这个数组中重新找一个没被占用的存储这个冲突的key，那么没有被占用的有很多，找哪个呢？常见的有线性探测法，线性补偿探测法、随机探测法。</p>
</li>
<li><p>线性探测：按照顺序来，从冲突的下标开始往后探测，到达数组末尾时，从数组开始探测，直到找到一个空位置存储这个key，当数组找不到的情况下会扩容（当数组快满的时候就会扩容了）；<br>如下图：首先存储key&#x3D;xiaoming在下标0处，当存储key&#x3D;xiaowang时，hash冲突了，按照线性探测，存储在下标1处，（红色的线是冲突或者下标已经被占用了） 再者key&#x3D;xiaozhao存储在下标4处，当存储key&#x3D;xiaoliu是，hash冲突了，按照线性探测，从头开始，存储在下标2处 （黄色的是冲突或者下标已经被占用了）</p>
<img data-src="/2025/02/25/technology/golang/go-basic/image_1.png" class="" title="图1">
</li>
<li><p>拉链法：拉链简单理解为链表，当key的hash冲突的时候，我们在冲突位置的元素上形成一个链表，通过指针相互连接，当查找时，发现key冲突，顺着链表一直往下找，直到链表的尾结点，找不到则返回空；<br>如下图描述：</p>
<img data-src="/2025/02/25/technology/golang/go-basic/image_2.png" class="" title="图2">
<p>开放定址和拉链的优缺点：</p>
<ul>
<li>拉链比线性探测处理简单</li>
<li>线性探测查找会比拉链更消耗时间</li>
<li>线性探测会比拉链更容易导致扩容，而拉链不会</li>
<li>拉链存储了指针，所以空间上会比线性探测占用多一点</li>
<li>拉链是动态申请存储空间的，所以更适合链长不确定的。</li>
</ul>
</li>
</ul>
<h3 id="2-HashMap怎么扩容"><a href="#2-HashMap怎么扩容" class="headerlink" title="2. HashMap怎么扩容"></a>2. HashMap怎么扩容</h3><p>首先需要知道哈希表的存储过程，当有新的数据进行存储的时候，需要根据key计算出它的哈希值h，假设哈希表的 容量是n，那么键值对就会放在h%n个位置中，如果该位置已经有了键值对，会分局开放寻址法或者拉链法解决冲突；<br>哈希表的扩容会创建原来的两倍容量，因此即使key的哈希值不变，求余结果也会改变，因此所有的键值对存放的位置都会发生改变，此时需要重新哈希。扩容的时候需要分配一个新的数组，新数组是老数组的2倍长，然后遍历旧的哈希，重新分配到新的结果中。</p>
<h2 id="Go中的interface关键字"><a href="#Go中的interface关键字" class="headerlink" title="Go中的interface关键字"></a>Go中的interface关键字</h2><ul>
<li>interface是方法声明的集合</li>
<li>任何类型的对象实现在interface接口中声明的全部方法，则表明这个类型实现了接口</li>
<li>interface可以作为一种数据类型，实现了该接口的任何对象，都可以给对应的接口类型变量赋值</li>
<li>interface可以被任意对象实现，一个类型&#x2F;对象也可以实现多个(interface)接口</li>
<li>继承和多态的特点，在golang的语法中对多态的特点体现从语法上不是很明显</li>
<li>父类是子类的私有内部类(组合)</li>
<li>发生多态的几个要素：（满足这三个条件，就可以产生多态的效果，父类可以调用子类的具体方法）</li>
<li>有interface接口，并且有接口定义的方法（可以看做一个类型，父类）</li>
<li>有子类去重写interface的接口</li>
<li>有父类指针指向子类的具体对象</li>
</ul>
<h2 id="GMP并发模型："><a href="#GMP并发模型：" class="headerlink" title="GMP并发模型："></a>GMP并发模型：</h2><ul>
<li>G代表goroutine,占用内存更小（几kb），能在有限的内存空间支持更多的并发,调度灵活度更高（runtime调度）</li>
<li>M代表操作系统线程，负责执行 Goroutine</li>
<li>P代表逻辑处理器，负责调度 Goroutine</li>
<li>包含了运行goroutine的资源processor处理</li>
<li>可以运行的G队列<br>在Go中线程是运行goroutine的实体，调度器（runtime）的功能是把可运行的    goroutine分配到工作线程上。<br>Goroutine调度器和OS调度器是通过M结合起来的，每个M都代表了1个内核线程，OS调度器负责把内核线程分配到CPU执行。<img data-src="/2025/02/25/technology/golang/go-basic/image_3.png" class="" title="图3"></li>
</ul>
<h3 id="1-GMP-模型的优势"><a href="#1-GMP-模型的优势" class="headerlink" title="1. GMP 模型的优势"></a>1. GMP 模型的优势</h3><ul>
<li><strong>高效利用 CPU</strong>：通过多 P 和多 M 的绑定，充分利用多核 CPU 的计算能力。</li>
<li><strong>低延迟</strong>：Goroutine 的调度由 Go 运行时负责，避免了操作系统线程切换的开销。</li>
<li><strong>高并发</strong>：Goroutine 的轻量级特性使得 Go 程序可以轻松创建成千上万的并发任务。<br>以下是一个简单的 Go 程序，展示了 Goroutine 的创建和调度：<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">worker</span><span class="params">(id <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;Worker %d: %d\n&quot;</span>, id, i)</span><br><span class="line">		time.Sleep(time.Second)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">		<span class="keyword">go</span> worker(i)</span><br><span class="line">	&#125;</span><br><span class="line">	time.Sleep(<span class="number">5</span> * time.Second) <span class="comment">// 等待所有 Goroutine 执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="GO的GC垃圾回收机制"><a href="#GO的GC垃圾回收机制" class="headerlink" title="GO的GC垃圾回收机制"></a>GO的GC垃圾回收机制</h2><p>三色标记清楚法：</p>
<ul>
<li>初始化所有的对象为白色；</li>
<li>从root根出发扫描所有的根对象，将他们引用的对象标记为灰色；</li>
<li>这里的根对象是程序运行到当前时刻的栈和全局数据区域；</li>
<li>分析灰色对象是否引用了其他的对象，如果没有引用其他的对象，则将该灰色标记为黑色，如果有引用，则将它变为黑色的同时将引用对象标记为灰色；</li>
<li>重复步骤三，直到灰色对象队列为空，此时白色的对象是垃圾，进行回收。</li>
</ul>
<h2 id="Context关键字"><a href="#Context关键字" class="headerlink" title="Context关键字"></a>Context关键字</h2><p>Go1.7加入了一个新的标准库context，它定义了Context类型，专门用来简化 对于处理单个请求的多个 goroutine 之间与请求域的数据、取消信号、截止时间等相关操作，这些操作可能涉及多个 API 调用。<br>对服务器传入的请求应该创建上下文，而对服务器的传出调用应该接受上下文。它们之间的函数调用链必须传递上下文，或者可以使用WithCancel(获得数据通知关闭)、(获得数据定时关闭)WithDeadline、(超时关闭)WithTimeout或(传递KV)WithValue创建的派生上下文。当一个上下文被取消时，它派生的所有上下文也被取消。<br>context.Background()返回的是全局的上下文根（我在文章中多次提到），context.TODO()返回的是空的上下文（表明应用的不确定性）</p>
<h2 id="GO内存分配与逃逸分析"><a href="#GO内存分配与逃逸分析" class="headerlink" title="GO内存分配与逃逸分析"></a>GO内存分配与逃逸分析</h2><ul>
<li>逃逸分析的好处是为了减少gc的压力,不逃逸的对象分配到栈上,当函数返回释放即可,不需要gc标记删除</li>
<li>逃逸分析完成之后可以确定哪些变量可以分配在栈上,栈的分配比堆快,性能好(逃逸变量分配到堆,不逃逸变量分配到栈)</li>
<li>同步消除,如果你定义的对象的方法上有同步锁,在运行时,却只有一个线程在访问,此时逃逸分析后的机器码会去掉同步锁运行<br>总结:</li>
<li>栈上分配内存比在堆中分配内存有更高的效率</li>
<li>栈上分配的内存不需要GC处理</li>
<li>堆上分配的内存使用完毕会交给GC处理</li>
<li>逃逸分析的目的是决定分配地址是栈还是堆</li>
<li>逃逸分析在编译阶段完成</li>
</ul>
<h3 id="1-函数传递指针真的比传值效率高吗"><a href="#1-函数传递指针真的比传值效率高吗" class="headerlink" title="1. 函数传递指针真的比传值效率高吗?"></a>1. 函数传递指针真的比传值效率高吗?</h3><ul>
<li>传递指针可以减少底层值拷贝,可以提高效率,但是如果拷贝数据量小,由于指针传递会产生逃逸;</li>
<li>可能会使用堆,也可能会增加GC的负担,所以传递指针不一定是高效的;<br><strong>栈</strong> :函数内存申请临时变量,并不会作为返回值返回,它就会被编译器申请到栈中<br>在函数中申请一个新对象,如果在栈中,函数执行结束会自动将内存回收;<br><strong>申请到栈内存好处</strong>:  函数返回直接释放,不会引起垃圾回收,对性能没有影响.<br><strong>堆</strong>:    函数申请内存之后,作为返回值返回了,编译器会默认变量之后还会被使用,<br>当函数返回之后并不会将内存归还,那么他就会被申请到堆中.<br>如果分配到堆中,则函数执行结束之后交给GC处理;<br><strong>申请到堆的内存</strong>  :  会引起垃圾回收,如果这个过程(特指垃圾回收不断被触发)过高频次就会导致gc压力过大,性能变低。<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">F</span><span class="params">()</span></span> []<span class="type">int</span>&#123;</span><br><span class="line">    a := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>, <span class="number">20</span>)</span><br><span class="line">    <span class="keyword">return</span> a</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">F</span><span class="params">()</span></span> &#123;</span><br><span class="line">    a := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>, <span class="number">20</span>)     <span class="comment">// 栈 空间小</span></span><br><span class="line">    b := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>, <span class="number">20000</span>) <span class="comment">// 堆 空间过大</span></span><br><span class="line"></span><br><span class="line">    l := <span class="number">20</span></span><br><span class="line">    c := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>, l) <span class="comment">// 堆 动态分配不定空间,也会在堆</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="2-什么是逃逸分析，有哪些场景"><a href="#2-什么是逃逸分析，有哪些场景" class="headerlink" title="2. 什么是逃逸分析，有哪些场景"></a>2. 什么是逃逸分析，有哪些场景</h3><p>逃逸分析指的是由编译器决定内存分配的位置,不需要开发者指定。</p>
<h3 id="1-逃逸场景-什么时候才会被分配到堆中"><a href="#1-逃逸场景-什么时候才会被分配到堆中" class="headerlink" title="1.逃逸场景(什么时候才会被分配到堆中)"></a>1.逃逸场景(什么时候才会被分配到堆中)</h3><ul>
<li>指针逃逸 : go可以返回局部变量指针,典型的变量逃逸案例</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="type">string</span></span><br><span class="line">    Age <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">StudentRegister</span><span class="params">(name <span class="type">string</span>,age <span class="type">int</span>)</span></span>*Student  &#123;</span><br><span class="line">    s :=<span class="built_in">new</span>(Student) <span class="comment">//局部变量s逃逸到堆</span></span><br><span class="line">    s.Name = name</span><br><span class="line">    s.Age = age</span><br><span class="line">    <span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    StudentRegister(<span class="string">&quot;Jin&quot;</span>,<span class="number">19</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>虽然在函数StudentRegister<strong>中内存s 为局部变量</strong>,它的值通过函数返回值返回,s本身为一个指针</p>
<p>它指向发内存地址不会是对,而是栈,这是典型的逃逸案例</p>
<p>终端执行: go build -gcflags &#x3D; - m</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">C:\Users\Administrator\<span class="keyword">go</span>\src\内存逃逸分析&gt;<span class="keyword">go</span> build -gcflags=-m</span><br><span class="line"># 内存逃逸分析</span><br><span class="line">.\<span class="number">1.</span>指针逃逸.<span class="keyword">go</span>:<span class="number">8</span>:<span class="number">6</span>: can inline StudentRegister</span><br><span class="line">.\<span class="number">1.</span>指针逃逸.<span class="keyword">go</span>:<span class="number">15</span>:<span class="number">6</span>: can inline main</span><br><span class="line">.\<span class="number">1.</span>指针逃逸.<span class="keyword">go</span>:<span class="number">16</span>:<span class="number">17</span>: inlining call to StudentRegister</span><br><span class="line">.\<span class="number">1.</span>指针逃逸.<span class="keyword">go</span>:<span class="number">8</span>:<span class="number">22</span>: leaking param: name</span><br><span class="line">.\<span class="number">1.</span>指针逃逸.<span class="keyword">go</span>:<span class="number">9</span>:<span class="number">9</span>: <span class="built_in">new</span>(Student) escapes to heap  <span class="comment">//显示指针逃逸</span></span><br><span class="line">.\<span class="number">1.</span>指针逃逸.<span class="keyword">go</span>:<span class="number">16</span>:<span class="number">17</span>: <span class="built_in">new</span>(Student) does not escape</span><br></pre></td></tr></table></figure>

<ul>
<li>栈空间不足逃逸(空间开辟过大)</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Slice</span><span class="params">()</span></span> &#123;</span><br><span class="line">    s := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">10000</span>, <span class="number">10000</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> index, _ := <span class="keyword">range</span> s &#123;</span><br><span class="line">        s[index] = index</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    Slice()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//当切片长度扩大到100000时会逃逸</span></span><br><span class="line"><span class="comment">//实际上当栈空间不足以存放当前对象或者无法判断当前切片长度时会将对象分配到堆中</span></span><br><span class="line"></span><br><span class="line">C:\Users\Administrator\<span class="keyword">go</span>\src\内存逃逸分析&gt;<span class="keyword">go</span> build -gcflags=-m</span><br><span class="line"># 内存逃逸分析</span><br><span class="line">.\<span class="number">1.</span>指针逃逸.<span class="keyword">go</span>:<span class="number">11</span>:<span class="number">6</span>: can inline main</span><br><span class="line">.\<span class="number">1.</span>指针逃逸.<span class="keyword">go</span>:<span class="number">4</span>:<span class="number">11</span>: <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">10000</span>, <span class="number">10000</span>) escapes to heap</span><br></pre></td></tr></table></figure>

<ul>
<li>动态类型逃逸(不确定长度大小)</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    s := <span class="string">&quot;Escape&quot;</span></span><br><span class="line">    fmt.Println(s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">C:\Users\Administrator\<span class="keyword">go</span>\src\内存逃逸分析&gt;<span class="keyword">go</span> build -gcflags=-m</span><br><span class="line"># 内存逃逸分析</span><br><span class="line">.\<span class="number">1.</span>指针逃逸.<span class="keyword">go</span>:<span class="number">7</span>:<span class="number">13</span>: inlining call to fmt.Println</span><br><span class="line">.\<span class="number">1.</span>指针逃逸.<span class="keyword">go</span>:<span class="number">7</span>:<span class="number">13</span>: s escapes to heap</span><br><span class="line">.\<span class="number">1.</span>指针逃逸.<span class="keyword">go</span>:<span class="number">7</span>:<span class="number">13</span>: []<span class="keyword">interface</span> &#123;&#125; literal does not escape</span><br><span class="line">&lt;autogenerated&gt;:<span class="number">1</span>: .this does not escape</span><br><span class="line">&lt;autogenerated&gt;:<span class="number">1</span>: .this does not escape</span><br></pre></td></tr></table></figure>

<ul>
<li>闭包引用对象逃逸</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Fibonacci</span><span class="params">()</span></span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    a, b := <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">int</span> &#123;</span><br><span class="line">        a, b = b, a+b</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    f := Fibonacci()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;Fibonacci: %d\n&quot;</span>, f())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">C:\Users\Administrator\<span class="keyword">go</span>\src\内存逃逸分析&gt;<span class="keyword">go</span> build -gcflags=-m</span><br><span class="line"># 内存逃逸分析</span><br><span class="line">.\<span class="number">1.</span>指针逃逸.<span class="keyword">go</span>:<span class="number">7</span>:<span class="number">9</span>: can inline Fibonacci.func1</span><br><span class="line">.\<span class="number">1.</span>指针逃逸.<span class="keyword">go</span>:<span class="number">17</span>:<span class="number">13</span>: inlining call to fmt.Printf</span><br><span class="line">.\<span class="number">1.</span>指针逃逸.<span class="keyword">go</span>:<span class="number">6</span>:<span class="number">2</span>: moved to heap: a</span><br><span class="line">.\<span class="number">1.</span>指针逃逸.<span class="keyword">go</span>:<span class="number">6</span>:<span class="number">5</span>: moved to heap: b</span><br><span class="line">.\<span class="number">1.</span>指针逃逸.<span class="keyword">go</span>:<span class="number">7</span>:<span class="number">9</span>: <span class="function"><span class="keyword">func</span> <span class="title">literal</span> <span class="title">escapes</span> <span class="title">to</span> <span class="title">heap</span></span></span><br><span class="line">.\<span class="number">1.</span>指针逃逸.<span class="keyword">go</span>:<span class="number">17</span>:<span class="number">34</span>: f() escapes to heap</span><br><span class="line">.\<span class="number">1.</span>指针逃逸.<span class="keyword">go</span>:<span class="number">17</span>:<span class="number">13</span>: []<span class="keyword">interface</span> &#123;&#125; literal does not escape</span><br><span class="line">&lt;autogenerated&gt;:<span class="number">1</span>: .this does not escape</span><br><span class="line">&lt;autogenerated&gt;:<span class="number">1</span>: .this does not escape</span><br></pre></td></tr></table></figure>

<h2 id="runtime机制是什么"><a href="#runtime机制是什么" class="headerlink" title="runtime机制是什么"></a>runtime机制是什么</h2><p>go 语言的可执行文件已经包含了 golang 的 runtime，它为用户的 go 程序提供协程调度、内存分配、垃圾回收等功能.此外还会与系统内核进行交互，从而真正的利用好 CPU 等资源。</p>
<ul>
<li><strong>Gosched</strong>：让当前线程让出 <code>cpu</code> 以让其它线程运行,它不会挂起当前线程，因此当前线程未来会继续执行</li>
<li><strong>NumCPU</strong>：返回当前系统的 <code>CPU</code> 核数量</li>
<li><strong>GOMAXPROCS</strong>：设置最大的可同时使用的 <code>CPU</code> 核数</li>
<li><strong>Goexit</strong>：退出当前 <code>goroutine</code>(但是<code>defer</code>语句会照常执行)</li>
<li><strong>NumGoroutine</strong>：返回正在执行和排队的任务总数</li>
<li><strong>GOOS</strong>：目标操作系统</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">fmt.Println(<span class="string">&quot;cpus:&quot;</span>, runtime.NumCPU())</span><br><span class="line">fmt.Println(<span class="string">&quot;goroot:&quot;</span>, runtime.GOROOT())</span><br><span class="line">fmt.Println(<span class="string">&quot;archive:&quot;</span>, runtime.GOOS)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>底层原理</tag>
      </tags>
  </entry>
  <entry>
    <title>Go高频面试题</title>
    <url>/2025/02/25/technology/golang/interview_issue/</url>
    <content><![CDATA[<h2 id="1-关于select"><a href="#1-关于select" class="headerlink" title="1.关于select"></a>1.关于select</h2><ul>
<li><p>select是Go语言中的一个控制语句，类似于switch，但是select主要用于通道操作（每一个case必须是一个通信操作，要么接收，要么发送）。 </p>
</li>
<li><p>select会随机选择一个可以运行的case；如果没有case可运行，那么将会阻塞，直到有一个case可以运行。</p>
</li>
</ul>
<h2 id="2-变量会怎么分配："><a href="#2-变量会怎么分配：" class="headerlink" title="2.变量会怎么分配："></a>2.变量会怎么分配：</h2><p>变量分配在栈还是堆是由go编译器自己控制的；编译时，会做逃逸分析，当变量作用域没有跑出函数的范围，就放在栈上；反之则必须放在堆上。<a href="https://flowus.cn/457cce5a-ba8c-4b3e-90a8-14eae4123db5">Go内存逃逸分析</a></p>
<h2 id="3-GC垃圾回收"><a href="#3-GC垃圾回收" class="headerlink" title="3.GC垃圾回收"></a>3.GC垃圾回收</h2><ul>
<li><p>v1.3：标记清除：整体过程需要启动STW，效率极低。</p>
</li>
<li><p>v1.5：三色标记法：堆空间启动写屏障，栈空间不启动，全部扫描之后，需要重新扫描一次栈(需要STW)，效率普通</p>
</li>
<li><p>v1.8：混合写屏障机制： 栈空间不启动，堆空间启动。整个过程几乎不需要STW，效率较高 <a href="https://flowus.cn/8af645f6-50e2-4584-8d89-c6ed49dbef6c">Go垃圾回收</a></p>
</li>
</ul>
<h2 id="4-协程调度GPM"><a href="#4-协程调度GPM" class="headerlink" title="4.协程调度GPM"></a>4.协程调度GPM</h2><p>G：就是个goroutine（调度系统最基本的单位），里面除了存放本goroutine信息（执行stack信息；状态信息；所在的任务函数信息等）与所在P的绑定等信息。</p>
<p>P：就是process，管理着一组goroutine队列，存储当前goroutine运行的上下文环境。</p>
<p>M：machine，代表着真正的执行计算资源。</p>
<p>P管理着一组G在M上执行。<a href="https://flowus.cn/00f325cf-3352-461e-a91f-419ae8c3a4ef">GPM轻量理解</a></p>
<ul>
<li><p>每一个运行的M都必须绑定一个P，线程M创建后会检查并执行G对象</p>
</li>
<li><p>每一个P都保存着一个G队列</p>
</li>
<li><p>除了P保存的G队列外，还有一个全局G队列</p>
</li>
<li><p>M从队列中取出G并执行</p>
</li>
<li><p>P的个数就是 GOMAXPROCS(256)，一般不做修改</p>
</li>
<li><p>M的个数和P的个数不一定一样多</p>
</li>
<li><p>P是一个全局数组（255）来保存，并且维护者一个全局的P空闲链表</p>
</li>
</ul>
<h2 id="5-runtime机制"><a href="#5-runtime机制" class="headerlink" title="5.runtime机制"></a>5.runtime机制</h2><p><a href="https://blog.csdn.net/futurewu/article/details/104692651?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522162220408116780262566000%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=162220408116780262566000&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_v2~rank_v29-2-104692651.first_rank_v2_pc_rank_v29&utm_term=golang+%E7%9A%84+runtime+%E6%9C%BA%E5%88%B6&spm=1018.2226.3001.4187">runtime机制</a></p>
<p>runtime负责：管理调度，垃圾回收以及运行环境等。。Go语言的goroutine，channel这些高级功能都需要runtime的支持。</p>
<p>如何运行：用户编译代码后，runtime和编译后的代码会被静态链接起来，形成一个可执行文件。runtime通过接口函数调用来管理goroutine，channel这些高级功能；而且从用户代码调用操作系统的API调用会被runtime拦截处理。</p>
<p>组成：一个重要组成部分是goroutine scheduler ，它负责追踪调度goroutine运行，实际上是从应用程序的process所属的thread pool（线程池）中分配一个thread来执行这个goroutine。因此，每个goroutine只有分配到一个OS thread才能运行。</p>
<h2 id="6-make和new的区别"><a href="#6-make和new的区别" class="headerlink" title="6.make和new的区别"></a>6.make和new的区别</h2><p><a href="https://www.cnblogs.com/ghj1976/archive/2013/02/12/2910384.html">区别</a></p>
<p>make：返回初始化后的值。make是引用类型初始化的方法；常用于slice,map,channle。make(T…)</p>
<p>new：返回指针，即new(T)返回的是*T</p>
<h2 id="7-channel有缓冲和无缓冲"><a href="#7-channel有缓冲和无缓冲" class="headerlink" title="7.channel有缓冲和无缓冲"></a>7.channel有缓冲和无缓冲</h2><p><a href="https://blog.csdn.net/sgsgy5/article/details/82054902?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522162227719016780262526931%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=162227719016780262526931&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-82054902.first_rank_v2_pc_rank_v29&utm_term=%E6%9C%89%E7%BC%93%E5%86%B2channel&spm=1018.2226.3001.4187">有无缓冲</a></p>
<p>无缓冲：channel接收阻数据塞直到读取数据；channel发送阻塞直到数据被接收</p>
<p>有缓冲：当缓冲满时，channel接收数据阻塞；当缓冲空时，channel发送数据阻塞</p>
<p>无缓冲的  就是一个送信人去你家门口送信 ，你不在家 他不走，你一定要接下信，他才会走。</p>
<p>无缓冲保证信能到你手上（同步）</p>
<p>有缓冲的 就是一个送信人去你家仍到你家的信箱 转身就走 ，除非你的信箱满了 他必须等信箱空下来。</p>
<p>有缓冲的 保证 信能进你家的邮箱（非同步）</p>
<h2 id="8-并发方式和退出"><a href="#8-并发方式和退出" class="headerlink" title="8.并发方式和退出"></a>8.并发方式和退出</h2><p>并发：通常使用无缓冲chan来实现goroutine来是实现</p>
<p>退出：使用for-range来退出；使用，ok来退出；使用退出通道来退出</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// for-range是使用频率很高的结构，常用它来遍历数据，**range能够感知channel的关闭，当channel被发送数据的协程关闭时，range就会结束**，接着退出for循环。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    inCh := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(in &lt;-<span class="keyword">chan</span> <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">        <span class="comment">// Using for-range to exit goroutine</span></span><br><span class="line">        <span class="comment">// range has the ability to detect the close/end of a channel</span></span><br><span class="line">        <span class="keyword">for</span> x := <span class="keyword">range</span> in &#123;</span><br><span class="line">            fmt.Printf(<span class="string">&quot;Process %d\n&quot;</span>, x)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;(inCh)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用一个专门的通道，发送退出的信号</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">worker</span><span class="params">(stopCh &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">defer</span> fmt.Println(<span class="string">&quot;worker exit&quot;</span>)</span><br><span class="line">        <span class="comment">// Using stop channel explicit exit</span></span><br><span class="line">        <span class="keyword">for</span> &#123;</span><br><span class="line">            <span class="keyword">select</span> &#123;</span><br><span class="line">            <span class="keyword">case</span> &lt;-stopCh:</span><br><span class="line">                fmt.Println(<span class="string">&quot;Recv stop signal&quot;</span>)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">case</span> &lt;-t.C:</span><br><span class="line">                fmt.Println(<span class="string">&quot;Working .&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="9-interface-技巧"><a href="#9-interface-技巧" class="headerlink" title="9.interface()技巧"></a>9.interface()技巧</h2><ul>
<li>空接口    可以存放任意类型的数据</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    data := <span class="built_in">make</span>([]<span class="keyword">interface</span>&#123;&#125;, <span class="number">3</span>)</span><br><span class="line">    intData := <span class="number">1</span></span><br><span class="line">    stringData := <span class="string">&quot;abc&quot;</span></span><br><span class="line">    boolData := <span class="literal">true</span></span><br><span class="line">    data[<span class="number">0</span>] = intData</span><br><span class="line">    data[<span class="number">1</span>] = stringData</span><br><span class="line">    data[<span class="number">2</span>] = boolData</span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> data &#123;</span><br><span class="line">        fmt.Println(v)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<ul>
<li>接口嵌套</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> ReadWrite <span class="keyword">interface</span> &#123;</span><br><span class="line">    Read(b Buffer) <span class="type">bool</span></span><br><span class="line">    Write(b Buffer) <span class="type">bool</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Lock <span class="keyword">interface</span> &#123;</span><br><span class="line">    Lock()</span><br><span class="line">    Unlock()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> File <span class="keyword">interface</span> &#123;   <span class="comment">// 除了上面两个还有一个额外的close()接口</span></span><br><span class="line">    ReadWrite</span><br><span class="line">    Lock</span><br><span class="line">    Close()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<ul>
<li>类型选择和断言</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> v, ok := varI.(T); ok &#123;  <span class="comment">// 判断是否是自己想要的类型</span></span><br><span class="line">    assertion</span><br><span class="line">    Process(v)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h2 id="10-用信道实现主程等待协程2s-如果超过2s-主程直接结束-不用sleep"><a href="#10-用信道实现主程等待协程2s-如果超过2s-主程直接结束-不用sleep" class="headerlink" title="10.用信道实现主程等待协程2s,如果超过2s,主程直接结束(不用sleep)"></a>10.用信道实现主程等待协程2s,如果超过2s,主程直接结束(不用sleep)</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    start := time.Now()</span><br><span class="line">    wait := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;做点东西&quot;</span>)</span><br><span class="line">        time.Sleep(<span class="number">3</span>* time.Second)</span><br><span class="line">        wait &lt;- <span class="number">2</span></span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="string">&quot;这里是主程序&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> nums := &lt;-wait:    <span class="comment">// 当超过(阻塞)2s后，不会再执行这个条件，直接执行下面的</span></span><br><span class="line">        fmt.Println(nums)</span><br><span class="line">    <span class="keyword">case</span> &lt;-time.After(<span class="number">2</span> * time.Second): </span><br><span class="line">        fmt.Println(<span class="string">&quot;2秒后&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(time.Since(start))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>底层原理</tag>
        <tag>面试题</tag>
      </tags>
  </entry>
</search>

<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Go-GC垃圾回收</title>
    <url>/2021/02/03/technology/golang/gc_recycle/</url>
    <content><![CDATA[<h2 id="Go垃圾回收"><a href="#Go垃圾回收" class="headerlink" title="Go垃圾回收"></a>Go垃圾回收</h2><ul>
<li><p>G0 V1.3之前的标记-清除(mark and sweep)算法</p>
</li>
<li><p>Go V1.3之前的标记-清扫(mark and sweep)的缺点</p>
</li>
<li><p>Go V1.5的三色并发标记法</p>
</li>
<li><p>Go V1.5的三色标记为什么需要STW</p>
</li>
<li><p>Go V1.5的三色标记为什么需要屏障机制(“强-弱” 三色不变式、插入屏障、删除屏障 )</p>
</li>
<li><p>Go V1.8混合写屏障机制</p>
</li>
<li><p>Go V1.8混合写屏障机制的全场景分析</p>
</li>
</ul>
<h2 id="Go-V1-3-之前的标记-清除-mark-and-sweep-算法"><a href="#Go-V1-3-之前的标记-清除-mark-and-sweep-算法" class="headerlink" title="Go V1.3 之前的标记-清除(mark and sweep)算法"></a>Go V1.3 之前的标记-清除(mark and sweep)算法</h2><h4 id="步骤："><a href="#步骤：" class="headerlink" title="步骤："></a>步骤：</h4><ul>
<li><p>标记(Mark phase)</p>
</li>
<li><p>清除(Sweep phase)</p>
</li>
</ul>
<p><strong>第一步</strong>，暂停程序业务逻辑, 找出不可达的对象，然后做上标记。</p>
<p>操作非常简单，但是有一点需要额外注意：mark and sweep算法在执行的时候，需要程序暂停！即 <code>STW(stop the world)</code>。也就是说，这段时间程序会卡在哪儿。</p>
<img data-src="/2021/02/03/technology/golang/gc_recycle/image.png" class="" title="image.png">


<p><strong>第二步</strong>, 开始标记，程序找出它所有可达的对象，并做上标记。如下图所示：</p>
<img data-src="/2021/02/03/technology/golang/gc_recycle/image_1.png" class="" title="image.png">

<p><strong>第三步</strong>, 标记完了之后，然后开始清除未标记的对象. 结果如下.</p>
<img data-src="/2021/02/03/technology/golang/gc_recycle/image_2.png" class="" title="image.png">

<p><strong>第四步</strong>, 停止暂停，让程序继续跑。然后循环重复这个过程，直到process程序生命周期结束。</p>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul>
<li>STW，stop the world；让程序暂停，程序出现卡顿 (重要问题)。</li>
<li>标记需要扫描整个heap</li>
<li>清除数据会产生heap碎片</li>
</ul>
<p>所以Go V1.3版本之前就是以上来实施的, 流程是</p>
<img data-src="/2021/02/03/technology/golang/gc_recycle/image_3.png" class="" title="image.png">
<p>Go V1.3 做了简单的优化,将STW提前, 减少STW暂停的时间范围.如下所示</p>
<img data-src="/2021/02/03/technology/golang/gc_recycle/image_4.png" class="" title="image.png">
<p><strong>这里面最重要的问题就是：mark-and-sweep 算法会暂停整个程序。</strong><br>Go是如何面对并这个问题的呢？接下来G V1.5版本 就用三色并发标记法来优化这个问题.</p>
<h2 id="Go-V1-5的三色并发标记法"><a href="#Go-V1-5的三色并发标记法" class="headerlink" title="Go V1.5的三色并发标记法"></a>Go V1.5的三色并发标记法</h2><p>三色标记法 实际上就是通过三个阶段的标记来确定清楚的对象都有哪些. 我们来看一下具体的过程.</p>
<p><strong>第一步</strong>, 就是只要是新创建的对象,默认的颜色都是标记为“白色”.</p>
<img data-src="/2021/02/03/technology/golang/gc_recycle/image_5.png" class="" title="image.png">
<p>这里面需要注意的是, 所谓“程序”, 则是一些对象的跟节点集合.</p>
<img data-src="/2021/02/03/technology/golang/gc_recycle/image_6.png" class="" title="image.png">
<p>所以上图,可以转换如下的方式来表示.</p>
<p><strong>第二步</strong>, 每次GC回收开始, 然后从根节点开始遍历所有对象，把遍历到的对象从白色集合放入“灰色”集合。</p>
<img data-src="/2021/02/03/technology/golang/gc_recycle/image_7.png" class="" title="image.png">
<p><strong>第三步</strong>, 遍历灰色集合，将灰色对象引用的对象从白色集合放入灰色集合，之后将此灰色对象放入黑色集合</p>
<img data-src="/2021/02/03/technology/golang/gc_recycle/image_8.png" class="" title="image.png">
<p><strong>第四步</strong>, 重复第三步, 直到灰色中无任何对象.</p>
<img data-src="/2021/02/03/technology/golang/gc_recycle/image_9.png" class="" title="image.png">
<img data-src="/2021/02/03/technology/golang/gc_recycle/image_10.png" class="" title="image.png">
<p><strong>第五步</strong>，回收所有的白色标记表的对象. 也就是回收垃圾.</p>
<img data-src="/2021/02/03/technology/golang/gc_recycle/image_11.png" class="" title="image.png">

<p>以上便是<code>三色并发标记法</code>, 不难看出,我们上面已经清楚的体现<code>三色</code>的特性</p>
<h2 id="没有STW的三色标记法"><a href="#没有STW的三色标记法" class="headerlink" title="没有STW的三色标记法"></a>没有STW的三色标记法</h2><p>我们还是基于上述的三色并发标记法来说, 他是一定要依赖STW的. 因为如果不暂停程序, 程序的逻辑改变对象引用关系, 这种动作如果在标记阶段做了修改，会影响标记结果的正确性。我们举一个场景.</p>
<p>如果三色标记法, 标记过程不使用STW将会发生什么事情?</p>
<img data-src="/2021/02/03/technology/golang/gc_recycle/image_12.png" class="" title="image.png">
<hr>
<img data-src="/2021/02/03/technology/golang/gc_recycle/image_13.png" class="" title="image.png">




<img data-src="/2021/02/03/technology/golang/gc_recycle/image_14.png" class="" title="image.png">
<img data-src="/2021/02/03/technology/golang/gc_recycle/image_15.png" class="" title="image.png">
<img data-src="/2021/02/03/technology/golang/gc_recycle/image_16.png" class="" title="image.png">
<p>可以看出，有两个问题, 在三色标记法中,是不希望被发生的</p>
<ul>
<li><p><strong>条件1:</strong> 一个白色对象被黑色对象引用(白色被挂在黑色下)</p>
</li>
<li><p><strong>条件2:</strong> 灰色对象与它之间的可达关系的白色对象遭到破坏(灰色同时丢了该白色)</p>
</li>
</ul>
<p>当以上两个条件同时满足时, 就会出现对象丢失现象!</p>
<p>当然, 如果上述中的白色对象3, 如果他还有很多下游对象的话, 也会一并都清理掉.</p>
<p>为了防止这种现象的发生，最简单的方式就是STW，直接禁止掉其他用户程序对对象引用关系的干扰，但是STW的过程有明显的资源浪费，对所有的用户程序都有很大影响，如何能在保证对象不丢失的情况下合理的尽可能的提高GC效率，减少STW时间呢？</p>
<p>答案就是, 那么我们只要使用一个机制,来破坏上面的两个条件就可以了.</p>
<p>五、屏障机制</p>
<p>我们让GC回收器,满足下面两种情况之一时,可保对象不丢失. 所以引出两种方式.</p>
<h4 id="“强-弱”-三色不变式"><a href="#“强-弱”-三色不变式" class="headerlink" title="“强-弱” 三色不变式"></a>“强-弱” 三色不变式</h4><p>01</p>
<ul>
<li><strong>强三色不变式</strong></li>
</ul>
<p>不存在黑色对象引用到白色对象的指针。</p>
<img data-src="/2021/02/03/technology/golang/gc_recycle/image_17.png" class="" title="image.png">
<ul>
<li><strong>弱三色不变式</strong></li>
</ul>
<p>所有被黑色对象引用的白色对象都处于灰色保护状态.</p>
<img data-src="/2021/02/03/technology/golang/gc_recycle/image_18.png" class="" title="image.png">

<p>为了遵循上述的两个方式,Golang团队初步得到了如下具体的两种屏障方式“插入屏障”, “删除屏障”.</p>
<h4 id="插入屏障"><a href="#插入屏障" class="headerlink" title="插入屏障"></a>插入屏障</h4><p>02</p>
<p><code>具体操作</code>: 在A对象引用B对象的时候，B对象被标记为灰色。(将B挂在A下游，B必须被标记为灰色)</p>
<p><code>满足</code>: 强三色不变式. (不存在黑色对象引用白色对象的情况了， 因为白色会强制变成灰色)</p>
<p>伪码如下:</p>
<p><code>添加下游对象``(``当前下游对象**slot**``,</code> <code>新下游对象**ptr**``) &#123;     //1     标记灰色(``新下游对象**ptr**``)          //2    `` 当前下游对象**slot**</code> <code>=</code> <code>新下游对象**ptr**``   &#125;</code></p>
<p>场景：</p>
<figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="code"><pre><span class="line">A.添加下游对象(nil, B)   //A 之前没有下游， 新添加一个下游对象B， B被标记为灰色</span><br><span class="line">A.添加下游对象(C, B)     //A 将下游对象C 更换为B，  B被标记为灰色</span><br></pre></td></tr></table></figure>


<p>这段伪码逻辑就是写屏障,. 我们知道,黑色对象的内存槽有两种位置, <code>栈</code>和<code>堆</code>. 栈空间的特点是容量小,但是要求相应速度快,因为函数调用弹出频繁使用, 所以“插入屏障”机制,在栈空间的对象操作中不使用. 而仅仅使用在堆空间对象的操作中.</p>
<p>接下来，我们用几张图，来模拟整个一个详细的过程， 希望您能够更可观的看清晰整体流程。</p>
<img data-src="/2021/02/03/technology/golang/gc_recycle/image_19.png" class="" title="image.png">
<img data-src="/2021/02/03/technology/golang/gc_recycle/image_20.png" class="" title="image.png">
<img data-src="/2021/02/03/technology/golang/gc_recycle/image_21.png" class="" title="image.png">

<img data-src="/2021/02/03/technology/golang/gc_recycle/image_22.png" class="" title="image.png">



<img data-src="/2021/02/03/technology/golang/gc_recycle/image_23.png" class="" title="image.png">

<img data-src="/2021/02/03/technology/golang/gc_recycle/image_24.png" class="" title="image.png">

<p>但是如果栈不添加,当全部三色标记扫描之后,栈上有可能依然存在白色对象被引用的情况(如上图的对象9). 所以要对栈重新进行三色标记扫描, 但这次为了对象不丢失, 要对本次标记扫描启动STW暂停. 直到栈空间的三色标记结束.</p>
<img data-src="/2021/02/03/technology/golang/gc_recycle/image_25.png" class="" title="image.png">

<img data-src="/2021/02/03/technology/golang/gc_recycle/image_26.png" class="" title="image.png">

<img data-src="/2021/02/03/technology/golang/gc_recycle/image_27.png" class="" title="image.png">

<p>最后将栈和堆空间 扫描剩余的全部 白色节点清除. 这次STW大约的时间在10~100ms间.</p>
<img data-src="/2021/02/03/technology/golang/gc_recycle/image_28.png" class="" title="image.png">

<hr>
<h4 id="删除屏障"><a href="#删除屏障" class="headerlink" title="删除屏障"></a>删除屏障</h4><p>03</p>
<p><code>具体操作</code>: 被删除的对象，如果自身为灰色或者白色，那么被标记为灰色。</p>
<p><code>满足</code>: 弱三色不变式. (保护灰色对象到白色对象的路径不会断)</p>
<p>伪代码：</p>
<p><code>添加下游对象``(``当前下游对象**slot**``，</code> <code>新下游对象**ptr**``) &#123;     //1     if (``当前下游对象**slot**``是灰色 ||</code> <code>当前下游对象**slot**``是白色) &#123;             标记灰色(``当前下游对象**slo**``**t**``) //slot为被删除对象， 标记为灰色     &#125;          //2</code>  <code>当前下游对象**slot**</code> <code>=</code> <code>新下游对象**ptr**``   &#125;</code></p>
<p>场景：</p>
<figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="code"><pre><span class="line">A.添加下游对象(B, nil)   //A对象，删除B对象的引用。B被A删除，被标记为灰(如果B之前为白)</span><br><span class="line">A.添加下游对象(B, C)     //A对象，更换下游B变成C。B被A删除，被标记为灰(如果B之前为白)</span><br></pre></td></tr></table></figure>


<p>接下来，我们用几张图，来模拟整个一个详细的过程， 希望您能够更可观的看清晰整体流程。</p>
<img data-src="/2021/02/03/technology/golang/gc_recycle/image_29.png" class="" title="image.png">
<img data-src="/2021/02/03/technology/golang/gc_recycle/image_30.png" class="" title="image.png">
<img data-src="/2021/02/03/technology/golang/gc_recycle/image_31.png" class="" title="image.png">

<img data-src="/2021/02/03/technology/golang/gc_recycle/image_32.png" class="" title="image.png">

<img data-src="/2021/02/03/technology/golang/gc_recycle/image_33.png" class="" title="image.png">

<img data-src="/2021/02/03/technology/golang/gc_recycle/image_34.png" class="" title="image.png">

<img data-src="/2021/02/03/technology/golang/gc_recycle/image_35.png" class="" title="image.png">





<p>这种方式的回收精度低，一个对象即使被删除了最后一个指向它的指针也依旧可以活过这一轮，在下一轮GC中被清理掉。</p>
<p>六、Go V1.8的混合写屏障(hybrid write barrier)机制</p>
<p>插入写屏障和删除写屏障的短板：</p>
<ul>
<li><strong>插入写屏障</strong>：结束时需要STW来重新扫描栈，标记栈上引用的白色对象的</li>
</ul>
<p>存活；</p>
<ul>
<li><strong>删除写屏障</strong>：回收精度低，GC开始时STW扫描堆栈来记录初始快照，这个</li>
</ul>
<p>过程会保护开始时刻的所有存活对象。</p>
<p>Go V1.8版本引入了混合写屏障机制（hybrid write barrier）,避免了对栈</p>
<p>re-scan的过程，极大的减少了STW的时间。结合了两者的优点。</p>
<hr>
<h4 id="混合写屏障规则"><a href="#混合写屏障规则" class="headerlink" title="混合写屏障规则"></a>混合写屏障规则</h4><p>01</p>
<p><code>具体操作</code>:</p>
<p>1、GC开始将栈上的对象全部扫描并标记为黑色(之后不再进行第二次重复扫描，无需STW)，</p>
<p>2、GC期间，任何在栈上创建的新对象，均为黑色。</p>
<p>3、被删除的对象标记为灰色。</p>
<p>4、被添加的对象标记为灰色。</p>
<p><code>满足</code>: 变形的弱三色不变式.</p>
<p>伪代码：</p>
<p><code>添加下游对象``(``当前下游对象**slot**``,</code> <code>新下游对象**ptr**``) &#123;         //1         标记灰色(``当前下游对象**slot**``) //只要当前下游对象被移走，就标记灰色                  //2         标记灰色(``新下游对象**ptr**``)                      //3</code>      <code>当前下游对象**slot**</code> <code>=</code> <code>新下游对象**ptr**``   &#125;</code></p>
<p>这里我们注意， 屏障技术是不在栈上应用的，因为要保证栈的运行效率。</p>
<h4 id="混合写屏障的具体场景分析"><a href="#混合写屏障的具体场景分析" class="headerlink" title="混合写屏障的具体场景分析"></a>混合写屏障的具体场景分析</h4><p>02</p>
<pre><code>    接下来，我们用几张图，来模拟整个一个详细的过程， 希望您能够更可观的看清晰整体流程。
</code></pre>
<p>注意混合写屏障是Gc的一种屏障机制，所以只是当程序执行GC的时候，才会触发这种机制。</p>
<h4 id="GC开始：扫描栈区，将可达对象全部标记为黑"><a href="#GC开始：扫描栈区，将可达对象全部标记为黑" class="headerlink" title="GC开始：扫描栈区，将可达对象全部标记为黑"></a>GC开始：扫描栈区，将可达对象全部标记为黑</h4><img data-src="/2021/02/03/technology/golang/gc_recycle/image_36.png" class="" title="image.png">

<img data-src="/2021/02/03/technology/golang/gc_recycle/image_37.png" class="" title="image.png">



<h4 id="场景一：对象被一个堆对象删除引用，成为栈对象的下游"><a href="#场景一：对象被一个堆对象删除引用，成为栈对象的下游" class="headerlink" title="场景一：对象被一个堆对象删除引用，成为栈对象的下游"></a>场景一：对象被一个堆对象删除引用，成为栈对象的下游</h4><figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="code"><pre><span class="line">//前提：堆对象4-&gt;对象7 = 对象7；//对象7 被 对象4引用</span><br><span class="line">栈对象1-&gt;对象7 = 堆对象7；//将堆对象7 挂在 栈对象1 下游</span><br><span class="line">堆对象4-&gt;对象7 = null；//对象4 删除引用 对象7</span><br></pre></td></tr></table></figure>


<img data-src="/2021/02/03/technology/golang/gc_recycle/image_38.png" class="" title="image.png">

<img data-src="/2021/02/03/technology/golang/gc_recycle/image_39.png" class="" title="image.png">





<h4 id="场景二：对象被一个栈对象删除引用，成为另一个栈对象的下游"><a href="#场景二：对象被一个栈对象删除引用，成为另一个栈对象的下游" class="headerlink" title="场景二：对象被一个栈对象删除引用，成为另一个栈对象的下游"></a>场景二：对象被一个栈对象删除引用，成为另一个栈对象的下游</h4><p>new 栈对象9；</p>
<p>对象9-&gt;对象3 &#x3D; 对象3；      &#x2F;&#x2F;将栈对象3 挂在 栈对象9 下游</p>
<p>对象2-&gt;对象3 &#x3D; null；      &#x2F;&#x2F;对象2 删除引用 对象3</p>
<img data-src="/2021/02/03/technology/golang/gc_recycle/image_40.png" class="" title="image.png">

<img data-src="/2021/02/03/technology/golang/gc_recycle/image_41.png" class="" title="image.png">
<img data-src="/2021/02/03/technology/golang/gc_recycle/image_42.png" class="" title="image.png">


<h4 id="场景三：对象被一个堆对象删除引用，成为另一个堆对象的下游"><a href="#场景三：对象被一个堆对象删除引用，成为另一个堆对象的下游" class="headerlink" title="场景三：对象被一个堆对象删除引用，成为另一个堆对象的下游"></a>场景三：对象被一个堆对象删除引用，成为另一个堆对象的下游</h4><figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="code"><pre><span class="line">堆对象10-&gt;对象7 = 堆对象7；//将堆对象7 挂在 堆对象10 下游</span><br><span class="line">堆对象4-&gt;对象7 = null；//对象4 删除引用 对象7</span><br></pre></td></tr></table></figure>


<img data-src="/2021/02/03/technology/golang/gc_recycle/image_43.png" class="" title="image.png">
<img data-src="/2021/02/03/technology/golang/gc_recycle/image_44.png" class="" title="image.png">
<img data-src="/2021/02/03/technology/golang/gc_recycle/image_45.png" class="" title="image.png">


<h4 id="场景四：对象从一个栈对象删除引用，成为另一个堆对象的下游"><a href="#场景四：对象从一个栈对象删除引用，成为另一个堆对象的下游" class="headerlink" title="场景四：对象从一个栈对象删除引用，成为另一个堆对象的下游"></a>场景四：对象从一个栈对象删除引用，成为另一个堆对象的下游</h4><p>栈对象1-&gt;对象2 &#x3D; null；      &#x2F;&#x2F;对象1 删除引用 对象2</p>
<p>堆对象4-&gt;对象2 &#x3D; 栈对象2；    &#x2F;&#x2F;对象4 添加 下游 栈对象2</p>
<p>堆对象4-&gt;对象7 &#x3D; null;       &#x2F;&#x2F;对象4 删除引用 对象7null；&#x2F;&#x2F;对象4 删除引用 对象7</p>
<img data-src="/2021/02/03/technology/golang/gc_recycle/image_46.png" class="" title="image.png">
<img data-src="/2021/02/03/technology/golang/gc_recycle/image_47.png" class="" title="image.png">
<img data-src="/2021/02/03/technology/golang/gc_recycle/image_48.png" class="" title="image.png">


<pre><code>    Golang中的混合写屏障满足`弱三色不变式`，结合了删除写屏障和插入写屏障的优点，只需要在开始时并发扫描各个goroutine的栈，使其变黑并一直保持，这个过程不需要STW，而标记结束后，因为栈在扫描后始终是黑色的，也无需再进行re-scan操作了，减少了STW的时间。
</code></pre>
<hr>
<p>七、总结</p>
<pre><code>    以上便是Golang的GC全部的标记-清除逻辑及场景演示全过程。
</code></pre>
<p>GoV1.3- 普通标记清除法，整体过程需要启动STW，效率极低。</p>
<p>GoV1.5- 三色标记法， 堆空间启动写屏障，栈空间不启动，全部扫描之后，需要重新扫描一次栈(需要STW)，效率普通</p>
<p>GoV1.8-三色标记法，混合写屏障机制， 栈空间不启动，堆空间启动。整个过程几乎不需要STW，效率较高。</p>
<p>参考文献:</p>
<p><a href="https://www.cnblogs.com/wangyiyang/p/12191591.html">https://www.cnblogs.com/wangyiyang/p/12191591.html</a><br><a href="https://www.jianshu.com/p/eb6b3aff9ca5">https://www.jianshu.com/p/eb6b3aff9ca5</a><br><a href="https://zhuanlan.zhihu.com/p/74853110">https://zhuanlan.zhihu.com/p/74853110</a></p>
]]></content>
      <categories>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>底层原理</tag>
        <tag>面试题</tag>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title>Gin源码解析</title>
    <url>/2021/02/03/technology/golang/gin_code_analyse/</url>
    <content><![CDATA[<p>gin框架使用的定制版本的http router。<br>http router的原理是大量使用公共前缀的树结构，</p>
<p>它基本是一个紧凑的trie terr或者只是一个RadixTree（基数树）</p>
<p>学到的优秀设计：</p>
<h2 id="gin中的Context-poll"><a href="#gin中的Context-poll" class="headerlink" title="gin中的Context poll"></a>gin中的Context poll</h2><p><strong>Poll用于存储哪些被分配了但是没有被使用,而未来有可能会被使用的值,以减少垃圾回收的压力.</strong></p>
<p>在Web应用中,后台处理用户的每条请求都会为当前请求创建一个上下文环境Context,用于存储请求信息及相关信息等.Context满足一个长生命周期的特点,且用户请求也属于并发环境,所以对于线程安全的Poll非常适合用来维护Context的临时对象池.</p>
<p>Gin在结构体Engine中定义了一个poll</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Engine <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="comment">// ... 省略了其他字段</span></span><br><span class="line">pool    sync.Pool</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>初始化engine时定义了poll的New函数:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">engine.pool.New = <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="keyword">interface</span>&#123;&#125; &#123;</span><br><span class="line">    <span class="keyword">return</span> engine.allocateContext()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// allocateContext</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(engine *Engine)</span></span> allocateContext() *Context &#123;</span><br><span class="line">    <span class="comment">// 构造新的上下文对象</span></span><br><span class="line">    <span class="keyword">return</span> &amp;Context&#123;engine: engine&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="ServerHttp"><a href="#ServerHttp" class="headerlink" title="ServerHttp"></a>ServerHttp</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 从 pool 中获取，并转化为 *Context</span></span><br><span class="line">c := engine.pool.Get().(*Context)</span><br><span class="line">c.writermem.reset(w)</span><br><span class="line">c.Request = req</span><br><span class="line">c.reset() <span class="comment">// reset</span></span><br><span class="line"></span><br><span class="line">engine.handleHTTPRequest(c)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 再扔回 pool 中</span></span><br><span class="line">engine.pool.Put(c)</span><br></pre></td></tr></table></figure>

<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ol>
<li>基于sync.poll使用对象池poll，从池中获取后对它转化Context，减少每次创建方法的CG和内存申请的频率,使用完之后,再扔回对象池中.</li>
</ol>
<p>避免对象的引用的干扰，在不影响项目的实际功能的情况下取出对象。</p>
<ol start="2">
<li>在设计for循环时的优秀设计：</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>,lens=<span class="built_in">len</span>(arr);i&lt;lens;i++&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<ol start="3">
<li>提倡最小执行代码原则：</li>
</ol>
<p>把应该立即返回的条件写在前面</p>
<p>4.在写完一个结构体后，在结构体下方新建一个接口类型的匿名变量</p>
<blockquote>
<p>目的：为了确保结构体实现了这个接口，把错误保留在编译阶段</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Engine <span class="keyword">struct</span>&#123;...&#125;</span><br><span class="line"><span class="keyword">var</span> _ Irouter [匿名变量的类型] = &amp;Engine&#123;&#125;</span><br></pre></td></tr></table></figure>


<p>5.为什么不用map而要用树遍历的方法？ map比较slice更占内存</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(trees methodTrees)</span></span> get(method <span class="type">string</span>) *node &#123;</span><br><span class="line">    <span class="keyword">for</span> _, tree := <span class="keyword">range</span> trees &#123;</span><br><span class="line">        <span class="keyword">if</span> tree.method == method &#123;</span><br><span class="line">            <span class="keyword">return</span> tree.root</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>6.当已知一个切片的容量时，我可以在初始化的时候一次性把切片的容量申请到位，避免动态申请slice。</p>
]]></content>
      <categories>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>面试题</tag>
        <tag>Golang</tag>
        <tag>Gin框架</tag>
      </tags>
  </entry>
  <entry>
    <title>Go语言底层基础知识</title>
    <url>/2021/02/01/technology/golang/go-basic/</url>
    <content><![CDATA[<h2 id="new和make的区别"><a href="#new和make的区别" class="headerlink" title="new和make的区别"></a>new和make的区别</h2><ol>
<li>new和make都是全部用来分配内存的关键字，new(T)创建一个没有任何数据的类型为T的实例，并返回该实例的指针；make(T, args)只能创建 slice、map和channel，并且返回一个有初始值args（非零）的T类型的实例，非指针。</li>
<li>对于返回值，new用于类型的内存分配，并且内存置零，返回的是一个指向类型的指针；make是对他们的初始化，（非0值）返回的是一个类型引用对象 ，对于引用类型的变量，我们不光要声明它，还要为它分配内容空间 。</li>
<li>对于入参，new只有一个Type参数，Type可以是任何类型的数据；make传入Type参数（map、slice、chan）中的一种，还有一个size  。（map：根据slice大小分配资源，以足够存储size个元素，如果省略size，会默认分配一个小的起始size ；slice ：第一个是长度，第二个是cap（容量）；对于chan，size表示缓冲区容量；如果省略则表示channel为无缓冲的channel）<br>总结：</li>
</ol>
<ul>
<li><p>new() 是分配内存给一个零值的指针，返回的是这个类型的指针，还可以返回自己定义的结构体，置零之后的。</p>
</li>
<li><p>make（）是开辟一块内存，并且初始化，返回这个经过初始化的对象，只能初始化slice、map、chan，返回的是这个类型的引用，它可以设置初始化的长度，如果是slice，则可以添加一个参数，容量，容量的大小要小于slice的大小。</p>
</li>
</ul>
<h2 id="array和slice的区别"><a href="#array和slice的区别" class="headerlink" title="array和slice的区别"></a>array和slice的区别</h2><ol>
<li>array在定义的时候必须传入数组的长度，并且是一个常量，并且不可改变，数组的赋值都是值传递，所以一般情况会就比较耗费内存。</li>
<li>slice是通过指针引用底层数组，是对数组一个连续片段的引用，这个片段可以是全部的数组，也可以是其中的一个片段，slice自身是一个结构体，切片的长度可以改变。切片在进行append时，未超过切片的容量，进行浅拷贝（传递引用），超过容量，进行扩容的时候才会执行深拷贝（生成一个新的内存空间，不共享。）</li>
</ol>
<h2 id="通道是什么"><a href="#通道是什么" class="headerlink" title="通道是什么"></a>通道是什么</h2><p>通道是go中的一个通信方式，提供goroutine进行通信，可以为并发的两个实体之间提供通信通道，而不是共享内存的方式。<br>通道分为无缓冲通道和有缓冲通道:</p>
<ul>
<li>对于无缓冲通道，接收方从通道接收东西的时候，如果通道中没有消息，则接收方进入阻塞，直到通道中有消息。对于发送方，直到接收方收到消息之后，才能继续给通道发送消息。</li>
<li>对于有缓冲通道，指的是在通道中可以缓冲指定数量的数据，直到数据填满，发送方阻塞，直到接收方接收，采用了环形数组的方式进行存储。</li>
</ul>
<p>通道在Go中的代码定义:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> hchan <span class="keyword">struct</span> &#123;</span><br><span class="line">  qcount   <span class="type">uint</span>           <span class="comment">// 当前队列中剩余元素个数</span></span><br><span class="line">  dataqsiz <span class="type">uint</span>           <span class="comment">// 环形队列长度，即可以存放的元素个数</span></span><br><span class="line">  buf      unsafe.Pointer <span class="comment">// 环形队列指针</span></span><br><span class="line">  elemsize <span class="type">uint16</span>         <span class="comment">// 每个元素的大小</span></span><br><span class="line">  closed   <span class="type">uint32</span>            <span class="comment">// 标识关闭状态</span></span><br><span class="line">  elemtype *_type         <span class="comment">// 元素类型</span></span><br><span class="line">  sendx    <span class="type">uint</span>           <span class="comment">// 队列下标，指示元素写入时存放到队列中的位置</span></span><br><span class="line">  recvx    <span class="type">uint</span>           <span class="comment">// 队列下标，指示元素从队列的该位置读出</span></span><br><span class="line">  recvq    waitq          <span class="comment">// 等待读消息的goroutine队列</span></span><br><span class="line">  sendq    waitq          <span class="comment">// 等待写消息的goroutine队列</span></span><br><span class="line">  lock mutex              <span class="comment">// 互斥锁，chan不允许并发读写</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通道内部维护一个环形队列，队列的长度是在用户创建的时候指定的。</p>
<ul>
<li>sendx代表写入时的位置</li>
<li>recvx代表读数据时的位置</li>
<li>chan内部还维护了两个等待队列</li>
<li>一个等待读消息的groutine队列</li>
<li>一个等待写消息的groutine队列</li>
<li>一般情况下，recvq和sendq至少有一个为空；一个例外(同一个groutine使用select向channel一边写数据，一边读数据)</li>
</ul>
<p>注意：</p>
<ul>
<li> channel关闭之后任然可以读，如果channel中仍然有未读取的数据，则仍然可以读取到，没有数据会返回0。</li>
<li>关闭一个未初始化的channel会产生panic。</li>
<li>重复关闭同一个channel会产生painc。</li>
<li>从已经关闭的channel中读取消息不会产生painc，且能读出channel中还未被读取的消息，如果消息已经读出，则返回0值；(有缓冲无缓冲都是)。</li>
<li>关闭的channel中读取消息永远不会阻塞，并且会返回一个为false的ok-idiom。</li>
</ul>
<h2 id="map的底层实现"><a href="#map的底层实现" class="headerlink" title="map的底层实现"></a>map的底层实现</h2><p>golang的map是hasmap，使用数组+链表的形式 实现的，使用拉链法消除hash冲突。<br>map类型的变量默认初始值为nil，需要使用make()函数来分配内存。语法为：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">map</span>[keyType]ValueType</span><br><span class="line"><span class="built_in">make</span>(<span class="keyword">map</span>[KeyType]ValueType, [<span class="built_in">cap</span>])</span><br></pre></td></tr></table></figure>
<p>golang的map有两种重要的结构：hmap，bmap，主要就是hmap中包含bmap的一个指针。<br>存储时key不能重复，如果重复则覆盖value，通过key进行hash运算（可以简单的理解为把key转化为一个整数）然后对数组的长度取余,得到key存储在数组的哪个下标位置，咱以后将key和value组装成一个结构体，放入下标的位置。</p>
<h3 id="1-关于hash冲突"><a href="#1-关于hash冲突" class="headerlink" title="1. 关于hash冲突"></a>1. 关于hash冲突</h3><p>数组一个下标只能存储一个元素，也就是说一个数组下标只能存储一对key，value，hashkey（小明）&#x3D;4占用了下标0的位置，假设我们遇到了另一个key，它的hashkey(xiaowang)也是4，这就是hash冲突（不同的key经过hash之后得到的值一样）那么key&#x3D;xiaowang怎么存储？</p>
<ul>
<li><p>开放定址法：当我们存储一个key，value时，发现下标已经被占了，那么我们再这个数组中重新找一个没被占用的存储这个冲突的key，那么没有被占用的有很多，找哪个呢？常见的有线性探测法，线性补偿探测法、随机探测法。</p>
</li>
<li><p>线性探测：按照顺序来，从冲突的下标开始往后探测，到达数组末尾时，从数组开始探测，直到找到一个空位置存储这个key，当数组找不到的情况下会扩容（当数组快满的时候就会扩容了）；<br>如下图：首先存储key&#x3D;xiaoming在下标0处，当存储key&#x3D;xiaowang时，hash冲突了，按照线性探测，存储在下标1处，（红色的线是冲突或者下标已经被占用了） 再者key&#x3D;xiaozhao存储在下标4处，当存储key&#x3D;xiaoliu是，hash冲突了，按照线性探测，从头开始，存储在下标2处 （黄色的是冲突或者下标已经被占用了）</p>
<img data-src="/2021/02/01/technology/golang/go-basic/image_1.png" class="" title="图1">
</li>
<li><p>拉链法：拉链简单理解为链表，当key的hash冲突的时候，我们在冲突位置的元素上形成一个链表，通过指针相互连接，当查找时，发现key冲突，顺着链表一直往下找，直到链表的尾结点，找不到则返回空；<br>如下图描述：</p>
<img data-src="/2021/02/01/technology/golang/go-basic/image_2.png" class="" title="图2">
<p>开放定址和拉链的优缺点：</p>
<ul>
<li>拉链比线性探测处理简单</li>
<li>线性探测查找会比拉链更消耗时间</li>
<li>线性探测会比拉链更容易导致扩容，而拉链不会</li>
<li>拉链存储了指针，所以空间上会比线性探测占用多一点</li>
<li>拉链是动态申请存储空间的，所以更适合链长不确定的。</li>
</ul>
</li>
</ul>
<h3 id="2-HashMap怎么扩容"><a href="#2-HashMap怎么扩容" class="headerlink" title="2. HashMap怎么扩容"></a>2. HashMap怎么扩容</h3><p>首先需要知道哈希表的存储过程，当有新的数据进行存储的时候，需要根据key计算出它的哈希值h，假设哈希表的 容量是n，那么键值对就会放在h%n个位置中，如果该位置已经有了键值对，会分局开放寻址法或者拉链法解决冲突；<br>哈希表的扩容会创建原来的两倍容量，因此即使key的哈希值不变，求余结果也会改变，因此所有的键值对存放的位置都会发生改变，此时需要重新哈希。扩容的时候需要分配一个新的数组，新数组是老数组的2倍长，然后遍历旧的哈希，重新分配到新的结果中。</p>
<h2 id="Go中的interface关键字"><a href="#Go中的interface关键字" class="headerlink" title="Go中的interface关键字"></a>Go中的interface关键字</h2><ul>
<li>interface是方法声明的集合</li>
<li>任何类型的对象实现在interface接口中声明的全部方法，则表明这个类型实现了接口</li>
<li>interface可以作为一种数据类型，实现了该接口的任何对象，都可以给对应的接口类型变量赋值</li>
<li>interface可以被任意对象实现，一个类型&#x2F;对象也可以实现多个(interface)接口</li>
<li>继承和多态的特点，在golang的语法中对多态的特点体现从语法上不是很明显</li>
<li>父类是子类的私有内部类(组合)</li>
<li>发生多态的几个要素：（满足这三个条件，就可以产生多态的效果，父类可以调用子类的具体方法）</li>
<li>有interface接口，并且有接口定义的方法（可以看做一个类型，父类）</li>
<li>有子类去重写interface的接口</li>
<li>有父类指针指向子类的具体对象</li>
</ul>
<h2 id="GMP并发模型："><a href="#GMP并发模型：" class="headerlink" title="GMP并发模型："></a>GMP并发模型：</h2><ul>
<li>G代表goroutine,占用内存更小（几kb），能在有限的内存空间支持更多的并发,调度灵活度更高（runtime调度）</li>
<li>M代表操作系统线程，负责执行 Goroutine</li>
<li>P代表逻辑处理器，负责调度 Goroutine</li>
<li>包含了运行goroutine的资源processor处理</li>
<li>可以运行的G队列<br>在Go中线程是运行goroutine的实体，调度器（runtime）的功能是把可运行的    goroutine分配到工作线程上。<br>Goroutine调度器和OS调度器是通过M结合起来的，每个M都代表了1个内核线程，OS调度器负责把内核线程分配到CPU执行。<img data-src="/2021/02/01/technology/golang/go-basic/image_3.png" class="" title="图3"></li>
</ul>
<h3 id="1-GMP-模型的优势"><a href="#1-GMP-模型的优势" class="headerlink" title="1. GMP 模型的优势"></a>1. GMP 模型的优势</h3><ul>
<li><strong>高效利用 CPU</strong>：通过多 P 和多 M 的绑定，充分利用多核 CPU 的计算能力。</li>
<li><strong>低延迟</strong>：Goroutine 的调度由 Go 运行时负责，避免了操作系统线程切换的开销。</li>
<li><strong>高并发</strong>：Goroutine 的轻量级特性使得 Go 程序可以轻松创建成千上万的并发任务。<br>以下是一个简单的 Go 程序，展示了 Goroutine 的创建和调度：<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">worker</span><span class="params">(id <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;Worker %d: %d\n&quot;</span>, id, i)</span><br><span class="line">		time.Sleep(time.Second)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">		<span class="keyword">go</span> worker(i)</span><br><span class="line">	&#125;</span><br><span class="line">	time.Sleep(<span class="number">5</span> * time.Second) <span class="comment">// 等待所有 Goroutine 执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="GO的GC垃圾回收机制"><a href="#GO的GC垃圾回收机制" class="headerlink" title="GO的GC垃圾回收机制"></a>GO的GC垃圾回收机制</h2><p>三色标记清楚法：</p>
<ul>
<li>初始化所有的对象为白色；</li>
<li>从root根出发扫描所有的根对象，将他们引用的对象标记为灰色；</li>
<li>这里的根对象是程序运行到当前时刻的栈和全局数据区域；</li>
<li>分析灰色对象是否引用了其他的对象，如果没有引用其他的对象，则将该灰色标记为黑色，如果有引用，则将它变为黑色的同时将引用对象标记为灰色；</li>
<li>重复步骤三，直到灰色对象队列为空，此时白色的对象是垃圾，进行回收。</li>
</ul>
<h2 id="Context关键字"><a href="#Context关键字" class="headerlink" title="Context关键字"></a>Context关键字</h2><p>Go1.7加入了一个新的标准库context，它定义了Context类型，专门用来简化 对于处理单个请求的多个 goroutine 之间与请求域的数据、取消信号、截止时间等相关操作，这些操作可能涉及多个 API 调用。<br>对服务器传入的请求应该创建上下文，而对服务器的传出调用应该接受上下文。它们之间的函数调用链必须传递上下文，或者可以使用WithCancel(获得数据通知关闭)、(获得数据定时关闭)WithDeadline、(超时关闭)WithTimeout或(传递KV)WithValue创建的派生上下文。当一个上下文被取消时，它派生的所有上下文也被取消。<br>context.Background()返回的是全局的上下文根（我在文章中多次提到），context.TODO()返回的是空的上下文（表明应用的不确定性）</p>
<h2 id="GO内存分配与逃逸分析"><a href="#GO内存分配与逃逸分析" class="headerlink" title="GO内存分配与逃逸分析"></a>GO内存分配与逃逸分析</h2><ul>
<li>逃逸分析的好处是为了减少gc的压力,不逃逸的对象分配到栈上,当函数返回释放即可,不需要gc标记删除</li>
<li>逃逸分析完成之后可以确定哪些变量可以分配在栈上,栈的分配比堆快,性能好(逃逸变量分配到堆,不逃逸变量分配到栈)</li>
<li>同步消除,如果你定义的对象的方法上有同步锁,在运行时,却只有一个线程在访问,此时逃逸分析后的机器码会去掉同步锁运行<br>总结:</li>
<li>栈上分配内存比在堆中分配内存有更高的效率</li>
<li>栈上分配的内存不需要GC处理</li>
<li>堆上分配的内存使用完毕会交给GC处理</li>
<li>逃逸分析的目的是决定分配地址是栈还是堆</li>
<li>逃逸分析在编译阶段完成</li>
</ul>
<h3 id="1-函数传递指针真的比传值效率高吗"><a href="#1-函数传递指针真的比传值效率高吗" class="headerlink" title="1. 函数传递指针真的比传值效率高吗?"></a>1. 函数传递指针真的比传值效率高吗?</h3><ul>
<li>传递指针可以减少底层值拷贝,可以提高效率,但是如果拷贝数据量小,由于指针传递会产生逃逸;</li>
<li>可能会使用堆,也可能会增加GC的负担,所以传递指针不一定是高效的;<br><strong>栈</strong> :函数内存申请临时变量,并不会作为返回值返回,它就会被编译器申请到栈中<br>在函数中申请一个新对象,如果在栈中,函数执行结束会自动将内存回收;<br><strong>申请到栈内存好处</strong>:  函数返回直接释放,不会引起垃圾回收,对性能没有影响.<br><strong>堆</strong>:    函数申请内存之后,作为返回值返回了,编译器会默认变量之后还会被使用,<br>当函数返回之后并不会将内存归还,那么他就会被申请到堆中.<br>如果分配到堆中,则函数执行结束之后交给GC处理;<br><strong>申请到堆的内存</strong>  :  会引起垃圾回收,如果这个过程(特指垃圾回收不断被触发)过高频次就会导致gc压力过大,性能变低。<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">F</span><span class="params">()</span></span> []<span class="type">int</span>&#123;</span><br><span class="line">    a := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>, <span class="number">20</span>)</span><br><span class="line">    <span class="keyword">return</span> a</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">F</span><span class="params">()</span></span> &#123;</span><br><span class="line">    a := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>, <span class="number">20</span>)     <span class="comment">// 栈 空间小</span></span><br><span class="line">    b := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>, <span class="number">20000</span>) <span class="comment">// 堆 空间过大</span></span><br><span class="line"></span><br><span class="line">    l := <span class="number">20</span></span><br><span class="line">    c := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>, l) <span class="comment">// 堆 动态分配不定空间,也会在堆</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="2-什么是逃逸分析，有哪些场景"><a href="#2-什么是逃逸分析，有哪些场景" class="headerlink" title="2. 什么是逃逸分析，有哪些场景"></a>2. 什么是逃逸分析，有哪些场景</h3><p>逃逸分析指的是由编译器决定内存分配的位置,不需要开发者指定。</p>
<h3 id="1-逃逸场景-什么时候才会被分配到堆中"><a href="#1-逃逸场景-什么时候才会被分配到堆中" class="headerlink" title="1.逃逸场景(什么时候才会被分配到堆中)"></a>1.逃逸场景(什么时候才会被分配到堆中)</h3><ul>
<li>指针逃逸 : go可以返回局部变量指针,典型的变量逃逸案例</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="type">string</span></span><br><span class="line">    Age <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">StudentRegister</span><span class="params">(name <span class="type">string</span>,age <span class="type">int</span>)</span></span>*Student  &#123;</span><br><span class="line">    s :=<span class="built_in">new</span>(Student) <span class="comment">//局部变量s逃逸到堆</span></span><br><span class="line">    s.Name = name</span><br><span class="line">    s.Age = age</span><br><span class="line">    <span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    StudentRegister(<span class="string">&quot;Jin&quot;</span>,<span class="number">19</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>虽然在函数StudentRegister<strong>中内存s 为局部变量</strong>,它的值通过函数返回值返回,s本身为一个指针</p>
<p>它指向发内存地址不会是对,而是栈,这是典型的逃逸案例</p>
<p>终端执行: go build -gcflags &#x3D; - m</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">C:\Users\Administrator\<span class="keyword">go</span>\src\内存逃逸分析&gt;<span class="keyword">go</span> build -gcflags=-m</span><br><span class="line"># 内存逃逸分析</span><br><span class="line">.\<span class="number">1.</span>指针逃逸.<span class="keyword">go</span>:<span class="number">8</span>:<span class="number">6</span>: can inline StudentRegister</span><br><span class="line">.\<span class="number">1.</span>指针逃逸.<span class="keyword">go</span>:<span class="number">15</span>:<span class="number">6</span>: can inline main</span><br><span class="line">.\<span class="number">1.</span>指针逃逸.<span class="keyword">go</span>:<span class="number">16</span>:<span class="number">17</span>: inlining call to StudentRegister</span><br><span class="line">.\<span class="number">1.</span>指针逃逸.<span class="keyword">go</span>:<span class="number">8</span>:<span class="number">22</span>: leaking param: name</span><br><span class="line">.\<span class="number">1.</span>指针逃逸.<span class="keyword">go</span>:<span class="number">9</span>:<span class="number">9</span>: <span class="built_in">new</span>(Student) escapes to heap  <span class="comment">//显示指针逃逸</span></span><br><span class="line">.\<span class="number">1.</span>指针逃逸.<span class="keyword">go</span>:<span class="number">16</span>:<span class="number">17</span>: <span class="built_in">new</span>(Student) does not escape</span><br></pre></td></tr></table></figure>

<ul>
<li>栈空间不足逃逸(空间开辟过大)</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Slice</span><span class="params">()</span></span> &#123;</span><br><span class="line">    s := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">10000</span>, <span class="number">10000</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> index, _ := <span class="keyword">range</span> s &#123;</span><br><span class="line">        s[index] = index</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    Slice()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//当切片长度扩大到100000时会逃逸</span></span><br><span class="line"><span class="comment">//实际上当栈空间不足以存放当前对象或者无法判断当前切片长度时会将对象分配到堆中</span></span><br><span class="line"></span><br><span class="line">C:\Users\Administrator\<span class="keyword">go</span>\src\内存逃逸分析&gt;<span class="keyword">go</span> build -gcflags=-m</span><br><span class="line"># 内存逃逸分析</span><br><span class="line">.\<span class="number">1.</span>指针逃逸.<span class="keyword">go</span>:<span class="number">11</span>:<span class="number">6</span>: can inline main</span><br><span class="line">.\<span class="number">1.</span>指针逃逸.<span class="keyword">go</span>:<span class="number">4</span>:<span class="number">11</span>: <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">10000</span>, <span class="number">10000</span>) escapes to heap</span><br></pre></td></tr></table></figure>

<ul>
<li>动态类型逃逸(不确定长度大小)</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    s := <span class="string">&quot;Escape&quot;</span></span><br><span class="line">    fmt.Println(s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">C:\Users\Administrator\<span class="keyword">go</span>\src\内存逃逸分析&gt;<span class="keyword">go</span> build -gcflags=-m</span><br><span class="line"># 内存逃逸分析</span><br><span class="line">.\<span class="number">1.</span>指针逃逸.<span class="keyword">go</span>:<span class="number">7</span>:<span class="number">13</span>: inlining call to fmt.Println</span><br><span class="line">.\<span class="number">1.</span>指针逃逸.<span class="keyword">go</span>:<span class="number">7</span>:<span class="number">13</span>: s escapes to heap</span><br><span class="line">.\<span class="number">1.</span>指针逃逸.<span class="keyword">go</span>:<span class="number">7</span>:<span class="number">13</span>: []<span class="keyword">interface</span> &#123;&#125; literal does not escape</span><br><span class="line">&lt;autogenerated&gt;:<span class="number">1</span>: .this does not escape</span><br><span class="line">&lt;autogenerated&gt;:<span class="number">1</span>: .this does not escape</span><br></pre></td></tr></table></figure>

<ul>
<li>闭包引用对象逃逸</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Fibonacci</span><span class="params">()</span></span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    a, b := <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">int</span> &#123;</span><br><span class="line">        a, b = b, a+b</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    f := Fibonacci()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;Fibonacci: %d\n&quot;</span>, f())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">C:\Users\Administrator\<span class="keyword">go</span>\src\内存逃逸分析&gt;<span class="keyword">go</span> build -gcflags=-m</span><br><span class="line"># 内存逃逸分析</span><br><span class="line">.\<span class="number">1.</span>指针逃逸.<span class="keyword">go</span>:<span class="number">7</span>:<span class="number">9</span>: can inline Fibonacci.func1</span><br><span class="line">.\<span class="number">1.</span>指针逃逸.<span class="keyword">go</span>:<span class="number">17</span>:<span class="number">13</span>: inlining call to fmt.Printf</span><br><span class="line">.\<span class="number">1.</span>指针逃逸.<span class="keyword">go</span>:<span class="number">6</span>:<span class="number">2</span>: moved to heap: a</span><br><span class="line">.\<span class="number">1.</span>指针逃逸.<span class="keyword">go</span>:<span class="number">6</span>:<span class="number">5</span>: moved to heap: b</span><br><span class="line">.\<span class="number">1.</span>指针逃逸.<span class="keyword">go</span>:<span class="number">7</span>:<span class="number">9</span>: <span class="function"><span class="keyword">func</span> <span class="title">literal</span> <span class="title">escapes</span> <span class="title">to</span> <span class="title">heap</span></span></span><br><span class="line">.\<span class="number">1.</span>指针逃逸.<span class="keyword">go</span>:<span class="number">17</span>:<span class="number">34</span>: f() escapes to heap</span><br><span class="line">.\<span class="number">1.</span>指针逃逸.<span class="keyword">go</span>:<span class="number">17</span>:<span class="number">13</span>: []<span class="keyword">interface</span> &#123;&#125; literal does not escape</span><br><span class="line">&lt;autogenerated&gt;:<span class="number">1</span>: .this does not escape</span><br><span class="line">&lt;autogenerated&gt;:<span class="number">1</span>: .this does not escape</span><br></pre></td></tr></table></figure>

<h2 id="runtime机制是什么"><a href="#runtime机制是什么" class="headerlink" title="runtime机制是什么"></a>runtime机制是什么</h2><p>go 语言的可执行文件已经包含了 golang 的 runtime，它为用户的 go 程序提供协程调度、内存分配、垃圾回收等功能.此外还会与系统内核进行交互，从而真正的利用好 CPU 等资源。</p>
<ul>
<li><strong>Gosched</strong>：让当前线程让出 <code>cpu</code> 以让其它线程运行,它不会挂起当前线程，因此当前线程未来会继续执行</li>
<li><strong>NumCPU</strong>：返回当前系统的 <code>CPU</code> 核数量</li>
<li><strong>GOMAXPROCS</strong>：设置最大的可同时使用的 <code>CPU</code> 核数</li>
<li><strong>Goexit</strong>：退出当前 <code>goroutine</code>(但是<code>defer</code>语句会照常执行)</li>
<li><strong>NumGoroutine</strong>：返回正在执行和排队的任务总数</li>
<li><strong>GOOS</strong>：目标操作系统</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">fmt.Println(<span class="string">&quot;cpus:&quot;</span>, runtime.NumCPU())</span><br><span class="line">fmt.Println(<span class="string">&quot;goroot:&quot;</span>, runtime.GOROOT())</span><br><span class="line">fmt.Println(<span class="string">&quot;archive:&quot;</span>, runtime.GOOS)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>底层原理</tag>
        <tag>面试题</tag>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title>Go语言反射reflect</title>
    <url>/2021/02/03/technology/golang/go_reflect/</url>
    <content><![CDATA[<p><strong>反射指的是在程序运行期间对程序本身进行访问和修改的能力.</strong></p>
<p>不支持反射的语言:</p>
<blockquote>
<p>程序在编译时,变量转换为内存地址,变量名不会被编译器写入到可执行部分.在运行程序时,程序无法获取自身的信息.</p>
</blockquote>
<p>支持反射的语言:</p>
<blockquote>
<p>可以在程序编译期间将变量的反射信息,比如字段名称 , 类型信息 , 结构体信息等整合到可执行文件中,并给程序提供接口访问反射信息,这样就可以在程序运行期间获取类型的反射信息,并且有能力修改它们.</p>
</blockquote>
<p><strong>Go程序在运行期间使用reflect包访问程序的反射信息</strong></p>
<p>reflct包实现了运行时反射,允许程序操作任意类型的对象.典型的用法是静态类型interface{}保存一个值,通过TypeOf获取其动态类型信息,该函数返回一个Type类型值,调用ValueOf函数返回一个Value类型值,该值代表运行时的数据.Zero接受一个一个Type类型参数,并返回一个代表该类型零值的Value类型值.</p>
<p>Go程序的反射系统无法获取到一个可执行文件空间中或者是一个包中的所有类型信息,需要配合使用标准库中对应的词法,语法解析器和抽象语法树(AST)对源码进行扫描后获得这些信息.</p>
<h2 id="通过反射获取类型信息"><a href="#通过反射获取类型信息" class="headerlink" title="通过反射获取类型信息"></a>通过反射获取类型信息</h2><p>通过反射获取类型信息:(reflect.TypeOf()和reflect.Type)</p>
<p>使用reflect.TypeOf()函数可以获得任意值的类型对象eflect.Type,程序通过类型对象可以访问任意值的类型信息.</p>
<p><strong>例子:</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;reflect&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="type">string</span></span><br><span class="line">    Age  <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> stu Student</span><br><span class="line">    typeOfStu := reflect.TypeOf(stu)</span><br><span class="line">    fmt.Println(typeOfStu.Name(), typeOfStu.Kind())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>代码输出:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">Student <span class="keyword">struct</span></span><br></pre></td></tr></table></figure>


<p>理解反射的类型( Type )和种类( Kind )</p>
<p>在使用反射的时候,需要首先理解类型（Type）和种类（Kind）的区别。编程中，使用最多的是类型，但在反射中，当需要区分一个大品种的类型时，就会用到种类（Kind）。例如，需要统一判断类型中的指针时，使用种类（Kind）信息就较为方便。</p>
<h2 id="反射种类-kind-的定义"><a href="#反射种类-kind-的定义" class="headerlink" title="反射种类(kind)的定义"></a>反射种类(kind)的定义</h2><p>Go 程序中的类型（Type）指的是系统原生数据类型，如 int、string、bool、float32 等类型，以及使用 type 关键字定义的类型，这些类型的名称就是其类型本身的名称。例如使用 type A struct{} 定义结构体时，A 就是 struct{} 的类型。</p>
<p>种类（Kind）指的是对象归属的品种，在 reflect 包中有如下定义：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Kind <span class="type">uint</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    Invalid Kind = <span class="literal">iota</span>  <span class="comment">// 非法类型</span></span><br><span class="line">    Bool                                 <span class="comment">// 布尔型</span></span><br><span class="line">    Int                                <span class="comment">// 有符号整型</span></span><br><span class="line">    Int8                                 <span class="comment">// 有符号8位整型</span></span><br><span class="line">    Int16                                <span class="comment">// 有符号16位整型</span></span><br><span class="line">    Int32                                <span class="comment">// 有符号32位整型</span></span><br><span class="line">    Int64                                <span class="comment">// 有符号64位整型</span></span><br><span class="line">    Uint                                 <span class="comment">// 无符号整型</span></span><br><span class="line">    Uint8                                <span class="comment">// 无符号8位整型</span></span><br><span class="line">    Uint16                           <span class="comment">// 无符号16位整型</span></span><br><span class="line">    Uint32                           <span class="comment">// 无符号32位整型</span></span><br><span class="line">    Uint64                           <span class="comment">// 无符号64位整型</span></span><br><span class="line">    Uintptr                          <span class="comment">// 指针</span></span><br><span class="line">    Float32                          <span class="comment">// 单精度浮点数</span></span><br><span class="line">    Float64                          <span class="comment">// 双精度浮点数</span></span><br><span class="line">    Complex64                        <span class="comment">// 32位复数类型</span></span><br><span class="line">    Complex128                   <span class="comment">// 64位复数类型</span></span><br><span class="line">    Array                                <span class="comment">// 数组</span></span><br><span class="line">    Chan                                 <span class="comment">// 通道</span></span><br><span class="line">    Func                                 <span class="comment">// 函数</span></span><br><span class="line">    Interface                        <span class="comment">// 接口</span></span><br><span class="line">    Map                                <span class="comment">// 映射</span></span><br><span class="line">    Ptr                                <span class="comment">// 指针</span></span><br><span class="line">    Slice                                <span class="comment">// 切片</span></span><br><span class="line">    String                           <span class="comment">// 字符串</span></span><br><span class="line">    Struct                           <span class="comment">// 结构体</span></span><br><span class="line">    UnsafePointer                <span class="comment">// 底层指针</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>


<p>Map、Slice、Chan 属于引用类型，使用起来类似于指针，但是在种类常量定义中仍然属于独立的种类，不属于 Ptr。</p>
<p>type A struct{} 定义的结构体属于 Struct 种类，*A 属于 Ptr。</p>
<h2 id="从类型对象中获取类型名称和种类的例子"><a href="#从类型对象中获取类型名称和种类的例子" class="headerlink" title="从类型对象中获取类型名称和种类的例子:"></a>从类型对象中获取类型名称和种类的例子:</h2><p>Go 语言中的类型名称对应的反射获取方法是 reflect.Type 中的 Name() 方法，返回表示类型名称的字符串。</p>
<p>类型归属的种类（Kind）使用的是 reflect.Type 中的 Kind() 方法，返回 reflect.Kind 类型的常量。</p>
<p>例子:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;reflect&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="comment">//定义一个Enum类型</span></span><br><span class="line"><span class="keyword">type</span> Enum <span class="type">int</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    Zero Enum = <span class="number">0</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="type">string</span></span><br><span class="line">    Age  <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">//定义一个Student类型的变量</span></span><br><span class="line">    <span class="keyword">var</span> stu Student</span><br><span class="line">    <span class="comment">//获取结构体实例的反射类型对象</span></span><br><span class="line">    typeOfStu := reflect.TypeOf(stu)</span><br><span class="line">    <span class="comment">//显示反射类型对象的名称和种类</span></span><br><span class="line">    fmt.Println(typeOfStu.Name(), typeOfStu.Kind())</span><br><span class="line">    <span class="comment">//获取Zero常量的反射类型对象</span></span><br><span class="line">    typeOfZero := reflect.TypeOf(Zero)</span><br><span class="line">    <span class="comment">//显示反射类型对象的名称和种类</span></span><br><span class="line">    fmt.Println(typeOfZero.Name(), typeOfZero.Kind())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//代码输出如下:</span></span><br><span class="line"></span><br><span class="line">Student <span class="keyword">struct</span></span><br><span class="line">Enum <span class="type">int</span></span><br></pre></td></tr></table></figure>


<h3 id="reflect-Elem-通过反射获取指针指向的元素类型"><a href="#reflect-Elem-通过反射获取指针指向的元素类型" class="headerlink" title="reflect.Elem() - 通过反射获取指针指向的元素类型"></a>reflect.Elem() - 通过反射获取指针指向的元素类型</h3><p>通过反射获取指针指向的元素类型：reflect.Elem()</p>
<p>Go 程序中对指针获取反射对象时，可以通过 reflect.Elem() 方法获取这个指针指向的元素类型。这个获取过程被称为取元素，等效于对指针类型变量做了一个<code>*</code>操作，代码如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;reflect&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line"></span><br><span class="line">    Name <span class="type">string</span></span><br><span class="line">    Age  <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">//定义一个Student类型的指针变量</span></span><br><span class="line">    <span class="keyword">var</span> stu = &amp;Student&#123;Name:<span class="string">&quot;kitty&quot;</span>, Age: <span class="number">20</span>&#125;</span><br><span class="line">    <span class="comment">//获取结构体实例的反射类型对象</span></span><br><span class="line">    typeOfStu := reflect.TypeOf(stu)</span><br><span class="line">    <span class="comment">//显示反射类型对象的名称和种类</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;name: &#x27;%v&#x27;, kind: &#x27;%v&#x27;\n&quot;</span>, typeOfStu.Name(), typeOfStu.Kind())</span><br><span class="line">    <span class="comment">//取类型的元素</span></span><br><span class="line">    typeOfStu = typeOfStu.Elem()</span><br><span class="line">    <span class="comment">//显示反射类型对象的名称和种类</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;element name: &#x27;%v&#x27;, element kind: &#x27;%v&#x27;\n&quot;</span>, typeOfStu.Name(), typeOfStu.Kind())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//代码输出如下:</span></span><br><span class="line"><span class="comment">//name: &#x27;&#x27;, kind: &#x27;ptr&#x27;</span></span><br><span class="line"><span class="comment">//element name: &#x27;Student&#x27;, element kind: &#x27;struct&#x27;</span></span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>面试题</tag>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title>Go-GPM解析</title>
    <url>/2021/02/03/technology/golang/gpm_explain/</url>
    <content><![CDATA[<h1 id="GPM轻量理解"><a href="#GPM轻量理解" class="headerlink" title="GPM轻量理解"></a>GPM轻量理解</h1><p>GPM是Go语言运行时（runtime）层面的实现，是go语言自己实现的一套调度系统。区别于操作系统调度OS线程。</p>
<ul>
<li><p>1.G很好理解，就是个goroutine，里面除了存放本goroutine信息外 还有与所在P的绑定等信息。</p>
</li>
<li><p>2.P管理着一组goroutine队列，P里面会存储当前goroutine运行的上下文环境（函数指针，堆栈地址及地址边界），P会对自己管理的goroutine队列做一些调度（比如把占用CPU时间较长的goroutine暂停、运行后续的goroutine等等）当自己的队列消费完了就去全局队列里取，如果全局队列里也消费完了会去其他P的队列里抢任务。</p>
</li>
<li><p>3.M（machine）是Go运行时（runtime）对操作系统内核线程的虚拟， M与内核线程一般是一一映射的关系， 一个groutine最终是要放到M上执行的；</p>
</li>
</ul>
<p>P与M一般也是一一对应的。他们关系是： P管理着一组G挂载在M上运行。当一个G长久阻塞在一个M上时，runtime会新建一个M，阻塞G所在的P会把其他的G 挂载在新建的M上。当旧的G阻塞完成或者认为其已经死掉时 回收旧的M。</p>
<p>P的个数是通过runtime.GOMAXPROCS设定（最大256），Go1.5版本之后默认为物理线程数。 在并发量大的时候会增加一些P和M，但不会太多，切换太频繁的话得不偿失。</p>
<p>三者关系：</p>
<ul>
<li><p>每一个运行的M都必须绑定一个P,线程M创建后会去检查并执行G(goroutine)对象</p>
</li>
<li><p>每一个P保存着一个协程G的队列</p>
</li>
<li><p>除了每个P自身保存的G的队列外,调度器还拥有一个全局的G队列</p>
</li>
<li><p>M从队列中提取G,并执行</p>
</li>
<li><p>P的个数就是<code>GOMAXPROCS</code>(最大256),启动时固定的,一般不修改</p>
</li>
<li><p>M的个数和P的个数不一定一样多(会有休眠的M或P不绑定M) (最大10000)</p>
</li>
<li><p>P是用一个全局数组(255)来保存的,并且维护着一个全局的P空闲链表</p>
</li>
</ul>
<p>单从线程调度讲，Go语言相比起其他语言的优势在于OS线程是由OS内核来调度的，goroutine则是由Go运行时（runtime）自己的调度器调度的，这个调度器使用一个称为m:n调度的技术（复用&#x2F;调度m个goroutine到n个OS线程）。 其一大特点是goroutine的调度是在用户态下完成的， 不涉及内核态与用户态之间的频繁切换，包括内存的分配与释放，都是在用户态维护着一块大的内存池， 不直接调用系统的malloc函数（除非内存池需要改变），成本比调度OS线程低很多。 另一方面充分利用了多核的硬件资源，近似的把若干goroutine均分在物理线程上， 再加上本身goroutine的超轻量（默认为2kb），以上种种保证了go调度方面的性能。</p>
]]></content>
      <categories>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>底层原理</tag>
        <tag>面试题</tag>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title>Go高频面试题</title>
    <url>/2021/02/02/technology/golang/interview_issue/</url>
    <content><![CDATA[<h2 id="1-关于select"><a href="#1-关于select" class="headerlink" title="1.关于select"></a>1.关于select</h2><ul>
<li><p>select是Go语言中的一个控制语句，类似于switch，但是select主要用于通道操作（每一个case必须是一个通信操作，要么接收，要么发送）。 </p>
</li>
<li><p>select会随机选择一个可以运行的case；如果没有case可运行，那么将会阻塞，直到有一个case可以运行。</p>
</li>
</ul>
<h2 id="2-变量会怎么分配："><a href="#2-变量会怎么分配：" class="headerlink" title="2.变量会怎么分配："></a>2.变量会怎么分配：</h2><p>变量分配在栈还是堆是由go编译器自己控制的；编译时，会做逃逸分析，当变量作用域没有跑出函数的范围，就放在栈上；反之则必须放在堆上。<a href="/2021/02/03/technology/golang/memory_escape/">Go内存逃逸分析</a></p>
<h2 id="3-GC垃圾回收"><a href="#3-GC垃圾回收" class="headerlink" title="3.GC垃圾回收"></a>3.GC垃圾回收</h2><ul>
<li><p>v1.3：标记清除：整体过程需要启动STW，效率极低。</p>
</li>
<li><p>v1.5：三色标记法：堆空间启动写屏障，栈空间不启动，全部扫描之后，需要重新扫描一次栈(需要STW)，效率普通</p>
</li>
<li><p>v1.8：混合写屏障机制： 栈空间不启动，堆空间启动。整个过程几乎不需要STW，效率较高 <a href="/2021/02/03/technology/golang/gc_recycle/">Go垃圾回收</a></p>
</li>
</ul>
<h2 id="4-协程调度GPM"><a href="#4-协程调度GPM" class="headerlink" title="4.协程调度GPM"></a>4.协程调度GPM</h2><p>G：就是个goroutine（调度系统最基本的单位），里面除了存放本goroutine信息（执行stack信息；状态信息；所在的任务函数信息等）与所在P的绑定等信息。</p>
<p>P：就是process，管理着一组goroutine队列，存储当前goroutine运行的上下文环境。</p>
<p>M：machine，代表着真正的执行计算资源。</p>
<p>P管理着一组G在M上执行。<a href="/2021/02/03/technology/golang/gpm_explain/">GPM轻量理解</a></p>
<ul>
<li><p>每一个运行的M都必须绑定一个P，线程M创建后会检查并执行G对象</p>
</li>
<li><p>每一个P都保存着一个G队列</p>
</li>
<li><p>除了P保存的G队列外，还有一个全局G队列</p>
</li>
<li><p>M从队列中取出G并执行</p>
</li>
<li><p>P的个数就是 GOMAXPROCS(256)，一般不做修改</p>
</li>
<li><p>M的个数和P的个数不一定一样多</p>
</li>
<li><p>P是一个全局数组（255）来保存，并且维护者一个全局的P空闲链表</p>
</li>
</ul>
<h2 id="5-runtime机制"><a href="#5-runtime机制" class="headerlink" title="5.runtime机制"></a>5.runtime机制</h2><p><a href="https://blog.csdn.net/futurewu/article/details/104692651?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522162220408116780262566000%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=162220408116780262566000&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_v2~rank_v29-2-104692651.first_rank_v2_pc_rank_v29&utm_term=golang+%E7%9A%84+runtime+%E6%9C%BA%E5%88%B6&spm=1018.2226.3001.4187">runtime机制</a></p>
<p>runtime负责：管理调度，垃圾回收以及运行环境等。。Go语言的goroutine，channel这些高级功能都需要runtime的支持。</p>
<p>如何运行：用户编译代码后，runtime和编译后的代码会被静态链接起来，形成一个可执行文件。runtime通过接口函数调用来管理goroutine，channel这些高级功能；而且从用户代码调用操作系统的API调用会被runtime拦截处理。</p>
<p>组成：一个重要组成部分是goroutine scheduler ，它负责追踪调度goroutine运行，实际上是从应用程序的process所属的thread pool（线程池）中分配一个thread来执行这个goroutine。因此，每个goroutine只有分配到一个OS thread才能运行。</p>
<h2 id="6-make和new的区别"><a href="#6-make和new的区别" class="headerlink" title="6.make和new的区别"></a>6.make和new的区别</h2><p><a href="https://www.cnblogs.com/ghj1976/archive/2013/02/12/2910384.html">区别</a></p>
<p>make：返回初始化后的值。make是引用类型初始化的方法；常用于slice,map,channle。make(T…)</p>
<p>new：返回指针，即new(T)返回的是*T</p>
<h2 id="7-channel有缓冲和无缓冲"><a href="#7-channel有缓冲和无缓冲" class="headerlink" title="7.channel有缓冲和无缓冲"></a>7.channel有缓冲和无缓冲</h2><p><a href="https://blog.csdn.net/sgsgy5/article/details/82054902?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522162227719016780262526931%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=162227719016780262526931&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-82054902.first_rank_v2_pc_rank_v29&utm_term=%E6%9C%89%E7%BC%93%E5%86%B2channel&spm=1018.2226.3001.4187">有无缓冲</a></p>
<p>无缓冲：channel接收阻数据塞直到读取数据；channel发送阻塞直到数据被接收</p>
<p>有缓冲：当缓冲满时，channel接收数据阻塞；当缓冲空时，channel发送数据阻塞</p>
<p>无缓冲的  就是一个送信人去你家门口送信 ，你不在家 他不走，你一定要接下信，他才会走。</p>
<p>无缓冲保证信能到你手上（同步）</p>
<p>有缓冲的 就是一个送信人去你家仍到你家的信箱 转身就走 ，除非你的信箱满了 他必须等信箱空下来。</p>
<p>有缓冲的 保证 信能进你家的邮箱（非同步）</p>
<h2 id="8-并发方式和退出"><a href="#8-并发方式和退出" class="headerlink" title="8.并发方式和退出"></a>8.并发方式和退出</h2><p>并发：通常使用无缓冲chan来实现goroutine来是实现</p>
<p>退出：使用for-range来退出；使用，ok来退出；使用退出通道来退出</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// for-range是使用频率很高的结构，常用它来遍历数据，**range能够感知channel的关闭，当channel被发送数据的协程关闭时，range就会结束**，接着退出for循环。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    inCh := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(in &lt;-<span class="keyword">chan</span> <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">        <span class="comment">// Using for-range to exit goroutine</span></span><br><span class="line">        <span class="comment">// range has the ability to detect the close/end of a channel</span></span><br><span class="line">        <span class="keyword">for</span> x := <span class="keyword">range</span> in &#123;</span><br><span class="line">            fmt.Printf(<span class="string">&quot;Process %d\n&quot;</span>, x)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;(inCh)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用一个专门的通道，发送退出的信号</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">worker</span><span class="params">(stopCh &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">defer</span> fmt.Println(<span class="string">&quot;worker exit&quot;</span>)</span><br><span class="line">        <span class="comment">// Using stop channel explicit exit</span></span><br><span class="line">        <span class="keyword">for</span> &#123;</span><br><span class="line">            <span class="keyword">select</span> &#123;</span><br><span class="line">            <span class="keyword">case</span> &lt;-stopCh:</span><br><span class="line">                fmt.Println(<span class="string">&quot;Recv stop signal&quot;</span>)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">case</span> &lt;-t.C:</span><br><span class="line">                fmt.Println(<span class="string">&quot;Working .&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="9-interface-技巧"><a href="#9-interface-技巧" class="headerlink" title="9.interface()技巧"></a>9.interface()技巧</h2><ul>
<li>空接口    可以存放任意类型的数据</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    data := <span class="built_in">make</span>([]<span class="keyword">interface</span>&#123;&#125;, <span class="number">3</span>)</span><br><span class="line">    intData := <span class="number">1</span></span><br><span class="line">    stringData := <span class="string">&quot;abc&quot;</span></span><br><span class="line">    boolData := <span class="literal">true</span></span><br><span class="line">    data[<span class="number">0</span>] = intData</span><br><span class="line">    data[<span class="number">1</span>] = stringData</span><br><span class="line">    data[<span class="number">2</span>] = boolData</span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> data &#123;</span><br><span class="line">        fmt.Println(v)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<ul>
<li>接口嵌套</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> ReadWrite <span class="keyword">interface</span> &#123;</span><br><span class="line">    Read(b Buffer) <span class="type">bool</span></span><br><span class="line">    Write(b Buffer) <span class="type">bool</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Lock <span class="keyword">interface</span> &#123;</span><br><span class="line">    Lock()</span><br><span class="line">    Unlock()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> File <span class="keyword">interface</span> &#123;   <span class="comment">// 除了上面两个还有一个额外的close()接口</span></span><br><span class="line">    ReadWrite</span><br><span class="line">    Lock</span><br><span class="line">    Close()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<ul>
<li>类型选择和断言</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> v, ok := varI.(T); ok &#123;  <span class="comment">// 判断是否是自己想要的类型</span></span><br><span class="line">    assertion</span><br><span class="line">    Process(v)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h2 id="10-用信道实现主程等待协程2s-如果超过2s-主程直接结束-不用sleep"><a href="#10-用信道实现主程等待协程2s-如果超过2s-主程直接结束-不用sleep" class="headerlink" title="10.用信道实现主程等待协程2s,如果超过2s,主程直接结束(不用sleep)"></a>10.用信道实现主程等待协程2s,如果超过2s,主程直接结束(不用sleep)</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    start := time.Now()</span><br><span class="line">    wait := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;做点东西&quot;</span>)</span><br><span class="line">        time.Sleep(<span class="number">3</span>* time.Second)</span><br><span class="line">        wait &lt;- <span class="number">2</span></span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="string">&quot;这里是主程序&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> nums := &lt;-wait:    <span class="comment">// 当超过(阻塞)2s后，不会再执行这个条件，直接执行下面的</span></span><br><span class="line">        fmt.Println(nums)</span><br><span class="line">    <span class="keyword">case</span> &lt;-time.After(<span class="number">2</span> * time.Second): </span><br><span class="line">        fmt.Println(<span class="string">&quot;2秒后&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(time.Since(start))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>底层原理</tag>
        <tag>面试题</tag>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title>Go内存逃逸分析</title>
    <url>/2021/02/03/technology/golang/memory_escape/</url>
    <content><![CDATA[<h2 id="1-关于-堆和栈"><a href="#1-关于-堆和栈" class="headerlink" title="1. 关于 堆和栈"></a>1. 关于 堆和栈</h2><p>栈可以简单得理解成一次函数调用内部申请到的内存，它们会随着函数的返回把内存还给系统。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">F</span><span class="params">()</span></span> &#123;</span><br><span class="line">    temp := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>, <span class="number">20</span>)</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>类似于上面代码里面的temp变量，只是内函数内部申请的临时变量，并不会作为返回值返回，它就是被编译器申请到栈里面。 </p>
<p>申请到<strong>栈内存</strong>好处：函数返回直接释放，不会引起垃圾回收，对性能没有影响。</p>
<p>再来看看堆得情况之一如下代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">F</span><span class="params">()</span></span> []<span class="type">int</span>&#123;</span><br><span class="line">    a := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>, <span class="number">20</span>)</span><br><span class="line">    <span class="keyword">return</span> a</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而上面这段代码，申请的代码一模一样，但是申请后作为返回值返回了，编译器会认为变量之后还会被使用，当函数返回之后并不会将其内存归还，那么它就会被申请到 堆 上面了。</p>
<p><strong>申请到堆上面的内存才会引起垃圾回收，如果这个过程（特指垃圾回收不断被触发）过于高频就会导致 gc 压力过大，程序性能出问题。</strong></p>
<p>我们再看看如下几个例子：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">F</span><span class="params">()</span></span> &#123;</span><br><span class="line">    a := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>, <span class="number">20</span>)     <span class="comment">// 栈 空间小</span></span><br><span class="line">    b := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>, <span class="number">20000</span>) <span class="comment">// 堆 空间过大</span></span><br><span class="line"></span><br><span class="line">    l := <span class="number">20</span></span><br><span class="line">    c := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>, l) <span class="comment">// 堆 动态分配不定空间</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>像是 b 这种 即使是临时变量，申请过大也会在堆上面申请。对于 c 编译器对于这种不定长度的申请方式，也会在堆上面申请，即使申请的长度很短。</p>
<h2 id="2-逃逸分析（Escape-analysis）"><a href="#2-逃逸分析（Escape-analysis）" class="headerlink" title="2. 逃逸分析（Escape analysis）"></a>2. 逃逸分析（Escape analysis）</h2><p>逃逸分析指的是由编译器决定内存分配的位置,不需要由程序员指定.</p>
<p>在函数中申请一个新的对象</p>
<ul>
<li><p><strong>如果申请到栈中,则函数执行结束可以自动将内存回收.</strong></p>
</li>
<li><p><strong>如果分配到堆,则函数执行结束就可以交给GC处理.</strong></p>
</li>
</ul>
<h2 id="3-逃逸场景（什么情况才分配到堆中）"><a href="#3-逃逸场景（什么情况才分配到堆中）" class="headerlink" title="3. 逃逸场景（什么情况才分配到堆中）"></a>3. 逃逸场景（什么情况才分配到堆中）</h2><h3 id="3-1-指针逃逸"><a href="#3-1-指针逃逸" class="headerlink" title="3.1 指针逃逸"></a>3.1 指针逃逸</h3><p>Go可以返回局部变量指针，这其实是一个典型的变量逃逸案例，示例代码如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="type">string</span></span><br><span class="line">    Age  <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">StudentRegister</span><span class="params">(name <span class="type">string</span>, age <span class="type">int</span>)</span></span> *Student &#123;</span><br><span class="line">    s := <span class="built_in">new</span>(Student) <span class="comment">//局部变量s逃逸到堆</span></span><br><span class="line"></span><br><span class="line">    s.Name = name</span><br><span class="line">    s.Age = age</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    StudentRegister(<span class="string">&quot;Jim&quot;</span>, <span class="number">18</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>虽然 在函数 StudentRegister() 内部 s 为局部变量，其值通过函数返回值返回，s 本身为一指针，其指向的内存地址不会是栈而是堆，这就是典型的逃逸案例。</p>
<p>终端运行命令查看逃逸分析日志：</p>
<figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="code"><pre><span class="line">go build -gcflags=-m</span><br></pre></td></tr></table></figure>


<img data-src="/2021/02/03/technology/golang/memory_escape/img_1.png" class="" title="image.png">

<p>可见在StudentRegister()函数中，也即代码第9行显示”escapes to heap”，代表该行内存分配发生了逃逸现象。</p>
<h3 id="3-2-栈空间不足逃逸（空间开辟过大）"><a href="#3-2-栈空间不足逃逸（空间开辟过大）" class="headerlink" title="3.2 栈空间不足逃逸（空间开辟过大）"></a>3.2 栈空间不足逃逸（空间开辟过大）</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Slice</span><span class="params">()</span></span> &#123;</span><br><span class="line">    s := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">1000</span>, <span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> index, _ := <span class="keyword">range</span> s &#123;</span><br><span class="line">        s[index] = index</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    Slice()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>上面代码Slice()函数中分配了一个1000个长度的切片，是否逃逸取决于栈空间是否足够大。 直接查看编译提示，如下：</p>
<img data-src="/2021/02/03/technology/golang/memory_escape/img_2.png" class="" title="image.png">

<p>所以只是1000的长度还不足以发生逃逸现象。然后就x10倍吧</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Slice</span><span class="params">()</span></span> &#123;</span><br><span class="line">    s := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">10000</span>, <span class="number">10000</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> index, _ := <span class="keyword">range</span> s &#123;</span><br><span class="line">        s[index] = index</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    Slice()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>分析如下：当切片长度扩大到10000时就会逃逸。实际上当栈空间不足以存放当前对象时或无法判断当前切片长度时会将对象分配到堆中。</p>
<h3 id="3-3-动态类型逃逸（不确定长度大小）"><a href="#3-3-动态类型逃逸（不确定长度大小）" class="headerlink" title="3.3 动态类型逃逸（不确定长度大小）"></a>3.3 动态类型逃逸（不确定长度大小）</h3><p>很多函数参数为interface类型，比如fmt.Println(a …interface{})，编译期间很难确定其参数的具体类型，也能产生逃逸。</p>
<p>如下代码所示：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    s := <span class="string">&quot;Escape&quot;</span></span><br><span class="line">    fmt.Println(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>逃逸分下如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">D:\SourceCode\GoExpert\src&gt;go build -gcflags=-m</span><br><span class="line"># _/D_/SourceCode/GoExpert/src</span><br><span class="line">.\main.go:7: s escapes to heap</span><br><span class="line">.\main.go:7: main ... argument does not escape</span><br></pre></td></tr></table></figure>


<p>又或者像前面提到的例子：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">F</span><span class="params">()</span></span> &#123;</span><br><span class="line">    a := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>, <span class="number">20</span>)     <span class="comment">// 栈 空间小</span></span><br><span class="line">    b := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>, <span class="number">20000</span>) <span class="comment">// 堆 空间过大 逃逸</span></span><br><span class="line"></span><br><span class="line">    l := <span class="number">20</span></span><br><span class="line">    c := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>, l) <span class="comment">// 堆 动态分配不定空间 逃逸</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="3-4-闭包引用对象逃逸"><a href="#3-4-闭包引用对象逃逸" class="headerlink" title="3.4 闭包引用对象逃逸"></a>3.4 闭包引用对象逃逸</h3><p>Fibonacci数列的函数：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Fibonacci</span><span class="params">()</span></span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    a, b := <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">int</span> &#123;</span><br><span class="line">        a, b = b, a+b</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    f := Fibonacci()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;Fibonacci: %d\n&quot;</span>, f())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>输出如下：</p>
<figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="code"><pre><span class="line"> ~/go/src/gitHub/test/pool  go run main.go</span><br><span class="line">Fibonacci: 1</span><br><span class="line">Fibonacci: 1</span><br><span class="line">Fibonacci: 2</span><br><span class="line">Fibonacci: 3</span><br><span class="line">Fibonacci: 5</span><br><span class="line">Fibonacci: 8</span><br><span class="line">Fibonacci: 13</span><br><span class="line">Fibonacci: 21</span><br><span class="line">Fibonacci: 34</span><br><span class="line">Fibonacci: 55</span><br></pre></td></tr></table></figure>


<p>逃逸如下：</p>
<figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="code"><pre><span class="line"> ~/go/src/gitHub/test/pool  go build -gcflags=-m</span><br><span class="line"># gitHub/test/pool</span><br><span class="line">./main.go:7:9: can inline Fibonacci.func1</span><br><span class="line">./main.go:7:9: func literal escapes to heap</span><br><span class="line">./main.go:7:9: func literal escapes to heap</span><br><span class="line">./main.go:8:10: &amp;b escapes to heap</span><br><span class="line">./main.go:6:5: moved to heap: b</span><br><span class="line">./main.go:8:13: &amp;a escapes to heap</span><br><span class="line">./main.go:6:2: moved to heap: a</span><br><span class="line">./main.go:17:34: f() escapes to heap</span><br><span class="line">./main.go:17:13: main ... argument does not escape</span><br></pre></td></tr></table></figure>


<p>Fibonacci()函数中原本属于局部变量的a和b由于闭包的引用，不得不将二者放到堆上，以致产生逃逸。</p>
<h3 id="逃逸分析的作用是什么呢？"><a href="#逃逸分析的作用是什么呢？" class="headerlink" title="逃逸分析的作用是什么呢？"></a>逃逸分析的作用是什么呢？</h3><ol>
<li><p>逃逸分析的好处是为了减少gc的压力，不逃逸的对象分配在栈上，当函数返回时就回收了资源，不需要gc标记清除。</p>
</li>
<li><p>逃逸分析完后可以确定哪些变量可以分配在栈上，栈的分配比堆快，性能好(逃逸的局部变量会在堆上分配 ,而没有发生逃逸的则有编译器在栈上分配)。</p>
</li>
<li><p>同步消除，如果你定义的对象的方法上有同步锁，但在运行时，却只有一个线程在访问，此时逃逸分析后的机器码，会去掉同步锁运行。</p>
</li>
</ol>
<h3 id="逃逸总结："><a href="#逃逸总结：" class="headerlink" title="逃逸总结："></a>逃逸总结：</h3><ul>
<li><p>栈上分配内存比在堆中分配内存有更高的效率</p>
</li>
<li><p>栈上分配的内存不需要GC处理</p>
</li>
<li><p>堆上分配的内存使用完毕会交给GC处理</p>
</li>
<li><p>逃逸分析目的是决定内分配地址是栈还是堆</p>
</li>
<li><p>逃逸分析在编译阶段完成</p>
</li>
</ul>
<p>提问：函数传递指针真的比传值效率高吗？</p>
<blockquote>
<p>我们知道传递指针可以减少底层值的拷贝，可以提高效率，但是如果拷贝的数据量小，由于指针传递会产生逃逸，可能会使用堆，也可能会增加GC的负担，所以传递指针不一定是高效的。</p>
</blockquote>
<p>在官网 (golang.org) FAQ 上有一个关于变量分配的问题如下：</p>
<blockquote>
<p>From a correctness standpoint, you don’t need to know. Each variable in Go exists as long as there are references to it. The storage location chosen by the implementation is irrelevant to the semantics of the language.</p>
</blockquote>
<blockquote>
<p>The storage location does have an effect on writing efficient programs. When possible, the Go compilers will allocate variables that are local to a function in that function’s stack frame.</p>
</blockquote>
<blockquote>
<p>However, if the compiler cannot prove that the variable is not referenced after the function returns, then the compiler must allocate the variable on the garbage-collected heap to avoid dangling pointer errors. Also, if a local variable is very large, it might make more sense to store it on the heap rather than the stack.</p>
</blockquote>
<blockquote>
<p>In the current compilers, if a variable has its address taken, that variable is a candidate for allocation on the heap. However, a basic escape analysis recognizes some cases when such variables will not live past the return from the function and can reside on the stack.</p>
</blockquote>
<p>翻译如下：</p>
<p>如何得知变量是分配在栈（stack）上还是堆（heap）上？</p>
<p>准确地说，你并不需要知道。Golang 中的变量只要被引用就一直会存活，存储在堆上还是栈上由内部实现决定而和具体的语法没有关系。</p>
<p>知道变量的存储位置确实和效率编程有关系。如果可能，Golang 编译器会将函数的局部变量分配到函数栈帧（stack frame）上。 然而，如果编译器不能确保变量在函数 return之后不再被引用，编译器就会将变量分配到堆上。而且，如果一个局部变量非常大，那么它也应该被分配到堆上而不是栈上。</p>
<p>当前情况下，如果一个变量被取地址，那么它就有可能被分配到堆上。然而，还要对这些变量做逃逸分析，如果函数return之后，变量不再被引用，则将其分配到栈上。</p>
]]></content>
      <categories>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>底层原理</tag>
        <tag>面试题</tag>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title>Go内存泄漏</title>
    <url>/2021/02/03/technology/golang/memory_leak/</url>
    <content><![CDATA[<h2 id="1-字符串截取"><a href="#1-字符串截取" class="headerlink" title="1.字符串截取"></a>1.字符串截取</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> str0 = <span class="string">&quot;12345678901234567890&quot;</span></span><br><span class="line">    str1 := str0[:<span class="number">10</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>以上代码，会有10字节的内存泄漏，我们知道，str0和str1底层共享内存，只要str1一直活跃，str0 就不会被回收，10字节的内存被使用，剩下的10字节内存就造成了临时性的内存泄漏，直到str1不再活跃</p>
<p>如果str0足够大，str1截取足够小，或者在高并发场景中频繁使用，那么可想而知，会造成临时性内存泄漏，对性能产生极大影响。</p>
<p>解决方法：</p>
<p>将需要截取的部分先转换成[]byte，再转换成string，但是这种方式会产生两个10字节的临时变量，string转换[]byte时产生一个10字节临时变量，[]byte转换string时产生一个10字节的临时变量</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> str0 = <span class="string">&quot;12345678901234567890&quot;</span></span><br><span class="line">    str1 := <span class="type">string</span>([]<span class="type">byte</span>(str0[:<span class="number">10</span>]))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="2-切片截取（和第一个类似）"><a href="#2-切片截取（和第一个类似）" class="headerlink" title="2.切片截取（和第一个类似）"></a>2.切片截取（和第一个类似）</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> s0 = []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;</span><br><span class="line">    s1 := s0[:<span class="number">5</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>解决方法：append</p>
<p>append函数是向 <code>slice里面追加一个或多个元素，然后返回一个和slice一样类型的slice（复制一份）</code></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> s0 = []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;</span><br><span class="line">    s1 := <span class="built_in">append</span>(s0[<span class="number">0</span>:<span class="number">0</span>], s0[:<span class="number">5</span>]...)</span><br><span class="line">    fmt.Println(s1)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-没有重置丢失的子切片元素中的指针"><a href="#3-没有重置丢失的子切片元素中的指针" class="headerlink" title="3.没有重置丢失的子切片元素中的指针"></a>3.没有重置丢失的子切片元素中的指针</h2><p>原切片元素为指针类型，原切片被截取后，丢失的子切片元素中的指针元素未被置空，导致内存泄漏</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> s0 = []*<span class="type">int</span>&#123;<span class="built_in">new</span>(<span class="type">int</span>), <span class="built_in">new</span>(<span class="type">int</span>), <span class="built_in">new</span>(<span class="type">int</span>), <span class="built_in">new</span>(<span class="type">int</span>), <span class="built_in">new</span>(<span class="type">int</span>)&#125;</span><br><span class="line">    s1 := s0[<span class="number">1</span>:<span class="number">3</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>解决方案：元素置空</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> s0 = []*<span class="type">int</span>&#123;<span class="built_in">new</span>(<span class="type">int</span>), <span class="built_in">new</span>(<span class="type">int</span>), <span class="built_in">new</span>(<span class="type">int</span>), <span class="built_in">new</span>(<span class="type">int</span>), <span class="built_in">new</span>(<span class="type">int</span>)&#125;</span><br><span class="line">    s0[<span class="number">0</span>], s0[<span class="number">3</span>], s0[<span class="number">4</span>] = <span class="literal">nil</span>, <span class="literal">nil</span>, <span class="literal">nil</span></span><br><span class="line">    s1 := s0[<span class="number">1</span>:<span class="number">3</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="4-数组传参"><a href="#4-数组传参" class="headerlink" title="4.数组传参"></a>4.数组传参</h2><p>Go数组是值类型，赋值和函数传参都会复制整个数组</p>
<p>如果我们在函数传参的时候用到了数组传参，且这个数组够大（我们假设数组大小为100万，64位机上消耗的内存约为800w字节，即8MB内存），或者该函数短时间内被调用N次，那么可想而知，会消耗大量内存，对性能产生极大的影响，如果短时间内分配大量内存，而又来不及GC，那么就会产生临时性的内存泄漏，对于高并发场景相当可怕。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> arrayA = [<span class="number">3</span>]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">    <span class="keyword">var</span> arrayB = [<span class="number">3</span>]<span class="type">int</span>&#123;&#125;</span><br><span class="line">    arrayB = arrayA</span><br><span class="line">    fmt.Printf(<span class="string">&quot;arrayA address: %p, arrayA value: %+v\n&quot;</span>, &amp;arrayA, arrayA)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;arrayB address: %p, arrayB value: %+v\n&quot;</span>, &amp;arrayB, arrayB)</span><br><span class="line">    array(arrayA)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">array</span><span class="params">(array [3]<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;array address: %p, array value: %+v\n&quot;</span>, &amp;array, array)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>解决方案：指针传参或者利用切片</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> arrayA = [<span class="number">3</span>]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">    <span class="keyword">var</span> arrayB = &amp;arrayA</span><br><span class="line">    fmt.Printf(<span class="string">&quot;arrayA address: %p, arrayA value: %+v\n&quot;</span>, &amp;arrayA, arrayA)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;arrayB address: %p, arrayB value: %+v\n&quot;</span>, arrayB, *arrayB)</span><br><span class="line">    arrayP(&amp;arrayA)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">arrayP</span><span class="params">(array *[3]<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;array address: %p, array value: %+v\n&quot;</span>, array, *array)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="5-goroutine"><a href="#5-goroutine" class="headerlink" title="5.goroutine"></a>5.goroutine</h2><p>“Go里面10次内存泄漏有9次都是goroutine泄漏引起的”</p>
<p>有些编码不当的情况下，goroutine被长期挂住，导致该协程中的内存也无法被释放，就会造成永久性的内存泄漏。例如协程结束时协程中的channel没有关闭，导致一直阻塞；例如协程中有死循环；等等</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ticker := time.NewTicker(time.Second * <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        &lt;-ticker.C</span><br><span class="line">        ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">100</span>; i++ &#123;</span><br><span class="line">                ch &lt;- i</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> v := <span class="keyword">range</span> ch &#123;</span><br><span class="line">            <span class="keyword">if</span> v == <span class="number">50</span> &#123;</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>解决方案：（涉及到goroutine之间的通信）</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ticker := time.NewTicker(time.Second * <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        &lt;-ticker.C</span><br><span class="line">        cxt, cancel := context.WithCancel(context.Background())</span><br><span class="line">        ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(cxt context.Context)</span></span> &#123;</span><br><span class="line">            <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">100</span>; i++ &#123;</span><br><span class="line">                <span class="keyword">select</span> &#123;</span><br><span class="line">                <span class="keyword">case</span> &lt;-cxt.Done():</span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">                <span class="keyword">case</span> ch &lt;- i:</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;(cxt)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> v := <span class="keyword">range</span> ch &#123;</span><br><span class="line">            <span class="keyword">if</span> v == <span class="number">50</span> &#123;</span><br><span class="line">                cancel()</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>面试题</tag>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title>Go内存对齐</title>
    <url>/2021/02/03/technology/golang/memory_to_its/</url>
    <content><![CDATA[<h2 id="为什么要内存对齐？"><a href="#为什么要内存对齐？" class="headerlink" title="为什么要内存对齐？"></a>为什么要内存对齐？</h2><ul>
<li><p>平台（移植性）原因：不是所有的硬件平台都能够访问任意地址上的任意数据。例如：特定的硬件平台只允许在特定地址获取特定类型的数据，否则会导致异常情况</p>
</li>
<li><p>性能原因：若访问未对齐的内存，将会导致 CPU 进行两次内存访问，并且要花费额外的时钟周期来处理对齐及运算。而本身就对齐的内存仅需要一次访问就可以完成读取动作</p>
</li>
</ul>
<h2 id="成员对齐"><a href="#成员对齐" class="headerlink" title="成员对齐"></a>成员对齐</h2><figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">    fmt.Printf(&quot;bool align: %d\n&quot;, unsafe.Alignof(bool(true)))</span><br><span class="line">    fmt.Printf(&quot;int32 align: %d\n&quot;, unsafe.Alignof(int32(0)))</span><br><span class="line">    fmt.Printf(&quot;int8 align: %d\n&quot;, unsafe.Alignof(int8(0)))</span><br><span class="line">    fmt.Printf(&quot;int64 align: %d\n&quot;, unsafe.Alignof(int64(0)))</span><br><span class="line">    fmt.Printf(&quot;byte align: %d\n&quot;, unsafe.Alignof(byte(0)))</span><br><span class="line">    fmt.Printf(&quot;string align: %d\n&quot;, unsafe.Alignof(&quot;EDDYCJY&quot;))</span><br><span class="line">    fmt.Printf(&quot;map align: %d\n&quot;, unsafe.Alignof(map[string]string&#123;&#125;))</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>输出结果：</p>
<figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="code"><pre><span class="line">bool align: 1</span><br><span class="line">int32 align: 4</span><br><span class="line">int8 align: 1</span><br><span class="line">int64 align: 8</span><br><span class="line">byte align: 1</span><br><span class="line">string align: 8</span><br><span class="line">map align: 8</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>在 Go 中可以调用 <code>unsafe.Alignof</code> 来返回相应类型的对齐系数。通过观察输出结果，可得知基本都是 <code>2^n</code>，最大也不会超过 8。这是因为我手提（64 位）编译器默认对齐系数是 8，因此最大值不会超过这个数</p>
<h2 id=""><a href="#" class="headerlink" title=""></a></h2><h2 id="整体对齐"><a href="#整体对齐" class="headerlink" title="整体对齐"></a>整体对齐</h2><p>在上小节中，提到了结构体中的成员变量要做字节对齐。那么想当然身为最终结果的结构体，也是需要做字节对齐的</p>
<h2 id="对齐规则"><a href="#对齐规则" class="headerlink" title="对齐规则"></a>对齐规则</h2><ul>
<li><p>结构体的成员变量，第一个成员变量的偏移量为 0。往后的每个成员变量的对齐值必须为<strong>编译器默认对齐长度</strong>（<code>#pragma pack(n)</code>）或<strong>当前成员变量类型的长度</strong>（<code>unsafe.Sizeof</code>），取<strong>最小值作为当前类型的对齐值</strong>。其偏移量必须为对齐值的整数倍</p>
</li>
<li><p>结构体本身，对齐值必须为<strong>编译器默认对齐长度</strong>（<code>#pragma pack(n)</code>）或<strong>结构体的所有成员变量类型中的最大长度</strong>，取<strong>最大数的最小整数倍</strong>作为对齐值</p>
</li>
</ul>
<p>结合以上两点，可得知若<strong>编译器默认对齐长度</strong>（<code>#pragma pack(n)</code>）超过结构体内成员变量的类型最大长度时，默认对齐长度是没有任何意义的</p>
]]></content>
      <categories>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>面试题</tag>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title>常用限流策略</title>
    <url>/2022/06/03/technology/network/flow_limit/</url>
    <content><![CDATA[<h2 id="限流"><a href="#限流" class="headerlink" title="限流"></a>限流</h2><p>限流又称为流量控制（流控），通常是指限制到达系统的并发请求数。</p>
<p>我们生活中也会经常遇到限流的场景，比如：某景区限制每日进入景区的游客数量为8万人；沙河地铁站早高峰通过站外排队逐一放行的方式限制同一时间进入车站的旅客数量等。</p>
<p>限流虽然会影响部分用户的使用体验，但是却能在一定程度上报障系统的稳定性，不至于崩溃（大家都没了用户体验）。</p>
<p>而互联网上类似需要限流的业务场景也有很多，比如电商系统的秒杀、微博上突发热点新闻、双十一购物节、12306抢票等等。这些场景下的用户请求量通常会激增，远远超过平时正常的请求量，此时如果不加任何限制很容易就会将后端服务打垮，影响服务的稳定性。</p>
<p>此外，一些厂商公开的API服务通常也会限制用户的请求次数，比如百度地图开放平台等会根据用户的付费情况来限制用户的请求数等。</p>
<img data-src="/2022/06/03/technology/network/flow_limit/image.png" class="" title="image.png">

<h2 id="常用的限流策略"><a href="#常用的限流策略" class="headerlink" title="常用的限流策略"></a>常用的限流策略</h2><h3 id="漏桶"><a href="#漏桶" class="headerlink" title="漏桶"></a>漏桶</h3><p>漏桶法限流很好理解，假设我们有一个水桶按固定的速率向下方滴落一滴水，无论有多少请求，请求的速率有多大，都按照固定的速率流出，对应到系统中就是按照固定的速率处理请求。</p>
<img data-src="/2022/06/03/technology/network/flow_limit/image_1.png" class="" title="image.png">
<p>漏桶法的关键点在于漏桶始终按照固定的速率运行，但是它并不能很好的处理有大量突发请求的场景，毕竟在某些场景下我们可能需要提高系统的处理效率，而不是一味的按照固定速率处理请求。</p>
<p>关于漏桶的实现，uber团队有一个开源的<a href="https://github.com/uber-go/ratelimit">github.com&#x2F;uber-go&#x2F;ratelimit</a>库。 这个库的使用方法比较简单，<code>Take()</code> 方法会返回漏桶下一次滴水的时间。</p>
<figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="code"><pre><span class="line">import (</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">    &quot;time&quot;</span><br><span class="line"></span><br><span class="line">    &quot;go.uber.org/ratelimit&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    rl := ratelimit.New(100) // per second</span><br><span class="line"></span><br><span class="line">    prev := time.Now()</span><br><span class="line">    for i := 0; i &lt; 10; i++ &#123;</span><br><span class="line">        now := rl.Take()</span><br><span class="line">        fmt.Println(i, now.Sub(prev))</span><br><span class="line">        prev = now</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Output:</span><br><span class="line">    // 0 0</span><br><span class="line">    // 1 10ms</span><br><span class="line">    // 2 10ms</span><br><span class="line">    // 3 10ms</span><br><span class="line">    // 4 10ms</span><br><span class="line">    // 5 10ms</span><br><span class="line">    // 6 10ms</span><br><span class="line">    // 7 10ms</span><br><span class="line">    // 8 10ms</span><br><span class="line">    // 9 10ms</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>它的源码实现也比较简单，这里大致说一下关键的地方，有兴趣的同学可以自己去看一下完整的源码。</p>
<p>限制器是一个接口类型，其要求实现一个<code>Take()</code>方法：</p>
<figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="code"><pre><span class="line">type Limiter interface &#123;</span><br><span class="line">    // Take方法应该阻塞已确保满足 RPS</span><br><span class="line">    Take() time.Time</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>实现限制器接口的结构体定义如下，这里可以重点留意下<code>maxSlack</code>字段，它在后面的<code>Take()</code>方法中的处理。</p>
<figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="code"><pre><span class="line">type limiter struct &#123;</span><br><span class="line">    sync.Mutex                // 锁</span><br><span class="line">    last       time.Time      // 上一次的时刻</span><br><span class="line">    sleepFor   time.Duration  // 需要等待的时间</span><br><span class="line">    perRequest time.Duration  // 每次的时间间隔</span><br><span class="line">    maxSlack   time.Duration  // 最大的富余量</span><br><span class="line">    clock      Clock          // 时钟</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p><code>limiter</code>结构体实现<code>Limiter</code>接口的<code>Take()</code>方法内容如下：</p>
<figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="code"><pre><span class="line">// Take 会阻塞确保两次请求之间的时间走完</span><br><span class="line">// Take 调用平均数为 time.Second/rate.</span><br><span class="line">func (t *limiter) Take() time.Time &#123;</span><br><span class="line">    t.Lock()</span><br><span class="line">    defer t.Unlock()</span><br><span class="line"></span><br><span class="line">    now := t.clock.Now()</span><br><span class="line"></span><br><span class="line">    // 如果是第一次请求就直接放行</span><br><span class="line">    if t.last.IsZero() &#123;</span><br><span class="line">        t.last = now</span><br><span class="line">        return t.last</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // sleepFor 根据 perRequest 和上一次请求的时刻计算应该sleep的时间</span><br><span class="line">    // 由于每次请求间隔的时间可能会超过perRequest, 所以这个数字可能为负数，并在多个请求之间累加</span><br><span class="line">    t.sleepFor += t.perRequest - now.Sub(t.last)</span><br><span class="line"></span><br><span class="line">    // 我们不应该让sleepFor负的太多，因为这意味着一个服务在短时间内慢了很多随后会得到更高的RPS。</span><br><span class="line">    if t.sleepFor &lt; t.maxSlack &#123;</span><br><span class="line">        t.sleepFor = t.maxSlack</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 如果 sleepFor 是正值那么就 sleep</span><br><span class="line">    if t.sleepFor &gt; 0 &#123;</span><br><span class="line">        t.clock.Sleep(t.sleepFor)</span><br><span class="line">        t.last = now.Add(t.sleepFor)</span><br><span class="line">        t.sleepFor = 0</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        t.last = now</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return t.last</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>上面的代码根据记录每次请求的间隔时间和上一次请求的时刻来计算当次请求需要阻塞的时间——<code>sleepFor</code>，这里需要留意的是<code>sleepFor</code>的值可能为负，在经过间隔时间长的两次访问之后会导致随后大量的请求被放行，所以代码中针对这个场景有专门的优化处理。创建限制器的<code>New()</code>函数中会为<code>maxSlack</code>设置初始值，也可以通过<code>WithoutSlack</code>这个Option取消这个默认值。</p>
<figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="code"><pre><span class="line">func New(rate int, opts ...Option) Limiter &#123;</span><br><span class="line">    l := &amp;limiter&#123;</span><br><span class="line">        perRequest: time.Second / time.Duration(rate),</span><br><span class="line">        maxSlack:   -10 * time.Second / time.Duration(rate),</span><br><span class="line">    &#125;</span><br><span class="line">    for _, opt := range opts &#123;</span><br><span class="line">        opt(l)</span><br><span class="line">    &#125;</span><br><span class="line">    if l.clock == nil &#123;</span><br><span class="line">        l.clock = clock.New()</span><br><span class="line">    &#125;</span><br><span class="line">    return l</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h3 id="令牌桶"><a href="#令牌桶" class="headerlink" title="令牌桶"></a>令牌桶</h3><p>令牌桶其实和漏桶的原理类似，令牌桶按固定的速率往桶里放入令牌，并且只要能从桶里取出令牌就能通过，令牌桶支持突发流量的快速处理。</p>
<img data-src="/2022/06/03/technology/network/flow_limit/image_2.png" class="" title="image.png">

<p>对于从桶里取不到令牌的场景，我们可以选择等待也可以直接拒绝并返回。</p>
<p>对于令牌桶的Go语言实现，大家可以参照<a href="https://github.com/juju/ratelimit">github.com&#x2F;juju&#x2F;ratelimit</a>库。这个库支持多种令牌桶模式，并且使用起来也比较简单。</p>
<p>创建令牌桶的方法：</p>
<figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="code"><pre><span class="line">// 创建指定填充速率和容量大小的令牌桶</span><br><span class="line">func NewBucket(fillInterval time.Duration, capacity int64) *Bucket</span><br><span class="line">// 创建指定填充速率、容量大小和每次填充的令牌数的令牌桶</span><br><span class="line">func NewBucketWithQuantum(fillInterval time.Duration, capacity, quantum int64) *Bucket</span><br><span class="line">// 创建填充速度为指定速率和容量大小的令牌桶</span><br><span class="line">// NewBucketWithRate(0.1, 200) 表示每秒填充20个令牌</span><br><span class="line">func NewBucketWithRate(rate float64, capacity int64) *Bucket</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>取出令牌的方法如下：</p>
<figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="code"><pre><span class="line">// 取token（非阻塞）</span><br><span class="line">func (tb *Bucket) Take(count int64) time.Duration</span><br><span class="line">func (tb *Bucket) TakeAvailable(count int64) int64</span><br><span class="line"></span><br><span class="line">// 最多等maxWait时间取token</span><br><span class="line">func (tb *Bucket) TakeMaxDuration(count int64, maxWait time.Duration) (time.Duration, bool)</span><br><span class="line"></span><br><span class="line">// 取token（阻塞）</span><br><span class="line">func (tb *Bucket) Wait(count int64)</span><br><span class="line">func (tb *Bucket) WaitMaxDuration(count int64, maxWait time.Duration) bool</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>虽说是令牌桶，但是我们没有必要真的去生成令牌放到桶里，我们只需要每次来取令牌的时候计算一下，当前是否有足够的令牌就可以了，具体的计算方式可以总结为下面的公式：</p>
<figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="code"><pre><span class="line">当前令牌数 = 上一次剩余的令牌数 + (本次取令牌的时刻-上一次取令牌的时刻)/放置令牌的时间间隔 * 每次放置的令牌数</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p><a href="https://github.com/juju/ratelimit">github.com&#x2F;juju&#x2F;ratelimit</a>这个库中关于令牌数计算的源代码如下：</p>
<figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="code"><pre><span class="line">func (tb *Bucket) currentTick(now time.Time) int64 &#123;</span><br><span class="line">    return int64(now.Sub(tb.startTime) / tb.fillInterval)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="code"><pre><span class="line">func (tb *Bucket) adjustavailableTokens(tick int64) &#123;</span><br><span class="line">    if tb.availableTokens &gt;= tb.capacity &#123;</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line">    tb.availableTokens += (tick - tb.latestTick) * tb.quantum</span><br><span class="line">    if tb.availableTokens &gt; tb.capacity &#123;</span><br><span class="line">        tb.availableTokens = tb.capacity</span><br><span class="line">    &#125;</span><br><span class="line">    tb.latestTick = tick</span><br><span class="line">    return</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>获取令牌的<code>TakeAvailable()</code>函数关键部分的源代码如下：</p>
<figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="code"><pre><span class="line">func (tb *Bucket) takeAvailable(now time.Time, count int64) int64 &#123;</span><br><span class="line">    if count &lt;= 0 &#123;</span><br><span class="line">        return 0</span><br><span class="line">    &#125;</span><br><span class="line">    tb.adjustavailableTokens(tb.currentTick(now))</span><br><span class="line">    if tb.availableTokens &lt;= 0 &#123;</span><br><span class="line">        return 0</span><br><span class="line">    &#125;</span><br><span class="line">    if count &gt; tb.availableTokens &#123;</span><br><span class="line">        count = tb.availableTokens</span><br><span class="line">    &#125;</span><br><span class="line">    tb.availableTokens -= count</span><br><span class="line">    return count</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>大家从代码中也可以看到其实令牌桶的实现并没有很复杂。</p>
<h2 id="gin框架中使用限流中间件"><a href="#gin框架中使用限流中间件" class="headerlink" title="gin框架中使用限流中间件"></a>gin框架中使用限流中间件</h2><p>在gin框架构建的项目中，我们可以将限流组件定义成中间件。</p>
<p>这里使用令牌桶作为限流策略，编写一个限流中间件如下：</p>
<figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="code"><pre><span class="line">func RateLimitMiddleware(fillInterval time.Duration, cap int64) func(c *gin.Context) &#123;</span><br><span class="line">    bucket := ratelimit.NewBucket(fillInterval, cap)</span><br><span class="line">    return func(c *gin.Context) &#123;</span><br><span class="line">        // 如果取不到令牌就中断本次请求返回 rate limit...</span><br><span class="line">        if bucket.TakeAvailable(1) &lt; 1 &#123;</span><br><span class="line">            c.String(http.StatusOK, &quot;rate limit...&quot;)</span><br><span class="line">            c.Abort()</span><br><span class="line">            return</span><br><span class="line">        &#125;</span><br><span class="line">        c.Next()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>对于该限流中间件的注册位置，我们可以按照不同的限流策略将其注册到不同的位置，例如：</p>
<ol>
<li><p>如果要对全站限流就可以注册成全局的中间件。</p>
</li>
<li><p>如果是某一组路由需要限流，那么就只需将该限流中间件注册到对应的路由组即可。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>面试题</tag>
        <tag>限流</tag>
      </tags>
  </entry>
  <entry>
    <title>goroutine通信方式</title>
    <url>/2021/02/03/technology/golang/goroutine_method/</url>
    <content><![CDATA[<p>Goroutine 之间常用的通信方式有：</p>
<ul>
<li><p>全局变量</p>
</li>
<li><p>channel</p>
</li>
<li><p>context 上下文</p>
</li>
</ul>
<h3 id="sync-WaitGroup"><a href="#sync-WaitGroup" class="headerlink" title="sync.WaitGroup"></a>sync.WaitGroup</h3><p>如果只是单纯的等待所有任务完成，可以使用 <code>sync.WaitGroup</code>：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">   <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</span><br><span class="line">       wg.Add(<span class="number">1</span>)</span><br><span class="line">       <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">           fmt.Println(<span class="string">&quot;func run&quot;</span>)</span><br><span class="line">           time.Sleep(time.Second)</span><br><span class="line">           wg.Done()</span><br><span class="line">       &#125;()</span><br><span class="line">   &#125;</span><br><span class="line">   wg.Wait()</span><br><span class="line">   fmt.Println(<span class="string">&quot;main done&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h3><p>简单，但是传递的数据只能一写多读。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> stop <span class="type">bool</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">go</span> f()</span><br><span class="line">    time.Sleep(<span class="number">2</span> * time.Second)</span><br><span class="line">    stop = <span class="literal">false</span></span><br><span class="line">    time.Sleep(<span class="number">2</span> * time.Second)</span><br><span class="line">    fmt.Println(<span class="string">&quot;main done&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> stop &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;still run&quot;</span>)</span><br><span class="line">        time.Sleep(time.Second)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="channel"><a href="#channel" class="headerlink" title="channel"></a>channel</h3><p>CSP 并发编程模型（Communicating Sequential Process）。channel 在 Golang 中是核心类型。</p>
<p>Golang 的 select 机制在语言层面实现了类似 Linux 的 select 功能，可以监听多个文件描述符的读写事件，能够在事件发生时主动通知应用程序处理。 Golang 的 select 还可以设置 default，在监听的事件全部阻塞时执行。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    stop := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">bool</span>)</span><br><span class="line">    <span class="keyword">go</span> f(stop)</span><br><span class="line">    time.Sleep(<span class="number">2</span> * time.Second)</span><br><span class="line">    stop&lt;-<span class="literal">true</span></span><br><span class="line">    time.Sleep(<span class="number">2</span> * time.Second)</span><br><span class="line">    fmt.Println(<span class="string">&quot;main done&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">(stop <span class="keyword">chan</span> <span class="type">bool</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">            <span class="keyword">case</span> &lt;-stop:</span><br><span class="line">                fmt.Println(<span class="string">&quot;done&quot;</span>)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                fmt.Println(<span class="string">&quot;still run&quot;</span>)</span><br><span class="line">                time.Sleep(time.Second)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="context-上下文"><a href="#context-上下文" class="headerlink" title="context 上下文"></a>context 上下文</h3><p>Golang 的上下文是树状结构，通过 context.Background() 方法可以拿到上下文的根节点。常用方法有：</p>
<ul>
<li><p>func WithCancel(parent Context) (ctx Context, cancel CancelFunc)</p>
</li>
<li><p>func WithDeadline(parent Context, deadline time.Time) (Context, CancelFunc)</p>
</li>
<li><p>func WithTimeout(parent Context, timeout time.Duration) (Context, CancelFunc)</p>
</li>
<li><p>func WithValue(parent Context, key, val interface{}) Context</p>
</li>
</ul>
<h3 id="WithCancel"><a href="#WithCancel" class="headerlink" title="WithCancel"></a>WithCancel</h3><p>子上下文可以调用 Done 方法（返回 channel，可以通过 select 读取）检测是否有父节点调用 cancel。上层节点的 cancel 调用会沿着上下文树的边向下通知到每一个子节点。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ctx, myCancel := context.WithCancel(context.Background())</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> &#123;</span><br><span class="line">            <span class="keyword">select</span> &#123;</span><br><span class="line">                <span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">                    fmt.Println(<span class="string">&quot;ctx Done&quot;</span>)</span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    fmt.Println(<span class="string">&quot;goroutine continue&quot;</span>)</span><br><span class="line">                    time.Sleep(time.Second)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    time.Sleep(time.Second * <span class="number">2</span>)</span><br><span class="line">    myCancel()</span><br><span class="line">    time.Sleep(time.Second)</span><br><span class="line">    fmt.Println(<span class="string">&quot;main done&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="WithValue"><a href="#WithValue" class="headerlink" title="WithValue"></a>WithValue</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> favContextKey <span class="type">string</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ctx := context.WithValue(context.Background(), favContextKey(<span class="string">&quot;hello&quot;</span>), <span class="string">&quot;Go&quot;</span>)</span><br><span class="line">    f := <span class="function"><span class="keyword">func</span><span class="params">(ctx context.Context, k favContextKey)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> v := ctx.Value(k); v != <span class="literal">nil</span> &#123;</span><br><span class="line">            fmt.Println(<span class="string">&quot;found value:&quot;</span>, v)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        fmt.Println(<span class="string">&quot;value not found:&quot;</span>, k)</span><br><span class="line">    &#125;</span><br><span class="line">    f(ctx, favContextKey(<span class="string">&quot;hello&quot;</span>))</span><br><span class="line">    f(ctx, favContextKey(<span class="string">&quot;color&quot;</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>




]]></content>
      <categories>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>面试题</tag>
        <tag>Golang</tag>
      </tags>
  </entry>
</search>

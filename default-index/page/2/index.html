<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.7.2/css/all.min.css" integrity="sha256-dABdfBfUoC8vJUBOwGVdm8L9qlMWaHTIfXt+7GnZCIo=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.22.0","exturl":false,"sidebar":{"position":"right","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":true,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="record and sharing learning experiences">
<meta property="og:type" content="website">
<meta property="og:title" content="zhyyao">
<meta property="og:url" content="http://example.com/default-index/page/2/index.html">
<meta property="og:site_name" content="zhyyao">
<meta property="og:description" content="record and sharing learning experiences">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="zhyyao">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/default-index/page/2/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"default-index/page/2/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>zhyyao</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">zhyyao</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">zhyyao-blogs</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-首页"><a href="/" rel="section"><i class="fas fas fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-分类"><a href="/categories/" rel="section"><i class="fas fa-folder-open fa-fw"></i>分类</a></li><li class="menu-item menu-item-时间轴"><a href="/archives/" rel="section"><i class="fas fa-archive fa-fw"></i>时间轴</a></li><li class="menu-item menu-item-标签"><a href="/tags/" rel="section"><i class="fas fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-关于我"><a href="/about/" rel="section"><i class="fas fa-heart fa-fw"></i>关于我</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
      <div class="search-header">
        <span class="search-icon">
          <i class="fa fa-search"></i>
        </span>
        <div class="search-input-container">
          <input autocomplete="off" autocapitalize="off" maxlength="80"
                placeholder="搜索..." spellcheck="false"
                type="search" class="search-input">
        </div>
        <span class="popup-btn-close" role="button">
          <i class="fa fa-times-circle"></i>
        </span>
      </div>
      <div class="search-result-container">
        <div class="search-result-icon">
          <i class="fa fa-spinner fa-pulse fa-5x"></i>
        </div>
      </div>
    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="zhyyao"
      src="/images/self.jpeg">
  <p class="site-author-name" itemprop="name">zhyyao</p>
  <div class="site-description" itemprop="description">record and sharing learning experiences</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">15</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/yaoyizhuo" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;yaoyizhuo" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:yyzclick@126.com" title="E-Mail → mailto:yyzclick@126.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://blog.csdn.net/qq_45804375?spm=1000.2115.3001.5343" title="CSND → https:&#x2F;&#x2F;blog.csdn.net&#x2F;qq_45804375?spm&#x3D;1000.2115.3001.5343" rel="noopener me" target="_blank"><i class="fa-solid fa-pen-fancy fa-fw"></i>CSND</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">



  <script>
  # 保留原来的文章列表
    if (window.location.pathname === '/') {
      # window.location.href = '/home/';
      window.location.href = '/';
    }
  </script>
    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/02/03/technology/golang/memory_leak/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/self.jpeg">
      <meta itemprop="name" content="zhyyao">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="zhyyao">
      <meta itemprop="description" content="record and sharing learning experiences">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | zhyyao">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/02/03/technology/golang/memory_leak/" class="post-title-link" itemprop="url">Go内存泄漏</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-02-03 15:51:53" itemprop="dateCreated datePublished" datetime="2021-02-03T15:51:53+08:00">2021-02-03</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-02-26 14:20:24" itemprop="dateModified" datetime="2025-02-26T14:20:24+08:00">2025-02-26</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Golang/" itemprop="url" rel="index"><span itemprop="name">Golang</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="1-字符串截取"><a href="#1-字符串截取" class="headerlink" title="1.字符串截取"></a>1.字符串截取</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> str0 = <span class="string">&quot;12345678901234567890&quot;</span></span><br><span class="line">    str1 := str0[:<span class="number">10</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>以上代码，会有10字节的内存泄漏，我们知道，str0和str1底层共享内存，只要str1一直活跃，str0 就不会被回收，10字节的内存被使用，剩下的10字节内存就造成了临时性的内存泄漏，直到str1不再活跃</p>
<p>如果str0足够大，str1截取足够小，或者在高并发场景中频繁使用，那么可想而知，会造成临时性内存泄漏，对性能产生极大影响。</p>
<p>解决方法：</p>
<p>将需要截取的部分先转换成[]byte，再转换成string，但是这种方式会产生两个10字节的临时变量，string转换[]byte时产生一个10字节临时变量，[]byte转换string时产生一个10字节的临时变量</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> str0 = <span class="string">&quot;12345678901234567890&quot;</span></span><br><span class="line">    str1 := <span class="type">string</span>([]<span class="type">byte</span>(str0[:<span class="number">10</span>]))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="2-切片截取（和第一个类似）"><a href="#2-切片截取（和第一个类似）" class="headerlink" title="2.切片截取（和第一个类似）"></a>2.切片截取（和第一个类似）</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> s0 = []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;</span><br><span class="line">    s1 := s0[:<span class="number">5</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>解决方法：append</p>
<p>append函数是向 <code>slice里面追加一个或多个元素，然后返回一个和slice一样类型的slice（复制一份）</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> s0 = []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;</span><br><span class="line">    s1 := <span class="built_in">append</span>(s0[<span class="number">0</span>:<span class="number">0</span>], s0[:<span class="number">5</span>]...)</span><br><span class="line">    fmt.Println(s1)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-没有重置丢失的子切片元素中的指针"><a href="#3-没有重置丢失的子切片元素中的指针" class="headerlink" title="3.没有重置丢失的子切片元素中的指针"></a>3.没有重置丢失的子切片元素中的指针</h2><p>原切片元素为指针类型，原切片被截取后，丢失的子切片元素中的指针元素未被置空，导致内存泄漏</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> s0 = []*<span class="type">int</span>&#123;<span class="built_in">new</span>(<span class="type">int</span>), <span class="built_in">new</span>(<span class="type">int</span>), <span class="built_in">new</span>(<span class="type">int</span>), <span class="built_in">new</span>(<span class="type">int</span>), <span class="built_in">new</span>(<span class="type">int</span>)&#125;</span><br><span class="line">    s1 := s0[<span class="number">1</span>:<span class="number">3</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>解决方案：元素置空</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> s0 = []*<span class="type">int</span>&#123;<span class="built_in">new</span>(<span class="type">int</span>), <span class="built_in">new</span>(<span class="type">int</span>), <span class="built_in">new</span>(<span class="type">int</span>), <span class="built_in">new</span>(<span class="type">int</span>), <span class="built_in">new</span>(<span class="type">int</span>)&#125;</span><br><span class="line">    s0[<span class="number">0</span>], s0[<span class="number">3</span>], s0[<span class="number">4</span>] = <span class="literal">nil</span>, <span class="literal">nil</span>, <span class="literal">nil</span></span><br><span class="line">    s1 := s0[<span class="number">1</span>:<span class="number">3</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="4-数组传参"><a href="#4-数组传参" class="headerlink" title="4.数组传参"></a>4.数组传参</h2><p>Go数组是值类型，赋值和函数传参都会复制整个数组</p>
<p>如果我们在函数传参的时候用到了数组传参，且这个数组够大（我们假设数组大小为100万，64位机上消耗的内存约为800w字节，即8MB内存），或者该函数短时间内被调用N次，那么可想而知，会消耗大量内存，对性能产生极大的影响，如果短时间内分配大量内存，而又来不及GC，那么就会产生临时性的内存泄漏，对于高并发场景相当可怕。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> arrayA = [<span class="number">3</span>]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">    <span class="keyword">var</span> arrayB = [<span class="number">3</span>]<span class="type">int</span>&#123;&#125;</span><br><span class="line">    arrayB = arrayA</span><br><span class="line">    fmt.Printf(<span class="string">&quot;arrayA address: %p, arrayA value: %+v\n&quot;</span>, &amp;arrayA, arrayA)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;arrayB address: %p, arrayB value: %+v\n&quot;</span>, &amp;arrayB, arrayB)</span><br><span class="line">    array(arrayA)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">array</span><span class="params">(array [3]<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;array address: %p, array value: %+v\n&quot;</span>, &amp;array, array)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>解决方案：指针传参或者利用切片</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> arrayA = [<span class="number">3</span>]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">    <span class="keyword">var</span> arrayB = &amp;arrayA</span><br><span class="line">    fmt.Printf(<span class="string">&quot;arrayA address: %p, arrayA value: %+v\n&quot;</span>, &amp;arrayA, arrayA)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;arrayB address: %p, arrayB value: %+v\n&quot;</span>, arrayB, *arrayB)</span><br><span class="line">    arrayP(&amp;arrayA)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">arrayP</span><span class="params">(array *[3]<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;array address: %p, array value: %+v\n&quot;</span>, array, *array)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="5-goroutine"><a href="#5-goroutine" class="headerlink" title="5.goroutine"></a>5.goroutine</h2><p>“Go里面10次内存泄漏有9次都是goroutine泄漏引起的”</p>
<p>有些编码不当的情况下，goroutine被长期挂住，导致该协程中的内存也无法被释放，就会造成永久性的内存泄漏。例如协程结束时协程中的channel没有关闭，导致一直阻塞；例如协程中有死循环；等等</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ticker := time.NewTicker(time.Second * <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        &lt;-ticker.C</span><br><span class="line">        ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">100</span>; i++ &#123;</span><br><span class="line">                ch &lt;- i</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> v := <span class="keyword">range</span> ch &#123;</span><br><span class="line">            <span class="keyword">if</span> v == <span class="number">50</span> &#123;</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>解决方案：（涉及到goroutine之间的通信）</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ticker := time.NewTicker(time.Second * <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        &lt;-ticker.C</span><br><span class="line">        cxt, cancel := context.WithCancel(context.Background())</span><br><span class="line">        ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(cxt context.Context)</span></span> &#123;</span><br><span class="line">            <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">100</span>; i++ &#123;</span><br><span class="line">                <span class="keyword">select</span> &#123;</span><br><span class="line">                <span class="keyword">case</span> &lt;-cxt.Done():</span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">                <span class="keyword">case</span> ch &lt;- i:</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;(cxt)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> v := <span class="keyword">range</span> ch &#123;</span><br><span class="line">            <span class="keyword">if</span> v == <span class="number">50</span> &#123;</span><br><span class="line">                cancel()</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/02/03/technology/golang/memory_escape/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/self.jpeg">
      <meta itemprop="name" content="zhyyao">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="zhyyao">
      <meta itemprop="description" content="record and sharing learning experiences">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | zhyyao">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/02/03/technology/golang/memory_escape/" class="post-title-link" itemprop="url">Go内存逃逸分析</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-02-03 15:51:53" itemprop="dateCreated datePublished" datetime="2021-02-03T15:51:53+08:00">2021-02-03</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-02-26 12:57:18" itemprop="dateModified" datetime="2025-02-26T12:57:18+08:00">2025-02-26</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Golang/" itemprop="url" rel="index"><span itemprop="name">Golang</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="1-关于-堆和栈"><a href="#1-关于-堆和栈" class="headerlink" title="1. 关于 堆和栈"></a>1. 关于 堆和栈</h2><p>栈可以简单得理解成一次函数调用内部申请到的内存，它们会随着函数的返回把内存还给系统。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">F</span><span class="params">()</span></span> &#123;</span><br><span class="line">    temp := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>, <span class="number">20</span>)</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>类似于上面代码里面的temp变量，只是内函数内部申请的临时变量，并不会作为返回值返回，它就是被编译器申请到栈里面。 </p>
<p>申请到<strong>栈内存</strong>好处：函数返回直接释放，不会引起垃圾回收，对性能没有影响。</p>
<p>再来看看堆得情况之一如下代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">F</span><span class="params">()</span></span> []<span class="type">int</span>&#123;</span><br><span class="line">    a := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>, <span class="number">20</span>)</span><br><span class="line">    <span class="keyword">return</span> a</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而上面这段代码，申请的代码一模一样，但是申请后作为返回值返回了，编译器会认为变量之后还会被使用，当函数返回之后并不会将其内存归还，那么它就会被申请到 堆 上面了。</p>
<p><strong>申请到堆上面的内存才会引起垃圾回收，如果这个过程（特指垃圾回收不断被触发）过于高频就会导致 gc 压力过大，程序性能出问题。</strong></p>
<p>我们再看看如下几个例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">F</span><span class="params">()</span></span> &#123;</span><br><span class="line">    a := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>, <span class="number">20</span>)     <span class="comment">// 栈 空间小</span></span><br><span class="line">    b := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>, <span class="number">20000</span>) <span class="comment">// 堆 空间过大</span></span><br><span class="line"></span><br><span class="line">    l := <span class="number">20</span></span><br><span class="line">    c := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>, l) <span class="comment">// 堆 动态分配不定空间</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>像是 b 这种 即使是临时变量，申请过大也会在堆上面申请。对于 c 编译器对于这种不定长度的申请方式，也会在堆上面申请，即使申请的长度很短。</p>
<h2 id="2-逃逸分析（Escape-analysis）"><a href="#2-逃逸分析（Escape-analysis）" class="headerlink" title="2. 逃逸分析（Escape analysis）"></a>2. 逃逸分析（Escape analysis）</h2><p>逃逸分析指的是由编译器决定内存分配的位置,不需要由程序员指定.</p>
<p>在函数中申请一个新的对象</p>
<ul>
<li><p><strong>如果申请到栈中,则函数执行结束可以自动将内存回收.</strong></p>
</li>
<li><p><strong>如果分配到堆,则函数执行结束就可以交给GC处理.</strong></p>
</li>
</ul>
<h2 id="3-逃逸场景（什么情况才分配到堆中）"><a href="#3-逃逸场景（什么情况才分配到堆中）" class="headerlink" title="3. 逃逸场景（什么情况才分配到堆中）"></a>3. 逃逸场景（什么情况才分配到堆中）</h2><h3 id="3-1-指针逃逸"><a href="#3-1-指针逃逸" class="headerlink" title="3.1 指针逃逸"></a>3.1 指针逃逸</h3><p>Go可以返回局部变量指针，这其实是一个典型的变量逃逸案例，示例代码如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="type">string</span></span><br><span class="line">    Age  <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">StudentRegister</span><span class="params">(name <span class="type">string</span>, age <span class="type">int</span>)</span></span> *Student &#123;</span><br><span class="line">    s := <span class="built_in">new</span>(Student) <span class="comment">//局部变量s逃逸到堆</span></span><br><span class="line"></span><br><span class="line">    s.Name = name</span><br><span class="line">    s.Age = age</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    StudentRegister(<span class="string">&quot;Jim&quot;</span>, <span class="number">18</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>虽然 在函数 StudentRegister() 内部 s 为局部变量，其值通过函数返回值返回，s 本身为一指针，其指向的内存地址不会是栈而是堆，这就是典型的逃逸案例。</p>
<p>终端运行命令查看逃逸分析日志：</p>
<figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go build -gcflags=-m</span><br></pre></td></tr></table></figure>


<img data-src="/2021/02/03/technology/golang/memory_escape/img_1.png" class="" title="image.png">

<p>可见在StudentRegister()函数中，也即代码第9行显示”escapes to heap”，代表该行内存分配发生了逃逸现象。</p>
<h3 id="3-2-栈空间不足逃逸（空间开辟过大）"><a href="#3-2-栈空间不足逃逸（空间开辟过大）" class="headerlink" title="3.2 栈空间不足逃逸（空间开辟过大）"></a>3.2 栈空间不足逃逸（空间开辟过大）</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Slice</span><span class="params">()</span></span> &#123;</span><br><span class="line">    s := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">1000</span>, <span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> index, _ := <span class="keyword">range</span> s &#123;</span><br><span class="line">        s[index] = index</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    Slice()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>上面代码Slice()函数中分配了一个1000个长度的切片，是否逃逸取决于栈空间是否足够大。 直接查看编译提示，如下：</p>
<img data-src="/2021/02/03/technology/golang/memory_escape/img_2.png" class="" title="image.png">

<p>所以只是1000的长度还不足以发生逃逸现象。然后就x10倍吧</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Slice</span><span class="params">()</span></span> &#123;</span><br><span class="line">    s := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">10000</span>, <span class="number">10000</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> index, _ := <span class="keyword">range</span> s &#123;</span><br><span class="line">        s[index] = index</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    Slice()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>分析如下：当切片长度扩大到10000时就会逃逸。实际上当栈空间不足以存放当前对象时或无法判断当前切片长度时会将对象分配到堆中。</p>
<h3 id="3-3-动态类型逃逸（不确定长度大小）"><a href="#3-3-动态类型逃逸（不确定长度大小）" class="headerlink" title="3.3 动态类型逃逸（不确定长度大小）"></a>3.3 动态类型逃逸（不确定长度大小）</h3><p>很多函数参数为interface类型，比如fmt.Println(a …interface{})，编译期间很难确定其参数的具体类型，也能产生逃逸。</p>
<p>如下代码所示：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    s := <span class="string">&quot;Escape&quot;</span></span><br><span class="line">    fmt.Println(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>逃逸分下如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">D:\SourceCode\GoExpert\src&gt;go build -gcflags=-m</span><br><span class="line"># _/D_/SourceCode/GoExpert/src</span><br><span class="line">.\main.go:7: s escapes to heap</span><br><span class="line">.\main.go:7: main ... argument does not escape</span><br></pre></td></tr></table></figure>


<p>又或者像前面提到的例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">F</span><span class="params">()</span></span> &#123;</span><br><span class="line">    a := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>, <span class="number">20</span>)     <span class="comment">// 栈 空间小</span></span><br><span class="line">    b := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>, <span class="number">20000</span>) <span class="comment">// 堆 空间过大 逃逸</span></span><br><span class="line"></span><br><span class="line">    l := <span class="number">20</span></span><br><span class="line">    c := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>, l) <span class="comment">// 堆 动态分配不定空间 逃逸</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="3-4-闭包引用对象逃逸"><a href="#3-4-闭包引用对象逃逸" class="headerlink" title="3.4 闭包引用对象逃逸"></a>3.4 闭包引用对象逃逸</h3><p>Fibonacci数列的函数：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Fibonacci</span><span class="params">()</span></span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    a, b := <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">int</span> &#123;</span><br><span class="line">        a, b = b, a+b</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    f := Fibonacci()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;Fibonacci: %d\n&quot;</span>, f())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>输出如下：</p>
<figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> ~/go/src/gitHub/test/pool  go run main.go</span><br><span class="line">Fibonacci: 1</span><br><span class="line">Fibonacci: 1</span><br><span class="line">Fibonacci: 2</span><br><span class="line">Fibonacci: 3</span><br><span class="line">Fibonacci: 5</span><br><span class="line">Fibonacci: 8</span><br><span class="line">Fibonacci: 13</span><br><span class="line">Fibonacci: 21</span><br><span class="line">Fibonacci: 34</span><br><span class="line">Fibonacci: 55</span><br></pre></td></tr></table></figure>


<p>逃逸如下：</p>
<figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> ~/go/src/gitHub/test/pool  go build -gcflags=-m</span><br><span class="line"># gitHub/test/pool</span><br><span class="line">./main.go:7:9: can inline Fibonacci.func1</span><br><span class="line">./main.go:7:9: func literal escapes to heap</span><br><span class="line">./main.go:7:9: func literal escapes to heap</span><br><span class="line">./main.go:8:10: &amp;b escapes to heap</span><br><span class="line">./main.go:6:5: moved to heap: b</span><br><span class="line">./main.go:8:13: &amp;a escapes to heap</span><br><span class="line">./main.go:6:2: moved to heap: a</span><br><span class="line">./main.go:17:34: f() escapes to heap</span><br><span class="line">./main.go:17:13: main ... argument does not escape</span><br></pre></td></tr></table></figure>


<p>Fibonacci()函数中原本属于局部变量的a和b由于闭包的引用，不得不将二者放到堆上，以致产生逃逸。</p>
<h3 id="逃逸分析的作用是什么呢？"><a href="#逃逸分析的作用是什么呢？" class="headerlink" title="逃逸分析的作用是什么呢？"></a>逃逸分析的作用是什么呢？</h3><ol>
<li><p>逃逸分析的好处是为了减少gc的压力，不逃逸的对象分配在栈上，当函数返回时就回收了资源，不需要gc标记清除。</p>
</li>
<li><p>逃逸分析完后可以确定哪些变量可以分配在栈上，栈的分配比堆快，性能好(逃逸的局部变量会在堆上分配 ,而没有发生逃逸的则有编译器在栈上分配)。</p>
</li>
<li><p>同步消除，如果你定义的对象的方法上有同步锁，但在运行时，却只有一个线程在访问，此时逃逸分析后的机器码，会去掉同步锁运行。</p>
</li>
</ol>
<h3 id="逃逸总结："><a href="#逃逸总结：" class="headerlink" title="逃逸总结："></a>逃逸总结：</h3><ul>
<li><p>栈上分配内存比在堆中分配内存有更高的效率</p>
</li>
<li><p>栈上分配的内存不需要GC处理</p>
</li>
<li><p>堆上分配的内存使用完毕会交给GC处理</p>
</li>
<li><p>逃逸分析目的是决定内分配地址是栈还是堆</p>
</li>
<li><p>逃逸分析在编译阶段完成</p>
</li>
</ul>
<p>提问：函数传递指针真的比传值效率高吗？</p>
<blockquote>
<p>我们知道传递指针可以减少底层值的拷贝，可以提高效率，但是如果拷贝的数据量小，由于指针传递会产生逃逸，可能会使用堆，也可能会增加GC的负担，所以传递指针不一定是高效的。</p>
</blockquote>
<p>在官网 (golang.org) FAQ 上有一个关于变量分配的问题如下：</p>
<blockquote>
<p>From a correctness standpoint, you don’t need to know. Each variable in Go exists as long as there are references to it. The storage location chosen by the implementation is irrelevant to the semantics of the language.</p>
</blockquote>
<blockquote>
<p>The storage location does have an effect on writing efficient programs. When possible, the Go compilers will allocate variables that are local to a function in that function’s stack frame.</p>
</blockquote>
<blockquote>
<p>However, if the compiler cannot prove that the variable is not referenced after the function returns, then the compiler must allocate the variable on the garbage-collected heap to avoid dangling pointer errors. Also, if a local variable is very large, it might make more sense to store it on the heap rather than the stack.</p>
</blockquote>
<blockquote>
<p>In the current compilers, if a variable has its address taken, that variable is a candidate for allocation on the heap. However, a basic escape analysis recognizes some cases when such variables will not live past the return from the function and can reside on the stack.</p>
</blockquote>
<p>翻译如下：</p>
<p>如何得知变量是分配在栈（stack）上还是堆（heap）上？</p>
<p>准确地说，你并不需要知道。Golang 中的变量只要被引用就一直会存活，存储在堆上还是栈上由内部实现决定而和具体的语法没有关系。</p>
<p>知道变量的存储位置确实和效率编程有关系。如果可能，Golang 编译器会将函数的局部变量分配到函数栈帧（stack frame）上。 然而，如果编译器不能确保变量在函数 return之后不再被引用，编译器就会将变量分配到堆上。而且，如果一个局部变量非常大，那么它也应该被分配到堆上而不是栈上。</p>
<p>当前情况下，如果一个变量被取地址，那么它就有可能被分配到堆上。然而，还要对这些变量做逃逸分析，如果函数return之后，变量不再被引用，则将其分配到栈上。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/02/03/technology/golang/memory_to_its/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/self.jpeg">
      <meta itemprop="name" content="zhyyao">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="zhyyao">
      <meta itemprop="description" content="record and sharing learning experiences">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | zhyyao">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/02/03/technology/golang/memory_to_its/" class="post-title-link" itemprop="url">Go内存对齐</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-02-03 15:51:53" itemprop="dateCreated datePublished" datetime="2021-02-03T15:51:53+08:00">2021-02-03</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-02-26 14:20:44" itemprop="dateModified" datetime="2025-02-26T14:20:44+08:00">2025-02-26</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Golang/" itemprop="url" rel="index"><span itemprop="name">Golang</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="为什么要内存对齐？"><a href="#为什么要内存对齐？" class="headerlink" title="为什么要内存对齐？"></a>为什么要内存对齐？</h2><ul>
<li><p>平台（移植性）原因：不是所有的硬件平台都能够访问任意地址上的任意数据。例如：特定的硬件平台只允许在特定地址获取特定类型的数据，否则会导致异常情况</p>
</li>
<li><p>性能原因：若访问未对齐的内存，将会导致 CPU 进行两次内存访问，并且要花费额外的时钟周期来处理对齐及运算。而本身就对齐的内存仅需要一次访问就可以完成读取动作</p>
</li>
</ul>
<h2 id="成员对齐"><a href="#成员对齐" class="headerlink" title="成员对齐"></a>成员对齐</h2><figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">    fmt.Printf(&quot;bool align: %d\n&quot;, unsafe.Alignof(bool(true)))</span><br><span class="line">    fmt.Printf(&quot;int32 align: %d\n&quot;, unsafe.Alignof(int32(0)))</span><br><span class="line">    fmt.Printf(&quot;int8 align: %d\n&quot;, unsafe.Alignof(int8(0)))</span><br><span class="line">    fmt.Printf(&quot;int64 align: %d\n&quot;, unsafe.Alignof(int64(0)))</span><br><span class="line">    fmt.Printf(&quot;byte align: %d\n&quot;, unsafe.Alignof(byte(0)))</span><br><span class="line">    fmt.Printf(&quot;string align: %d\n&quot;, unsafe.Alignof(&quot;EDDYCJY&quot;))</span><br><span class="line">    fmt.Printf(&quot;map align: %d\n&quot;, unsafe.Alignof(map[string]string&#123;&#125;))</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>输出结果：</p>
<figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">bool align: 1</span><br><span class="line">int32 align: 4</span><br><span class="line">int8 align: 1</span><br><span class="line">int64 align: 8</span><br><span class="line">byte align: 1</span><br><span class="line">string align: 8</span><br><span class="line">map align: 8</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>在 Go 中可以调用 <code>unsafe.Alignof</code> 来返回相应类型的对齐系数。通过观察输出结果，可得知基本都是 <code>2^n</code>，最大也不会超过 8。这是因为我手提（64 位）编译器默认对齐系数是 8，因此最大值不会超过这个数</p>
<h2 id=""><a href="#" class="headerlink" title=""></a></h2><h2 id="整体对齐"><a href="#整体对齐" class="headerlink" title="整体对齐"></a>整体对齐</h2><p>在上小节中，提到了结构体中的成员变量要做字节对齐。那么想当然身为最终结果的结构体，也是需要做字节对齐的</p>
<h2 id="对齐规则"><a href="#对齐规则" class="headerlink" title="对齐规则"></a>对齐规则</h2><ul>
<li><p>结构体的成员变量，第一个成员变量的偏移量为 0。往后的每个成员变量的对齐值必须为<strong>编译器默认对齐长度</strong>（<code>#pragma pack(n)</code>）或<strong>当前成员变量类型的长度</strong>（<code>unsafe.Sizeof</code>），取<strong>最小值作为当前类型的对齐值</strong>。其偏移量必须为对齐值的整数倍</p>
</li>
<li><p>结构体本身，对齐值必须为<strong>编译器默认对齐长度</strong>（<code>#pragma pack(n)</code>）或<strong>结构体的所有成员变量类型中的最大长度</strong>，取<strong>最大数的最小整数倍</strong>作为对齐值</p>
</li>
</ul>
<p>结合以上两点，可得知若<strong>编译器默认对齐长度</strong>（<code>#pragma pack(n)</code>）超过结构体内成员变量的类型最大长度时，默认对齐长度是没有任何意义的</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/02/02/technology/golang/interview_issue/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/self.jpeg">
      <meta itemprop="name" content="zhyyao">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="zhyyao">
      <meta itemprop="description" content="record and sharing learning experiences">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | zhyyao">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/02/02/technology/golang/interview_issue/" class="post-title-link" itemprop="url">Go高频面试题</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-02-02 15:51:53" itemprop="dateCreated datePublished" datetime="2021-02-02T15:51:53+08:00">2021-02-02</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-02-26 12:57:18" itemprop="dateModified" datetime="2025-02-26T12:57:18+08:00">2025-02-26</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Golang/" itemprop="url" rel="index"><span itemprop="name">Golang</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="1-关于select"><a href="#1-关于select" class="headerlink" title="1.关于select"></a>1.关于select</h2><ul>
<li><p>select是Go语言中的一个控制语句，类似于switch，但是select主要用于通道操作（每一个case必须是一个通信操作，要么接收，要么发送）。 </p>
</li>
<li><p>select会随机选择一个可以运行的case；如果没有case可运行，那么将会阻塞，直到有一个case可以运行。</p>
</li>
</ul>
<h2 id="2-变量会怎么分配："><a href="#2-变量会怎么分配：" class="headerlink" title="2.变量会怎么分配："></a>2.变量会怎么分配：</h2><p>变量分配在栈还是堆是由go编译器自己控制的；编译时，会做逃逸分析，当变量作用域没有跑出函数的范围，就放在栈上；反之则必须放在堆上。<a href="/2021/02/03/technology/golang/memory_escape/">Go内存逃逸分析</a></p>
<h2 id="3-GC垃圾回收"><a href="#3-GC垃圾回收" class="headerlink" title="3.GC垃圾回收"></a>3.GC垃圾回收</h2><ul>
<li><p>v1.3：标记清除：整体过程需要启动STW，效率极低。</p>
</li>
<li><p>v1.5：三色标记法：堆空间启动写屏障，栈空间不启动，全部扫描之后，需要重新扫描一次栈(需要STW)，效率普通</p>
</li>
<li><p>v1.8：混合写屏障机制： 栈空间不启动，堆空间启动。整个过程几乎不需要STW，效率较高 <a href="/2021/02/03/technology/golang/gc_recycle/">Go垃圾回收</a></p>
</li>
</ul>
<h2 id="4-协程调度GPM"><a href="#4-协程调度GPM" class="headerlink" title="4.协程调度GPM"></a>4.协程调度GPM</h2><p>G：就是个goroutine（调度系统最基本的单位），里面除了存放本goroutine信息（执行stack信息；状态信息；所在的任务函数信息等）与所在P的绑定等信息。</p>
<p>P：就是process，管理着一组goroutine队列，存储当前goroutine运行的上下文环境。</p>
<p>M：machine，代表着真正的执行计算资源。</p>
<p>P管理着一组G在M上执行。<a href="/2021/02/03/technology/golang/gpm_explain/">GPM轻量理解</a></p>
<ul>
<li><p>每一个运行的M都必须绑定一个P，线程M创建后会检查并执行G对象</p>
</li>
<li><p>每一个P都保存着一个G队列</p>
</li>
<li><p>除了P保存的G队列外，还有一个全局G队列</p>
</li>
<li><p>M从队列中取出G并执行</p>
</li>
<li><p>P的个数就是 GOMAXPROCS(256)，一般不做修改</p>
</li>
<li><p>M的个数和P的个数不一定一样多</p>
</li>
<li><p>P是一个全局数组（255）来保存，并且维护者一个全局的P空闲链表</p>
</li>
</ul>
<h2 id="5-runtime机制"><a href="#5-runtime机制" class="headerlink" title="5.runtime机制"></a>5.runtime机制</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/futurewu/article/details/104692651?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522162220408116780262566000%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=162220408116780262566000&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_v2~rank_v29-2-104692651.first_rank_v2_pc_rank_v29&utm_term=golang+%E7%9A%84+runtime+%E6%9C%BA%E5%88%B6&spm=1018.2226.3001.4187">runtime机制</a></p>
<p>runtime负责：管理调度，垃圾回收以及运行环境等。。Go语言的goroutine，channel这些高级功能都需要runtime的支持。</p>
<p>如何运行：用户编译代码后，runtime和编译后的代码会被静态链接起来，形成一个可执行文件。runtime通过接口函数调用来管理goroutine，channel这些高级功能；而且从用户代码调用操作系统的API调用会被runtime拦截处理。</p>
<p>组成：一个重要组成部分是goroutine scheduler ，它负责追踪调度goroutine运行，实际上是从应用程序的process所属的thread pool（线程池）中分配一个thread来执行这个goroutine。因此，每个goroutine只有分配到一个OS thread才能运行。</p>
<h2 id="6-make和new的区别"><a href="#6-make和new的区别" class="headerlink" title="6.make和new的区别"></a>6.make和new的区别</h2><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/ghj1976/archive/2013/02/12/2910384.html">区别</a></p>
<p>make：返回初始化后的值。make是引用类型初始化的方法；常用于slice,map,channle。make(T…)</p>
<p>new：返回指针，即new(T)返回的是*T</p>
<h2 id="7-channel有缓冲和无缓冲"><a href="#7-channel有缓冲和无缓冲" class="headerlink" title="7.channel有缓冲和无缓冲"></a>7.channel有缓冲和无缓冲</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/sgsgy5/article/details/82054902?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522162227719016780262526931%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=162227719016780262526931&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-82054902.first_rank_v2_pc_rank_v29&utm_term=%E6%9C%89%E7%BC%93%E5%86%B2channel&spm=1018.2226.3001.4187">有无缓冲</a></p>
<p>无缓冲：channel接收阻数据塞直到读取数据；channel发送阻塞直到数据被接收</p>
<p>有缓冲：当缓冲满时，channel接收数据阻塞；当缓冲空时，channel发送数据阻塞</p>
<p>无缓冲的  就是一个送信人去你家门口送信 ，你不在家 他不走，你一定要接下信，他才会走。</p>
<p>无缓冲保证信能到你手上（同步）</p>
<p>有缓冲的 就是一个送信人去你家仍到你家的信箱 转身就走 ，除非你的信箱满了 他必须等信箱空下来。</p>
<p>有缓冲的 保证 信能进你家的邮箱（非同步）</p>
<h2 id="8-并发方式和退出"><a href="#8-并发方式和退出" class="headerlink" title="8.并发方式和退出"></a>8.并发方式和退出</h2><p>并发：通常使用无缓冲chan来实现goroutine来是实现</p>
<p>退出：使用for-range来退出；使用，ok来退出；使用退出通道来退出</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// for-range是使用频率很高的结构，常用它来遍历数据，**range能够感知channel的关闭，当channel被发送数据的协程关闭时，range就会结束**，接着退出for循环。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    inCh := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(in &lt;-<span class="keyword">chan</span> <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">        <span class="comment">// Using for-range to exit goroutine</span></span><br><span class="line">        <span class="comment">// range has the ability to detect the close/end of a channel</span></span><br><span class="line">        <span class="keyword">for</span> x := <span class="keyword">range</span> in &#123;</span><br><span class="line">            fmt.Printf(<span class="string">&quot;Process %d\n&quot;</span>, x)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;(inCh)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用一个专门的通道，发送退出的信号</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">worker</span><span class="params">(stopCh &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">defer</span> fmt.Println(<span class="string">&quot;worker exit&quot;</span>)</span><br><span class="line">        <span class="comment">// Using stop channel explicit exit</span></span><br><span class="line">        <span class="keyword">for</span> &#123;</span><br><span class="line">            <span class="keyword">select</span> &#123;</span><br><span class="line">            <span class="keyword">case</span> &lt;-stopCh:</span><br><span class="line">                fmt.Println(<span class="string">&quot;Recv stop signal&quot;</span>)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">case</span> &lt;-t.C:</span><br><span class="line">                fmt.Println(<span class="string">&quot;Working .&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="9-interface-技巧"><a href="#9-interface-技巧" class="headerlink" title="9.interface()技巧"></a>9.interface()技巧</h2><ul>
<li>空接口    可以存放任意类型的数据</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    data := <span class="built_in">make</span>([]<span class="keyword">interface</span>&#123;&#125;, <span class="number">3</span>)</span><br><span class="line">    intData := <span class="number">1</span></span><br><span class="line">    stringData := <span class="string">&quot;abc&quot;</span></span><br><span class="line">    boolData := <span class="literal">true</span></span><br><span class="line">    data[<span class="number">0</span>] = intData</span><br><span class="line">    data[<span class="number">1</span>] = stringData</span><br><span class="line">    data[<span class="number">2</span>] = boolData</span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> data &#123;</span><br><span class="line">        fmt.Println(v)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<ul>
<li>接口嵌套</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ReadWrite <span class="keyword">interface</span> &#123;</span><br><span class="line">    Read(b Buffer) <span class="type">bool</span></span><br><span class="line">    Write(b Buffer) <span class="type">bool</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Lock <span class="keyword">interface</span> &#123;</span><br><span class="line">    Lock()</span><br><span class="line">    Unlock()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> File <span class="keyword">interface</span> &#123;   <span class="comment">// 除了上面两个还有一个额外的close()接口</span></span><br><span class="line">    ReadWrite</span><br><span class="line">    Lock</span><br><span class="line">    Close()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<ul>
<li>类型选择和断言</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> v, ok := varI.(T); ok &#123;  <span class="comment">// 判断是否是自己想要的类型</span></span><br><span class="line">    assertion</span><br><span class="line">    Process(v)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h2 id="10-用信道实现主程等待协程2s-如果超过2s-主程直接结束-不用sleep"><a href="#10-用信道实现主程等待协程2s-如果超过2s-主程直接结束-不用sleep" class="headerlink" title="10.用信道实现主程等待协程2s,如果超过2s,主程直接结束(不用sleep)"></a>10.用信道实现主程等待协程2s,如果超过2s,主程直接结束(不用sleep)</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    start := time.Now()</span><br><span class="line">    wait := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;做点东西&quot;</span>)</span><br><span class="line">        time.Sleep(<span class="number">3</span>* time.Second)</span><br><span class="line">        wait &lt;- <span class="number">2</span></span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="string">&quot;这里是主程序&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> nums := &lt;-wait:    <span class="comment">// 当超过(阻塞)2s后，不会再执行这个条件，直接执行下面的</span></span><br><span class="line">        fmt.Println(nums)</span><br><span class="line">    <span class="keyword">case</span> &lt;-time.After(<span class="number">2</span> * time.Second): </span><br><span class="line">        fmt.Println(<span class="string">&quot;2秒后&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(time.Since(start))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/02/01/technology/golang/go_basic/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/self.jpeg">
      <meta itemprop="name" content="zhyyao">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="zhyyao">
      <meta itemprop="description" content="record and sharing learning experiences">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | zhyyao">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/02/01/technology/golang/go_basic/" class="post-title-link" itemprop="url">Go语言底层基础知识</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-02-01 15:51:53" itemprop="dateCreated datePublished" datetime="2021-02-01T15:51:53+08:00">2021-02-01</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-02-28 13:58:27" itemprop="dateModified" datetime="2025-02-28T13:58:27+08:00">2025-02-28</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Golang/" itemprop="url" rel="index"><span itemprop="name">Golang</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>---------</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2021/02/01/technology/golang/go_basic/">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" title="上一页" aria-label="上一页" href="/default-index/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/default-index/">1</a><span class="page-number current">2</span>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>


  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">zhyyao</span>
  </div>

<div class="powered-by">
<i class="fa fa-user-md"></i><span id="busuanzi_container_site_uv">
  本站访客数:<span id="busuanzi_value_site_pv"></span>
</span>
</div>

<!--
  <div class="powered-by">由 Zhyyao 强力驱动
  </div>
-->

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdn.jsdelivr.net/npm/darkmode-js@1.5.7/lib/darkmode-js.min.js"></script>
<script>
var options = {
  bottom: '64px', // default: '32px'
  right: 'unset', // default: '32px'
  left: '32px', // default: 'unset'
  time: '0.5s', // default: '0.3s'
  mixColor: '#fff', // default: '#fff'
  backgroundColor: '#fff',  // default: '#fff'
  buttonColorDark: '#100f2c',  // default: '#100f2c'
  buttonColorLight: '#fff', // default: '#fff'
  saveInCookies: true, // default: true,
  label: '🌓', // default: ''
  autoMatchOsTheme: true // default: true
}
const darkmode = new Darkmode(options);
darkmode.showWidget();
</script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/next-theme-pjax/0.6.0/pjax.min.js" integrity="sha256-vxLn1tSKWD4dqbMRyv940UYw4sXgMtYcK6reefzZrao=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/lozad.js/1.16.0/lozad.min.js" integrity="sha256-mOFREFhqmHeQbXpK2lp4nA3qooVgACfh88fpJftLBbc=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/sidebar.js"></script><script src="/js/next-boot.js"></script><script src="/js/pjax.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>







  





</body>
</html>
